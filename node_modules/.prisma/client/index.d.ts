
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AuthUser
 * 
 */
export type AuthUser = $Result.DefaultSelection<Prisma.$AuthUserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Shop
 * 
 */
export type Shop = $Result.DefaultSelection<Prisma.$ShopPayload>
/**
 * Model Stream
 * 
 */
export type Stream = $Result.DefaultSelection<Prisma.$StreamPayload>
/**
 * Model Reel
 * 
 */
export type Reel = $Result.DefaultSelection<Prisma.$ReelPayload>
/**
 * Model ShopSocialHandle
 * 
 */
export type ShopSocialHandle = $Result.DefaultSelection<Prisma.$ShopSocialHandlePayload>
/**
 * Model ShopWhatsappLine
 * 
 */
export type ShopWhatsappLine = $Result.DefaultSelection<Prisma.$ShopWhatsappLinePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Penalty
 * 
 */
export type Penalty = $Result.DefaultSelection<Prisma.$PenaltyPayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model Agenda
 * 
 */
export type Agenda = $Result.DefaultSelection<Prisma.$AgendaPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model QuotaWallet
 * 
 */
export type QuotaWallet = $Result.DefaultSelection<Prisma.$QuotaWalletPayload>
/**
 * Model QuotaTransaction
 * 
 */
export type QuotaTransaction = $Result.DefaultSelection<Prisma.$QuotaTransactionPayload>
/**
 * Model PurchaseRequest
 * 
 */
export type PurchaseRequest = $Result.DefaultSelection<Prisma.$PurchaseRequestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthUserType: {
  CLIENT: 'CLIENT',
  SHOP: 'SHOP',
  ADMIN: 'ADMIN'
};

export type AuthUserType = (typeof AuthUserType)[keyof typeof AuthUserType]


export const AuthUserStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type AuthUserStatus = (typeof AuthUserStatus)[keyof typeof AuthUserStatus]


export const AdminRole: {
  SUPERADMIN: 'SUPERADMIN',
  MODERATOR: 'MODERATOR'
};

export type AdminRole = (typeof AdminRole)[keyof typeof AdminRole]


export const AdminStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type AdminStatus = (typeof AdminStatus)[keyof typeof AdminStatus]


export const ShopStatus: {
  PENDING_VERIFICATION: 'PENDING_VERIFICATION',
  ACTIVE: 'ACTIVE',
  AGENDA_SUSPENDED: 'AGENDA_SUSPENDED',
  HIDDEN: 'HIDDEN',
  BANNED: 'BANNED'
};

export type ShopStatus = (typeof ShopStatus)[keyof typeof ShopStatus]


export const StreamStatus: {
  UPCOMING: 'UPCOMING',
  LIVE: 'LIVE',
  FINISHED: 'FINISHED',
  MISSED: 'MISSED',
  CANCELLED: 'CANCELLED',
  BANNED: 'BANNED',
  PENDING_REPROGRAMMATION: 'PENDING_REPROGRAMMATION'
};

export type StreamStatus = (typeof StreamStatus)[keyof typeof StreamStatus]


export const SocialPlatform: {
  Instagram: 'Instagram',
  TikTok: 'TikTok',
  Facebook: 'Facebook',
  YouTube: 'YouTube'
};

export type SocialPlatform = (typeof SocialPlatform)[keyof typeof SocialPlatform]


export const ReportStatus: {
  OPEN: 'OPEN',
  VALIDATED: 'VALIDATED',
  REJECTED: 'REJECTED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const QuotaResource: {
  LIVE: 'LIVE',
  REEL: 'REEL'
};

export type QuotaResource = (typeof QuotaResource)[keyof typeof QuotaResource]


export const QuotaDirection: {
  CREDIT: 'CREDIT',
  DEBIT: 'DEBIT'
};

export type QuotaDirection = (typeof QuotaDirection)[keyof typeof QuotaDirection]


export const QuotaReason: {
  PLAN_BASE: 'PLAN_BASE',
  PURCHASE: 'PURCHASE',
  MANUAL_COMP: 'MANUAL_COMP',
  MISSED_BURN: 'MISSED_BURN',
  CANCEL_BURN: 'CANCEL_BURN',
  REPROGRAM: 'REPROGRAM',
  ADMIN_OVERRIDE: 'ADMIN_OVERRIDE',
  EXPIRED_REEL: 'EXPIRED_REEL',
  LEGACY_MIGRATION: 'LEGACY_MIGRATION'
};

export type QuotaReason = (typeof QuotaReason)[keyof typeof QuotaReason]


export const QuotaRefType: {
  PURCHASE: 'PURCHASE',
  LIVE: 'LIVE',
  ADMIN: 'ADMIN',
  SYSTEM: 'SYSTEM'
};

export type QuotaRefType = (typeof QuotaRefType)[keyof typeof QuotaRefType]


export const QuotaActorType: {
  ADMIN: 'ADMIN',
  SHOP: 'SHOP',
  SYSTEM: 'SYSTEM'
};

export type QuotaActorType = (typeof QuotaActorType)[keyof typeof QuotaActorType]


export const PurchaseType: {
  LIVE_PACK: 'LIVE_PACK',
  REEL_PACK: 'REEL_PACK',
  PLAN_UPGRADE: 'PLAN_UPGRADE'
};

export type PurchaseType = (typeof PurchaseType)[keyof typeof PurchaseType]


export const PurchaseStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type PurchaseStatus = (typeof PurchaseStatus)[keyof typeof PurchaseStatus]

}

export type AuthUserType = $Enums.AuthUserType

export const AuthUserType: typeof $Enums.AuthUserType

export type AuthUserStatus = $Enums.AuthUserStatus

export const AuthUserStatus: typeof $Enums.AuthUserStatus

export type AdminRole = $Enums.AdminRole

export const AdminRole: typeof $Enums.AdminRole

export type AdminStatus = $Enums.AdminStatus

export const AdminStatus: typeof $Enums.AdminStatus

export type ShopStatus = $Enums.ShopStatus

export const ShopStatus: typeof $Enums.ShopStatus

export type StreamStatus = $Enums.StreamStatus

export const StreamStatus: typeof $Enums.StreamStatus

export type SocialPlatform = $Enums.SocialPlatform

export const SocialPlatform: typeof $Enums.SocialPlatform

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type QuotaResource = $Enums.QuotaResource

export const QuotaResource: typeof $Enums.QuotaResource

export type QuotaDirection = $Enums.QuotaDirection

export const QuotaDirection: typeof $Enums.QuotaDirection

export type QuotaReason = $Enums.QuotaReason

export const QuotaReason: typeof $Enums.QuotaReason

export type QuotaRefType = $Enums.QuotaRefType

export const QuotaRefType: typeof $Enums.QuotaRefType

export type QuotaActorType = $Enums.QuotaActorType

export const QuotaActorType: typeof $Enums.QuotaActorType

export type PurchaseType = $Enums.PurchaseType

export const PurchaseType: typeof $Enums.PurchaseType

export type PurchaseStatus = $Enums.PurchaseStatus

export const PurchaseStatus: typeof $Enums.PurchaseStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AuthUsers
 * const authUsers = await prisma.authUser.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AuthUsers
   * const authUsers = await prisma.authUser.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.authUser`: Exposes CRUD operations for the **AuthUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthUsers
    * const authUsers = await prisma.authUser.findMany()
    * ```
    */
  get authUser(): Prisma.AuthUserDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<ExtArgs>;

  /**
   * `prisma.stream`: Exposes CRUD operations for the **Stream** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Streams
    * const streams = await prisma.stream.findMany()
    * ```
    */
  get stream(): Prisma.StreamDelegate<ExtArgs>;

  /**
   * `prisma.reel`: Exposes CRUD operations for the **Reel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reels
    * const reels = await prisma.reel.findMany()
    * ```
    */
  get reel(): Prisma.ReelDelegate<ExtArgs>;

  /**
   * `prisma.shopSocialHandle`: Exposes CRUD operations for the **ShopSocialHandle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopSocialHandles
    * const shopSocialHandles = await prisma.shopSocialHandle.findMany()
    * ```
    */
  get shopSocialHandle(): Prisma.ShopSocialHandleDelegate<ExtArgs>;

  /**
   * `prisma.shopWhatsappLine`: Exposes CRUD operations for the **ShopWhatsappLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopWhatsappLines
    * const shopWhatsappLines = await prisma.shopWhatsappLine.findMany()
    * ```
    */
  get shopWhatsappLine(): Prisma.ShopWhatsappLineDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.penalty`: Exposes CRUD operations for the **Penalty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Penalties
    * const penalties = await prisma.penalty.findMany()
    * ```
    */
  get penalty(): Prisma.PenaltyDelegate<ExtArgs>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs>;

  /**
   * `prisma.agenda`: Exposes CRUD operations for the **Agenda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agenda
    * const agenda = await prisma.agenda.findMany()
    * ```
    */
  get agenda(): Prisma.AgendaDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.quotaWallet`: Exposes CRUD operations for the **QuotaWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotaWallets
    * const quotaWallets = await prisma.quotaWallet.findMany()
    * ```
    */
  get quotaWallet(): Prisma.QuotaWalletDelegate<ExtArgs>;

  /**
   * `prisma.quotaTransaction`: Exposes CRUD operations for the **QuotaTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotaTransactions
    * const quotaTransactions = await prisma.quotaTransaction.findMany()
    * ```
    */
  get quotaTransaction(): Prisma.QuotaTransactionDelegate<ExtArgs>;

  /**
   * `prisma.purchaseRequest`: Exposes CRUD operations for the **PurchaseRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseRequests
    * const purchaseRequests = await prisma.purchaseRequest.findMany()
    * ```
    */
  get purchaseRequest(): Prisma.PurchaseRequestDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.0
   * Query Engine version: 12e25d8d06f6ea5a0252864dd9a03b1bb51f3022
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AuthUser: 'AuthUser',
    Admin: 'Admin',
    Client: 'Client',
    User: 'User',
    Shop: 'Shop',
    Stream: 'Stream',
    Reel: 'Reel',
    ShopSocialHandle: 'ShopSocialHandle',
    ShopWhatsappLine: 'ShopWhatsappLine',
    Review: 'Review',
    Report: 'Report',
    Penalty: 'Penalty',
    Favorite: 'Favorite',
    Agenda: 'Agenda',
    Notification: 'Notification',
    QuotaWallet: 'QuotaWallet',
    QuotaTransaction: 'QuotaTransaction',
    PurchaseRequest: 'PurchaseRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'authUser' | 'admin' | 'client' | 'user' | 'shop' | 'stream' | 'reel' | 'shopSocialHandle' | 'shopWhatsappLine' | 'review' | 'report' | 'penalty' | 'favorite' | 'agenda' | 'notification' | 'quotaWallet' | 'quotaTransaction' | 'purchaseRequest'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      AuthUser: {
        payload: Prisma.$AuthUserPayload<ExtArgs>
        fields: Prisma.AuthUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          findFirst: {
            args: Prisma.AuthUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          findMany: {
            args: Prisma.AuthUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>[]
          }
          create: {
            args: Prisma.AuthUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          createMany: {
            args: Prisma.AuthUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthUserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>[]
          }
          delete: {
            args: Prisma.AuthUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          update: {
            args: Prisma.AuthUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          deleteMany: {
            args: Prisma.AuthUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AuthUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AuthUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          aggregate: {
            args: Prisma.AuthUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuthUser>
          }
          groupBy: {
            args: Prisma.AuthUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuthUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthUserCountArgs<ExtArgs>,
            result: $Utils.Optional<AuthUserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Shop: {
        payload: Prisma.$ShopPayload<ExtArgs>
        fields: Prisma.ShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findFirst: {
            args: Prisma.ShopFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findMany: {
            args: Prisma.ShopFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          create: {
            args: Prisma.ShopCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          createMany: {
            args: Prisma.ShopCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          delete: {
            args: Prisma.ShopDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          update: {
            args: Prisma.ShopUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          deleteMany: {
            args: Prisma.ShopDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          aggregate: {
            args: Prisma.ShopAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShop>
          }
          groupBy: {
            args: Prisma.ShopGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopCountAggregateOutputType> | number
          }
        }
      }
      Stream: {
        payload: Prisma.$StreamPayload<ExtArgs>
        fields: Prisma.StreamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          findFirst: {
            args: Prisma.StreamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          findMany: {
            args: Prisma.StreamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>[]
          }
          create: {
            args: Prisma.StreamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          createMany: {
            args: Prisma.StreamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StreamCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>[]
          }
          delete: {
            args: Prisma.StreamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          update: {
            args: Prisma.StreamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          deleteMany: {
            args: Prisma.StreamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StreamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StreamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          aggregate: {
            args: Prisma.StreamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStream>
          }
          groupBy: {
            args: Prisma.StreamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StreamGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreamCountArgs<ExtArgs>,
            result: $Utils.Optional<StreamCountAggregateOutputType> | number
          }
        }
      }
      Reel: {
        payload: Prisma.$ReelPayload<ExtArgs>
        fields: Prisma.ReelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload>
          }
          findFirst: {
            args: Prisma.ReelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload>
          }
          findMany: {
            args: Prisma.ReelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload>[]
          }
          create: {
            args: Prisma.ReelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload>
          }
          createMany: {
            args: Prisma.ReelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReelCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload>[]
          }
          delete: {
            args: Prisma.ReelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload>
          }
          update: {
            args: Prisma.ReelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload>
          }
          deleteMany: {
            args: Prisma.ReelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReelPayload>
          }
          aggregate: {
            args: Prisma.ReelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReel>
          }
          groupBy: {
            args: Prisma.ReelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReelCountArgs<ExtArgs>,
            result: $Utils.Optional<ReelCountAggregateOutputType> | number
          }
        }
      }
      ShopSocialHandle: {
        payload: Prisma.$ShopSocialHandlePayload<ExtArgs>
        fields: Prisma.ShopSocialHandleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopSocialHandleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopSocialHandleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload>
          }
          findFirst: {
            args: Prisma.ShopSocialHandleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopSocialHandleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload>
          }
          findMany: {
            args: Prisma.ShopSocialHandleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload>[]
          }
          create: {
            args: Prisma.ShopSocialHandleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload>
          }
          createMany: {
            args: Prisma.ShopSocialHandleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopSocialHandleCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload>[]
          }
          delete: {
            args: Prisma.ShopSocialHandleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload>
          }
          update: {
            args: Prisma.ShopSocialHandleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload>
          }
          deleteMany: {
            args: Prisma.ShopSocialHandleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopSocialHandleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopSocialHandleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopSocialHandlePayload>
          }
          aggregate: {
            args: Prisma.ShopSocialHandleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShopSocialHandle>
          }
          groupBy: {
            args: Prisma.ShopSocialHandleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopSocialHandleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopSocialHandleCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopSocialHandleCountAggregateOutputType> | number
          }
        }
      }
      ShopWhatsappLine: {
        payload: Prisma.$ShopWhatsappLinePayload<ExtArgs>
        fields: Prisma.ShopWhatsappLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopWhatsappLineFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopWhatsappLineFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload>
          }
          findFirst: {
            args: Prisma.ShopWhatsappLineFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopWhatsappLineFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload>
          }
          findMany: {
            args: Prisma.ShopWhatsappLineFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload>[]
          }
          create: {
            args: Prisma.ShopWhatsappLineCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload>
          }
          createMany: {
            args: Prisma.ShopWhatsappLineCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopWhatsappLineCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload>[]
          }
          delete: {
            args: Prisma.ShopWhatsappLineDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload>
          }
          update: {
            args: Prisma.ShopWhatsappLineUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload>
          }
          deleteMany: {
            args: Prisma.ShopWhatsappLineDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopWhatsappLineUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopWhatsappLineUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopWhatsappLinePayload>
          }
          aggregate: {
            args: Prisma.ShopWhatsappLineAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShopWhatsappLine>
          }
          groupBy: {
            args: Prisma.ShopWhatsappLineGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopWhatsappLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopWhatsappLineCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopWhatsappLineCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>,
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Penalty: {
        payload: Prisma.$PenaltyPayload<ExtArgs>
        fields: Prisma.PenaltyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PenaltyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PenaltyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          findFirst: {
            args: Prisma.PenaltyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PenaltyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          findMany: {
            args: Prisma.PenaltyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          create: {
            args: Prisma.PenaltyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          createMany: {
            args: Prisma.PenaltyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PenaltyCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          delete: {
            args: Prisma.PenaltyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          update: {
            args: Prisma.PenaltyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          deleteMany: {
            args: Prisma.PenaltyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PenaltyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PenaltyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          aggregate: {
            args: Prisma.PenaltyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePenalty>
          }
          groupBy: {
            args: Prisma.PenaltyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PenaltyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PenaltyCountArgs<ExtArgs>,
            result: $Utils.Optional<PenaltyCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>,
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      Agenda: {
        payload: Prisma.$AgendaPayload<ExtArgs>
        fields: Prisma.AgendaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          findFirst: {
            args: Prisma.AgendaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          findMany: {
            args: Prisma.AgendaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>[]
          }
          create: {
            args: Prisma.AgendaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          createMany: {
            args: Prisma.AgendaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgendaCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>[]
          }
          delete: {
            args: Prisma.AgendaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          update: {
            args: Prisma.AgendaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          deleteMany: {
            args: Prisma.AgendaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AgendaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          aggregate: {
            args: Prisma.AgendaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgenda>
          }
          groupBy: {
            args: Prisma.AgendaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgendaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgendaCountArgs<ExtArgs>,
            result: $Utils.Optional<AgendaCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      QuotaWallet: {
        payload: Prisma.$QuotaWalletPayload<ExtArgs>
        fields: Prisma.QuotaWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotaWalletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotaWalletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload>
          }
          findFirst: {
            args: Prisma.QuotaWalletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotaWalletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload>
          }
          findMany: {
            args: Prisma.QuotaWalletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload>[]
          }
          create: {
            args: Prisma.QuotaWalletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload>
          }
          createMany: {
            args: Prisma.QuotaWalletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotaWalletCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload>[]
          }
          delete: {
            args: Prisma.QuotaWalletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload>
          }
          update: {
            args: Prisma.QuotaWalletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload>
          }
          deleteMany: {
            args: Prisma.QuotaWalletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuotaWalletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuotaWalletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaWalletPayload>
          }
          aggregate: {
            args: Prisma.QuotaWalletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuotaWallet>
          }
          groupBy: {
            args: Prisma.QuotaWalletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuotaWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotaWalletCountArgs<ExtArgs>,
            result: $Utils.Optional<QuotaWalletCountAggregateOutputType> | number
          }
        }
      }
      QuotaTransaction: {
        payload: Prisma.$QuotaTransactionPayload<ExtArgs>
        fields: Prisma.QuotaTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotaTransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotaTransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload>
          }
          findFirst: {
            args: Prisma.QuotaTransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotaTransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload>
          }
          findMany: {
            args: Prisma.QuotaTransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload>[]
          }
          create: {
            args: Prisma.QuotaTransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload>
          }
          createMany: {
            args: Prisma.QuotaTransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotaTransactionCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload>[]
          }
          delete: {
            args: Prisma.QuotaTransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload>
          }
          update: {
            args: Prisma.QuotaTransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload>
          }
          deleteMany: {
            args: Prisma.QuotaTransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuotaTransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuotaTransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuotaTransactionPayload>
          }
          aggregate: {
            args: Prisma.QuotaTransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuotaTransaction>
          }
          groupBy: {
            args: Prisma.QuotaTransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuotaTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotaTransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<QuotaTransactionCountAggregateOutputType> | number
          }
        }
      }
      PurchaseRequest: {
        payload: Prisma.$PurchaseRequestPayload<ExtArgs>
        fields: Prisma.PurchaseRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          findFirst: {
            args: Prisma.PurchaseRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          findMany: {
            args: Prisma.PurchaseRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
          }
          create: {
            args: Prisma.PurchaseRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          createMany: {
            args: Prisma.PurchaseRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseRequestCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
          }
          delete: {
            args: Prisma.PurchaseRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          update: {
            args: Prisma.PurchaseRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          aggregate: {
            args: Prisma.PurchaseRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePurchaseRequest>
          }
          groupBy: {
            args: Prisma.PurchaseRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    approvedPurchaseRequests: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedPurchaseRequests?: boolean | AdminCountOutputTypeCountApprovedPurchaseRequestsArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountApprovedPurchaseRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    favorites: number
    agenda: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    agenda?: boolean | UserCountOutputTypeCountAgendaArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ShopCountOutputType
   */

  export type ShopCountOutputType = {
    streams: number
    reels: number
    penalties: number
    socialHandles: number
    whatsappLines: number
    favorites: number
    quotaTransactions: number
    purchaseRequests: number
  }

  export type ShopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    streams?: boolean | ShopCountOutputTypeCountStreamsArgs
    reels?: boolean | ShopCountOutputTypeCountReelsArgs
    penalties?: boolean | ShopCountOutputTypeCountPenaltiesArgs
    socialHandles?: boolean | ShopCountOutputTypeCountSocialHandlesArgs
    whatsappLines?: boolean | ShopCountOutputTypeCountWhatsappLinesArgs
    favorites?: boolean | ShopCountOutputTypeCountFavoritesArgs
    quotaTransactions?: boolean | ShopCountOutputTypeCountQuotaTransactionsArgs
    purchaseRequests?: boolean | ShopCountOutputTypeCountPurchaseRequestsArgs
  }

  // Custom InputTypes
  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     */
    select?: ShopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountStreamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountReelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReelWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountPenaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenaltyWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountSocialHandlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopSocialHandleWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountWhatsappLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhatsappLineWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountQuotaTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotaTransactionWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountPurchaseRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
  }


  /**
   * Count Type StreamCountOutputType
   */

  export type StreamCountOutputType = {
    reports: number
    reviews: number
    agenda: number
  }

  export type StreamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | StreamCountOutputTypeCountReportsArgs
    reviews?: boolean | StreamCountOutputTypeCountReviewsArgs
    agenda?: boolean | StreamCountOutputTypeCountAgendaArgs
  }

  // Custom InputTypes
  /**
   * StreamCountOutputType without action
   */
  export type StreamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamCountOutputType
     */
    select?: StreamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StreamCountOutputType without action
   */
  export type StreamCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * StreamCountOutputType without action
   */
  export type StreamCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * StreamCountOutputType without action
   */
  export type StreamCountOutputTypeCountAgendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AuthUser
   */

  export type AggregateAuthUser = {
    _count: AuthUserCountAggregateOutputType | null
    _min: AuthUserMinAggregateOutputType | null
    _max: AuthUserMaxAggregateOutputType | null
  }

  export type AuthUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    userType: $Enums.AuthUserType | null
    status: $Enums.AuthUserStatus | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type AuthUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    userType: $Enums.AuthUserType | null
    status: $Enums.AuthUserStatus | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type AuthUserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    userType: number
    status: number
    createdAt: number
    lastLoginAt: number
    _all: number
  }


  export type AuthUserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    userType?: true
    status?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type AuthUserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    userType?: true
    status?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type AuthUserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    userType?: true
    status?: true
    createdAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type AuthUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthUser to aggregate.
     */
    where?: AuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthUsers to fetch.
     */
    orderBy?: AuthUserOrderByWithRelationInput | AuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthUsers
    **/
    _count?: true | AuthUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthUserMaxAggregateInputType
  }

  export type GetAuthUserAggregateType<T extends AuthUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthUser[P]>
      : GetScalarType<T[P], AggregateAuthUser[P]>
  }




  export type AuthUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthUserWhereInput
    orderBy?: AuthUserOrderByWithAggregationInput | AuthUserOrderByWithAggregationInput[]
    by: AuthUserScalarFieldEnum[] | AuthUserScalarFieldEnum
    having?: AuthUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthUserCountAggregateInputType | true
    _min?: AuthUserMinAggregateInputType
    _max?: AuthUserMaxAggregateInputType
  }

  export type AuthUserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    userType: $Enums.AuthUserType
    status: $Enums.AuthUserStatus
    createdAt: Date
    lastLoginAt: Date | null
    _count: AuthUserCountAggregateOutputType | null
    _min: AuthUserMinAggregateOutputType | null
    _max: AuthUserMaxAggregateOutputType | null
  }

  type GetAuthUserGroupByPayload<T extends AuthUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthUserGroupByOutputType[P]>
            : GetScalarType<T[P], AuthUserGroupByOutputType[P]>
        }
      >
    >


  export type AuthUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    userType?: boolean
    status?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    shop?: boolean | AuthUser$shopArgs<ExtArgs>
    admin?: boolean | AuthUser$adminArgs<ExtArgs>
    client?: boolean | AuthUser$clientArgs<ExtArgs>
  }, ExtArgs["result"]["authUser"]>

  export type AuthUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    userType?: boolean
    status?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["authUser"]>

  export type AuthUserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    userType?: boolean
    status?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }

  export type AuthUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | AuthUser$shopArgs<ExtArgs>
    admin?: boolean | AuthUser$adminArgs<ExtArgs>
    client?: boolean | AuthUser$clientArgs<ExtArgs>
  }
  export type AuthUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AuthUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthUser"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      userType: $Enums.AuthUserType
      status: $Enums.AuthUserStatus
      createdAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["authUser"]>
    composites: {}
  }

  type AuthUserGetPayload<S extends boolean | null | undefined | AuthUserDefaultArgs> = $Result.GetResult<Prisma.$AuthUserPayload, S>

  type AuthUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuthUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthUserCountAggregateInputType | true
    }

  export interface AuthUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthUser'], meta: { name: 'AuthUser' } }
    /**
     * Find zero or one AuthUser that matches the filter.
     * @param {AuthUserFindUniqueArgs} args - Arguments to find a AuthUser
     * @example
     * // Get one AuthUser
     * const authUser = await prisma.authUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AuthUserFindUniqueArgs<ExtArgs>>
    ): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AuthUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuthUserFindUniqueOrThrowArgs} args - Arguments to find a AuthUser
     * @example
     * // Get one AuthUser
     * const authUser = await prisma.authUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuthUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuthUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AuthUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserFindFirstArgs} args - Arguments to find a AuthUser
     * @example
     * // Get one AuthUser
     * const authUser = await prisma.authUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AuthUserFindFirstArgs<ExtArgs>>
    ): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AuthUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserFindFirstOrThrowArgs} args - Arguments to find a AuthUser
     * @example
     * // Get one AuthUser
     * const authUser = await prisma.authUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuthUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuthUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AuthUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthUsers
     * const authUsers = await prisma.authUser.findMany()
     * 
     * // Get first 10 AuthUsers
     * const authUsers = await prisma.authUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authUserWithIdOnly = await prisma.authUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuthUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuthUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AuthUser.
     * @param {AuthUserCreateArgs} args - Arguments to create a AuthUser.
     * @example
     * // Create one AuthUser
     * const AuthUser = await prisma.authUser.create({
     *   data: {
     *     // ... data to create a AuthUser
     *   }
     * })
     * 
    **/
    create<T extends AuthUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AuthUserCreateArgs<ExtArgs>>
    ): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AuthUsers.
     * @param {AuthUserCreateManyArgs} args - Arguments to create many AuthUsers.
     * @example
     * // Create many AuthUsers
     * const authUser = await prisma.authUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AuthUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuthUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthUsers and returns the data saved in the database.
     * @param {AuthUserCreateManyAndReturnArgs} args - Arguments to create many AuthUsers.
     * @example
     * // Create many AuthUsers
     * const authUser = await prisma.authUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthUsers and only return the `id`
     * const authUserWithIdOnly = await prisma.authUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AuthUserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AuthUserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a AuthUser.
     * @param {AuthUserDeleteArgs} args - Arguments to delete one AuthUser.
     * @example
     * // Delete one AuthUser
     * const AuthUser = await prisma.authUser.delete({
     *   where: {
     *     // ... filter to delete one AuthUser
     *   }
     * })
     * 
    **/
    delete<T extends AuthUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AuthUserDeleteArgs<ExtArgs>>
    ): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AuthUser.
     * @param {AuthUserUpdateArgs} args - Arguments to update one AuthUser.
     * @example
     * // Update one AuthUser
     * const authUser = await prisma.authUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AuthUserUpdateArgs<ExtArgs>>
    ): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AuthUsers.
     * @param {AuthUserDeleteManyArgs} args - Arguments to filter AuthUsers to delete.
     * @example
     * // Delete a few AuthUsers
     * const { count } = await prisma.authUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuthUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthUsers
     * const authUser = await prisma.authUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AuthUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthUser.
     * @param {AuthUserUpsertArgs} args - Arguments to update or create a AuthUser.
     * @example
     * // Update or create a AuthUser
     * const authUser = await prisma.authUser.upsert({
     *   create: {
     *     // ... data to create a AuthUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthUser we want to update
     *   }
     * })
    **/
    upsert<T extends AuthUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AuthUserUpsertArgs<ExtArgs>>
    ): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AuthUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserCountArgs} args - Arguments to filter AuthUsers to count.
     * @example
     * // Count the number of AuthUsers
     * const count = await prisma.authUser.count({
     *   where: {
     *     // ... the filter for the AuthUsers we want to count
     *   }
     * })
    **/
    count<T extends AuthUserCountArgs>(
      args?: Subset<T, AuthUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthUserAggregateArgs>(args: Subset<T, AuthUserAggregateArgs>): Prisma.PrismaPromise<GetAuthUserAggregateType<T>>

    /**
     * Group by AuthUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthUserGroupByArgs['orderBy'] }
        : { orderBy?: AuthUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthUser model
   */
  readonly fields: AuthUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends AuthUser$shopArgs<ExtArgs> = {}>(args?: Subset<T, AuthUser$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    admin<T extends AuthUser$adminArgs<ExtArgs> = {}>(args?: Subset<T, AuthUser$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    client<T extends AuthUser$clientArgs<ExtArgs> = {}>(args?: Subset<T, AuthUser$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AuthUser model
   */ 
  interface AuthUserFieldRefs {
    readonly id: FieldRef<"AuthUser", 'String'>
    readonly email: FieldRef<"AuthUser", 'String'>
    readonly passwordHash: FieldRef<"AuthUser", 'String'>
    readonly userType: FieldRef<"AuthUser", 'AuthUserType'>
    readonly status: FieldRef<"AuthUser", 'AuthUserStatus'>
    readonly createdAt: FieldRef<"AuthUser", 'DateTime'>
    readonly lastLoginAt: FieldRef<"AuthUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthUser findUnique
   */
  export type AuthUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUser to fetch.
     */
    where: AuthUserWhereUniqueInput
  }

  /**
   * AuthUser findUniqueOrThrow
   */
  export type AuthUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUser to fetch.
     */
    where: AuthUserWhereUniqueInput
  }

  /**
   * AuthUser findFirst
   */
  export type AuthUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUser to fetch.
     */
    where?: AuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthUsers to fetch.
     */
    orderBy?: AuthUserOrderByWithRelationInput | AuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthUsers.
     */
    cursor?: AuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthUsers.
     */
    distinct?: AuthUserScalarFieldEnum | AuthUserScalarFieldEnum[]
  }

  /**
   * AuthUser findFirstOrThrow
   */
  export type AuthUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUser to fetch.
     */
    where?: AuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthUsers to fetch.
     */
    orderBy?: AuthUserOrderByWithRelationInput | AuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthUsers.
     */
    cursor?: AuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthUsers.
     */
    distinct?: AuthUserScalarFieldEnum | AuthUserScalarFieldEnum[]
  }

  /**
   * AuthUser findMany
   */
  export type AuthUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUsers to fetch.
     */
    where?: AuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthUsers to fetch.
     */
    orderBy?: AuthUserOrderByWithRelationInput | AuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthUsers.
     */
    cursor?: AuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthUsers.
     */
    skip?: number
    distinct?: AuthUserScalarFieldEnum | AuthUserScalarFieldEnum[]
  }

  /**
   * AuthUser create
   */
  export type AuthUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthUser.
     */
    data: XOR<AuthUserCreateInput, AuthUserUncheckedCreateInput>
  }

  /**
   * AuthUser createMany
   */
  export type AuthUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthUsers.
     */
    data: AuthUserCreateManyInput | AuthUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthUser createManyAndReturn
   */
  export type AuthUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuthUsers.
     */
    data: AuthUserCreateManyInput | AuthUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthUser update
   */
  export type AuthUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthUser.
     */
    data: XOR<AuthUserUpdateInput, AuthUserUncheckedUpdateInput>
    /**
     * Choose, which AuthUser to update.
     */
    where: AuthUserWhereUniqueInput
  }

  /**
   * AuthUser updateMany
   */
  export type AuthUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthUsers.
     */
    data: XOR<AuthUserUpdateManyMutationInput, AuthUserUncheckedUpdateManyInput>
    /**
     * Filter which AuthUsers to update
     */
    where?: AuthUserWhereInput
  }

  /**
   * AuthUser upsert
   */
  export type AuthUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthUser to update in case it exists.
     */
    where: AuthUserWhereUniqueInput
    /**
     * In case the AuthUser found by the `where` argument doesn't exist, create a new AuthUser with this data.
     */
    create: XOR<AuthUserCreateInput, AuthUserUncheckedCreateInput>
    /**
     * In case the AuthUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthUserUpdateInput, AuthUserUncheckedUpdateInput>
  }

  /**
   * AuthUser delete
   */
  export type AuthUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter which AuthUser to delete.
     */
    where: AuthUserWhereUniqueInput
  }

  /**
   * AuthUser deleteMany
   */
  export type AuthUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthUsers to delete
     */
    where?: AuthUserWhereInput
  }

  /**
   * AuthUser.shop
   */
  export type AuthUser$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * AuthUser.admin
   */
  export type AuthUser$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * AuthUser.client
   */
  export type AuthUser$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * AuthUser without action
   */
  export type AuthUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    authUserId: string | null
    role: $Enums.AdminRole | null
    adminStatus: $Enums.AdminStatus | null
    createdAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    authUserId: string | null
    role: $Enums.AdminRole | null
    adminStatus: $Enums.AdminStatus | null
    createdAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    authUserId: number
    role: number
    adminStatus: number
    createdAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    authUserId?: true
    role?: true
    adminStatus?: true
    createdAt?: true
  }

  export type AdminMaxAggregateInputType = {
    authUserId?: true
    role?: true
    adminStatus?: true
    createdAt?: true
  }

  export type AdminCountAggregateInputType = {
    authUserId?: true
    role?: true
    adminStatus?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    authUserId: string
    role: $Enums.AdminRole
    adminStatus: $Enums.AdminStatus
    createdAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    authUserId?: boolean
    role?: boolean
    adminStatus?: boolean
    createdAt?: boolean
    authUser?: boolean | AuthUserDefaultArgs<ExtArgs>
    approvedPurchaseRequests?: boolean | Admin$approvedPurchaseRequestsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    authUserId?: boolean
    role?: boolean
    adminStatus?: boolean
    createdAt?: boolean
    authUser?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    authUserId?: boolean
    role?: boolean
    adminStatus?: boolean
    createdAt?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authUser?: boolean | AuthUserDefaultArgs<ExtArgs>
    approvedPurchaseRequests?: boolean | Admin$approvedPurchaseRequestsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authUser?: boolean | AuthUserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      authUser: Prisma.$AuthUserPayload<ExtArgs>
      approvedPurchaseRequests: Prisma.$PurchaseRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      authUserId: string
      role: $Enums.AdminRole
      adminStatus: $Enums.AdminStatus
      createdAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `authUserId`
     * const adminWithAuthUserIdOnly = await prisma.admin.findMany({ select: { authUserId: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `authUserId`
     * const adminWithAuthUserIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { authUserId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    authUser<T extends AuthUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthUserDefaultArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    approvedPurchaseRequests<T extends Admin$approvedPurchaseRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$approvedPurchaseRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly authUserId: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'AdminRole'>
    readonly adminStatus: FieldRef<"Admin", 'AdminStatus'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin.approvedPurchaseRequests
   */
  export type Admin$approvedPurchaseRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    cursor?: PurchaseRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    authUserId: string | null
    displayName: string | null
    avatarUrl: string | null
    createdAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    authUserId: string | null
    displayName: string | null
    avatarUrl: string | null
    createdAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    authUserId: number
    displayName: number
    avatarUrl: number
    createdAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    authUserId?: true
    displayName?: true
    avatarUrl?: true
    createdAt?: true
  }

  export type ClientMaxAggregateInputType = {
    authUserId?: true
    displayName?: true
    avatarUrl?: true
    createdAt?: true
  }

  export type ClientCountAggregateInputType = {
    authUserId?: true
    displayName?: true
    avatarUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    authUserId: string
    displayName: string | null
    avatarUrl: string | null
    createdAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    authUserId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    authUser?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    authUserId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    authUser?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    authUserId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authUser?: boolean | AuthUserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authUser?: boolean | AuthUserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      authUser: Prisma.$AuthUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      authUserId: string
      displayName: string | null
      avatarUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `authUserId`
     * const clientWithAuthUserIdOnly = await prisma.client.findMany({ select: { authUserId: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientCreateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `authUserId`
     * const clientWithAuthUserIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { authUserId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    authUser<T extends AuthUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthUserDefaultArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly authUserId: FieldRef<"Client", 'String'>
    readonly displayName: FieldRef<"Client", 'String'>
    readonly avatarUrl: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    agenda?: boolean | User$agendaArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    agenda?: boolean | User$agendaArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      agenda: Prisma.$AgendaPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends UserCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findMany'> | Null>;

    agenda<T extends User$agendaArgs<ExtArgs> = {}>(args?: Subset<T, User$agendaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'findMany'> | Null>;

    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.agenda
   */
  export type User$agendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    where?: AgendaWhereInput
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    cursor?: AgendaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Shop
   */

  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopAvgAggregateOutputType = {
    minimumPurchase: number | null
    streamQuota: number | null
    reelQuota: number | null
  }

  export type ShopSumAggregateOutputType = {
    minimumPurchase: number | null
    streamQuota: number | null
    reelQuota: number | null
  }

  export type ShopMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logoUrl: string | null
    website: string | null
    authUserId: string | null
    requiresEmailFix: boolean | null
    razonSocial: string | null
    cuit: string | null
    email: string | null
    password: string | null
    address: string | null
    minimumPurchase: number | null
    plan: string | null
    status: $Enums.ShopStatus | null
    statusReason: string | null
    statusChangedAt: Date | null
    agendaSuspendedUntil: Date | null
    agendaSuspendedByAdminId: string | null
    agendaSuspendedReason: string | null
    streamQuota: number | null
    reelQuota: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logoUrl: string | null
    website: string | null
    authUserId: string | null
    requiresEmailFix: boolean | null
    razonSocial: string | null
    cuit: string | null
    email: string | null
    password: string | null
    address: string | null
    minimumPurchase: number | null
    plan: string | null
    status: $Enums.ShopStatus | null
    statusReason: string | null
    statusChangedAt: Date | null
    agendaSuspendedUntil: Date | null
    agendaSuspendedByAdminId: string | null
    agendaSuspendedReason: string | null
    streamQuota: number | null
    reelQuota: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logoUrl: number
    website: number
    authUserId: number
    requiresEmailFix: number
    razonSocial: number
    cuit: number
    email: number
    password: number
    address: number
    addressDetails: number
    minimumPurchase: number
    paymentMethods: number
    plan: number
    status: number
    statusReason: number
    statusChangedAt: number
    agendaSuspendedUntil: number
    agendaSuspendedByAdminId: number
    agendaSuspendedReason: number
    streamQuota: number
    reelQuota: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopAvgAggregateInputType = {
    minimumPurchase?: true
    streamQuota?: true
    reelQuota?: true
  }

  export type ShopSumAggregateInputType = {
    minimumPurchase?: true
    streamQuota?: true
    reelQuota?: true
  }

  export type ShopMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    website?: true
    authUserId?: true
    requiresEmailFix?: true
    razonSocial?: true
    cuit?: true
    email?: true
    password?: true
    address?: true
    minimumPurchase?: true
    plan?: true
    status?: true
    statusReason?: true
    statusChangedAt?: true
    agendaSuspendedUntil?: true
    agendaSuspendedByAdminId?: true
    agendaSuspendedReason?: true
    streamQuota?: true
    reelQuota?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    website?: true
    authUserId?: true
    requiresEmailFix?: true
    razonSocial?: true
    cuit?: true
    email?: true
    password?: true
    address?: true
    minimumPurchase?: true
    plan?: true
    status?: true
    statusReason?: true
    statusChangedAt?: true
    agendaSuspendedUntil?: true
    agendaSuspendedByAdminId?: true
    agendaSuspendedReason?: true
    streamQuota?: true
    reelQuota?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    website?: true
    authUserId?: true
    requiresEmailFix?: true
    razonSocial?: true
    cuit?: true
    email?: true
    password?: true
    address?: true
    addressDetails?: true
    minimumPurchase?: true
    paymentMethods?: true
    plan?: true
    status?: true
    statusReason?: true
    statusChangedAt?: true
    agendaSuspendedUntil?: true
    agendaSuspendedByAdminId?: true
    agendaSuspendedReason?: true
    streamQuota?: true
    reelQuota?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shop to aggregate.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithAggregationInput | ShopOrderByWithAggregationInput[]
    by: ShopScalarFieldEnum[] | ShopScalarFieldEnum
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _avg?: ShopAvgAggregateInputType
    _sum?: ShopSumAggregateInputType
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }

  export type ShopGroupByOutputType = {
    id: string
    name: string
    slug: string
    logoUrl: string | null
    website: string | null
    authUserId: string | null
    requiresEmailFix: boolean
    razonSocial: string | null
    cuit: string | null
    email: string | null
    password: string | null
    address: string | null
    addressDetails: JsonValue | null
    minimumPurchase: number | null
    paymentMethods: string[]
    plan: string
    status: $Enums.ShopStatus
    statusReason: string | null
    statusChangedAt: Date | null
    agendaSuspendedUntil: Date | null
    agendaSuspendedByAdminId: string | null
    agendaSuspendedReason: string | null
    streamQuota: number
    reelQuota: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    website?: boolean
    authUserId?: boolean
    requiresEmailFix?: boolean
    razonSocial?: boolean
    cuit?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    addressDetails?: boolean
    minimumPurchase?: boolean
    paymentMethods?: boolean
    plan?: boolean
    status?: boolean
    statusReason?: boolean
    statusChangedAt?: boolean
    agendaSuspendedUntil?: boolean
    agendaSuspendedByAdminId?: boolean
    agendaSuspendedReason?: boolean
    streamQuota?: boolean
    reelQuota?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authUser?: boolean | Shop$authUserArgs<ExtArgs>
    streams?: boolean | Shop$streamsArgs<ExtArgs>
    reels?: boolean | Shop$reelsArgs<ExtArgs>
    penalties?: boolean | Shop$penaltiesArgs<ExtArgs>
    socialHandles?: boolean | Shop$socialHandlesArgs<ExtArgs>
    whatsappLines?: boolean | Shop$whatsappLinesArgs<ExtArgs>
    favorites?: boolean | Shop$favoritesArgs<ExtArgs>
    quotaWallet?: boolean | Shop$quotaWalletArgs<ExtArgs>
    quotaTransactions?: boolean | Shop$quotaTransactionsArgs<ExtArgs>
    purchaseRequests?: boolean | Shop$purchaseRequestsArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    website?: boolean
    authUserId?: boolean
    requiresEmailFix?: boolean
    razonSocial?: boolean
    cuit?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    addressDetails?: boolean
    minimumPurchase?: boolean
    paymentMethods?: boolean
    plan?: boolean
    status?: boolean
    statusReason?: boolean
    statusChangedAt?: boolean
    agendaSuspendedUntil?: boolean
    agendaSuspendedByAdminId?: boolean
    agendaSuspendedReason?: boolean
    streamQuota?: boolean
    reelQuota?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authUser?: boolean | Shop$authUserArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    website?: boolean
    authUserId?: boolean
    requiresEmailFix?: boolean
    razonSocial?: boolean
    cuit?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    addressDetails?: boolean
    minimumPurchase?: boolean
    paymentMethods?: boolean
    plan?: boolean
    status?: boolean
    statusReason?: boolean
    statusChangedAt?: boolean
    agendaSuspendedUntil?: boolean
    agendaSuspendedByAdminId?: boolean
    agendaSuspendedReason?: boolean
    streamQuota?: boolean
    reelQuota?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authUser?: boolean | Shop$authUserArgs<ExtArgs>
    streams?: boolean | Shop$streamsArgs<ExtArgs>
    reels?: boolean | Shop$reelsArgs<ExtArgs>
    penalties?: boolean | Shop$penaltiesArgs<ExtArgs>
    socialHandles?: boolean | Shop$socialHandlesArgs<ExtArgs>
    whatsappLines?: boolean | Shop$whatsappLinesArgs<ExtArgs>
    favorites?: boolean | Shop$favoritesArgs<ExtArgs>
    quotaWallet?: boolean | Shop$quotaWalletArgs<ExtArgs>
    quotaTransactions?: boolean | Shop$quotaTransactionsArgs<ExtArgs>
    purchaseRequests?: boolean | Shop$purchaseRequestsArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authUser?: boolean | Shop$authUserArgs<ExtArgs>
  }

  export type $ShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shop"
    objects: {
      authUser: Prisma.$AuthUserPayload<ExtArgs> | null
      streams: Prisma.$StreamPayload<ExtArgs>[]
      reels: Prisma.$ReelPayload<ExtArgs>[]
      penalties: Prisma.$PenaltyPayload<ExtArgs>[]
      socialHandles: Prisma.$ShopSocialHandlePayload<ExtArgs>[]
      whatsappLines: Prisma.$ShopWhatsappLinePayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      quotaWallet: Prisma.$QuotaWalletPayload<ExtArgs> | null
      quotaTransactions: Prisma.$QuotaTransactionPayload<ExtArgs>[]
      purchaseRequests: Prisma.$PurchaseRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logoUrl: string | null
      website: string | null
      authUserId: string | null
      requiresEmailFix: boolean
      razonSocial: string | null
      cuit: string | null
      email: string | null
      password: string | null
      address: string | null
      addressDetails: Prisma.JsonValue | null
      minimumPurchase: number | null
      paymentMethods: string[]
      plan: string
      status: $Enums.ShopStatus
      statusReason: string | null
      statusChangedAt: Date | null
      agendaSuspendedUntil: Date | null
      agendaSuspendedByAdminId: string | null
      agendaSuspendedReason: string | null
      streamQuota: number
      reelQuota: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shop"]>
    composites: {}
  }

  type ShopGetPayload<S extends boolean | null | undefined | ShopDefaultArgs> = $Result.GetResult<Prisma.$ShopPayload, S>

  type ShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopCountAggregateInputType | true
    }

  export interface ShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shop'], meta: { name: 'Shop' } }
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Shop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShopFindUniqueOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopFindFirstArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Shop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWithIdOnly = await prisma.shop.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
    **/
    create<T extends ShopCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopCreateArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Shops.
     * @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ShopCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shops and returns the data saved in the database.
     * @param {ShopCreateManyAndReturnArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shops and only return the `id`
     * const shopWithIdOnly = await prisma.shop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ShopCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
    **/
    delete<T extends ShopDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopDeleteArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopUpdateArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
    **/
    upsert<T extends ShopUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopUpsertArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): Prisma.PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shop model
   */
  readonly fields: ShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    authUser<T extends Shop$authUserArgs<ExtArgs> = {}>(args?: Subset<T, Shop$authUserArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    streams<T extends Shop$streamsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$streamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findMany'> | Null>;

    reels<T extends Shop$reelsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$reelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'findMany'> | Null>;

    penalties<T extends Shop$penaltiesArgs<ExtArgs> = {}>(args?: Subset<T, Shop$penaltiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'findMany'> | Null>;

    socialHandles<T extends Shop$socialHandlesArgs<ExtArgs> = {}>(args?: Subset<T, Shop$socialHandlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'findMany'> | Null>;

    whatsappLines<T extends Shop$whatsappLinesArgs<ExtArgs> = {}>(args?: Subset<T, Shop$whatsappLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'findMany'> | Null>;

    favorites<T extends Shop$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Shop$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findMany'> | Null>;

    quotaWallet<T extends Shop$quotaWalletArgs<ExtArgs> = {}>(args?: Subset<T, Shop$quotaWalletArgs<ExtArgs>>): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    quotaTransactions<T extends Shop$quotaTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$quotaTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    purchaseRequests<T extends Shop$purchaseRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$purchaseRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Shop model
   */ 
  interface ShopFieldRefs {
    readonly id: FieldRef<"Shop", 'String'>
    readonly name: FieldRef<"Shop", 'String'>
    readonly slug: FieldRef<"Shop", 'String'>
    readonly logoUrl: FieldRef<"Shop", 'String'>
    readonly website: FieldRef<"Shop", 'String'>
    readonly authUserId: FieldRef<"Shop", 'String'>
    readonly requiresEmailFix: FieldRef<"Shop", 'Boolean'>
    readonly razonSocial: FieldRef<"Shop", 'String'>
    readonly cuit: FieldRef<"Shop", 'String'>
    readonly email: FieldRef<"Shop", 'String'>
    readonly password: FieldRef<"Shop", 'String'>
    readonly address: FieldRef<"Shop", 'String'>
    readonly addressDetails: FieldRef<"Shop", 'Json'>
    readonly minimumPurchase: FieldRef<"Shop", 'Int'>
    readonly paymentMethods: FieldRef<"Shop", 'String[]'>
    readonly plan: FieldRef<"Shop", 'String'>
    readonly status: FieldRef<"Shop", 'ShopStatus'>
    readonly statusReason: FieldRef<"Shop", 'String'>
    readonly statusChangedAt: FieldRef<"Shop", 'DateTime'>
    readonly agendaSuspendedUntil: FieldRef<"Shop", 'DateTime'>
    readonly agendaSuspendedByAdminId: FieldRef<"Shop", 'String'>
    readonly agendaSuspendedReason: FieldRef<"Shop", 'String'>
    readonly streamQuota: FieldRef<"Shop", 'Int'>
    readonly reelQuota: FieldRef<"Shop", 'Int'>
    readonly active: FieldRef<"Shop", 'Boolean'>
    readonly createdAt: FieldRef<"Shop", 'DateTime'>
    readonly updatedAt: FieldRef<"Shop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findUniqueOrThrow
   */
  export type ShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findFirstOrThrow
   */
  export type ShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findMany
   */
  export type ShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop create
   */
  export type ShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to create a Shop.
     */
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }

  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shop createManyAndReturn
   */
  export type ShopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shop update
   */
  export type ShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to update a Shop.
     */
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
  }

  /**
   * Shop upsert
   */
  export type ShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The filter to search for the Shop to update in case it exists.
     */
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     */
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }

  /**
   * Shop delete
   */
  export type ShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter which Shop to delete.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopWhereInput
  }

  /**
   * Shop.authUser
   */
  export type Shop$authUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    where?: AuthUserWhereInput
  }

  /**
   * Shop.streams
   */
  export type Shop$streamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    where?: StreamWhereInput
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    cursor?: StreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[]
  }

  /**
   * Shop.reels
   */
  export type Shop$reelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    where?: ReelWhereInput
    orderBy?: ReelOrderByWithRelationInput | ReelOrderByWithRelationInput[]
    cursor?: ReelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReelScalarFieldEnum | ReelScalarFieldEnum[]
  }

  /**
   * Shop.penalties
   */
  export type Shop$penaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    where?: PenaltyWhereInput
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    cursor?: PenaltyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Shop.socialHandles
   */
  export type Shop$socialHandlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    where?: ShopSocialHandleWhereInput
    orderBy?: ShopSocialHandleOrderByWithRelationInput | ShopSocialHandleOrderByWithRelationInput[]
    cursor?: ShopSocialHandleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopSocialHandleScalarFieldEnum | ShopSocialHandleScalarFieldEnum[]
  }

  /**
   * Shop.whatsappLines
   */
  export type Shop$whatsappLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    where?: ShopWhatsappLineWhereInput
    orderBy?: ShopWhatsappLineOrderByWithRelationInput | ShopWhatsappLineOrderByWithRelationInput[]
    cursor?: ShopWhatsappLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopWhatsappLineScalarFieldEnum | ShopWhatsappLineScalarFieldEnum[]
  }

  /**
   * Shop.favorites
   */
  export type Shop$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Shop.quotaWallet
   */
  export type Shop$quotaWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    where?: QuotaWalletWhereInput
  }

  /**
   * Shop.quotaTransactions
   */
  export type Shop$quotaTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    where?: QuotaTransactionWhereInput
    orderBy?: QuotaTransactionOrderByWithRelationInput | QuotaTransactionOrderByWithRelationInput[]
    cursor?: QuotaTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotaTransactionScalarFieldEnum | QuotaTransactionScalarFieldEnum[]
  }

  /**
   * Shop.purchaseRequests
   */
  export type Shop$purchaseRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    cursor?: PurchaseRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * Shop without action
   */
  export type ShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
  }


  /**
   * Model Stream
   */

  export type AggregateStream = {
    _count: StreamCountAggregateOutputType | null
    _avg: StreamAvgAggregateOutputType | null
    _sum: StreamSumAggregateOutputType | null
    _min: StreamMinAggregateOutputType | null
    _max: StreamMaxAggregateOutputType | null
  }

  export type StreamAvgAggregateOutputType = {
    durationMinutes: number | null
    extensionCount: number | null
    reportCount: number | null
    editCount: number | null
  }

  export type StreamSumAggregateOutputType = {
    durationMinutes: number | null
    extensionCount: number | null
    reportCount: number | null
    editCount: number | null
  }

  export type StreamMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    title: string | null
    description: string | null
    status: $Enums.StreamStatus | null
    scheduledAt: Date | null
    scheduledEndPlanned: Date | null
    timezone: string | null
    startTime: Date | null
    endTime: Date | null
    durationMinutes: number | null
    cancelledAt: Date | null
    cancelReason: string | null
    hidden: boolean | null
    visibilityReason: string | null
    platform: $Enums.SocialPlatform | null
    url: string | null
    extensionCount: number | null
    reportCount: number | null
    editCount: number | null
    lastEditedAt: Date | null
    originalScheduledAt: Date | null
    reprogrammedFromId: string | null
    reprogramReason: string | null
    pendingReprogramNote: string | null
    reprogramBatchId: string | null
    createdAt: Date | null
  }

  export type StreamMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    title: string | null
    description: string | null
    status: $Enums.StreamStatus | null
    scheduledAt: Date | null
    scheduledEndPlanned: Date | null
    timezone: string | null
    startTime: Date | null
    endTime: Date | null
    durationMinutes: number | null
    cancelledAt: Date | null
    cancelReason: string | null
    hidden: boolean | null
    visibilityReason: string | null
    platform: $Enums.SocialPlatform | null
    url: string | null
    extensionCount: number | null
    reportCount: number | null
    editCount: number | null
    lastEditedAt: Date | null
    originalScheduledAt: Date | null
    reprogrammedFromId: string | null
    reprogramReason: string | null
    pendingReprogramNote: string | null
    reprogramBatchId: string | null
    createdAt: Date | null
  }

  export type StreamCountAggregateOutputType = {
    id: number
    shopId: number
    title: number
    description: number
    status: number
    scheduledAt: number
    scheduledEndPlanned: number
    timezone: number
    startTime: number
    endTime: number
    durationMinutes: number
    cancelledAt: number
    cancelReason: number
    hidden: number
    visibilityReason: number
    platform: number
    url: number
    extensionCount: number
    reportCount: number
    editCount: number
    lastEditedAt: number
    originalScheduledAt: number
    reprogrammedFromId: number
    reprogramReason: number
    pendingReprogramNote: number
    reprogramBatchId: number
    createdAt: number
    _all: number
  }


  export type StreamAvgAggregateInputType = {
    durationMinutes?: true
    extensionCount?: true
    reportCount?: true
    editCount?: true
  }

  export type StreamSumAggregateInputType = {
    durationMinutes?: true
    extensionCount?: true
    reportCount?: true
    editCount?: true
  }

  export type StreamMinAggregateInputType = {
    id?: true
    shopId?: true
    title?: true
    description?: true
    status?: true
    scheduledAt?: true
    scheduledEndPlanned?: true
    timezone?: true
    startTime?: true
    endTime?: true
    durationMinutes?: true
    cancelledAt?: true
    cancelReason?: true
    hidden?: true
    visibilityReason?: true
    platform?: true
    url?: true
    extensionCount?: true
    reportCount?: true
    editCount?: true
    lastEditedAt?: true
    originalScheduledAt?: true
    reprogrammedFromId?: true
    reprogramReason?: true
    pendingReprogramNote?: true
    reprogramBatchId?: true
    createdAt?: true
  }

  export type StreamMaxAggregateInputType = {
    id?: true
    shopId?: true
    title?: true
    description?: true
    status?: true
    scheduledAt?: true
    scheduledEndPlanned?: true
    timezone?: true
    startTime?: true
    endTime?: true
    durationMinutes?: true
    cancelledAt?: true
    cancelReason?: true
    hidden?: true
    visibilityReason?: true
    platform?: true
    url?: true
    extensionCount?: true
    reportCount?: true
    editCount?: true
    lastEditedAt?: true
    originalScheduledAt?: true
    reprogrammedFromId?: true
    reprogramReason?: true
    pendingReprogramNote?: true
    reprogramBatchId?: true
    createdAt?: true
  }

  export type StreamCountAggregateInputType = {
    id?: true
    shopId?: true
    title?: true
    description?: true
    status?: true
    scheduledAt?: true
    scheduledEndPlanned?: true
    timezone?: true
    startTime?: true
    endTime?: true
    durationMinutes?: true
    cancelledAt?: true
    cancelReason?: true
    hidden?: true
    visibilityReason?: true
    platform?: true
    url?: true
    extensionCount?: true
    reportCount?: true
    editCount?: true
    lastEditedAt?: true
    originalScheduledAt?: true
    reprogrammedFromId?: true
    reprogramReason?: true
    pendingReprogramNote?: true
    reprogramBatchId?: true
    createdAt?: true
    _all?: true
  }

  export type StreamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stream to aggregate.
     */
    where?: StreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Streams
    **/
    _count?: true | StreamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StreamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StreamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreamMaxAggregateInputType
  }

  export type GetStreamAggregateType<T extends StreamAggregateArgs> = {
        [P in keyof T & keyof AggregateStream]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStream[P]>
      : GetScalarType<T[P], AggregateStream[P]>
  }




  export type StreamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamWhereInput
    orderBy?: StreamOrderByWithAggregationInput | StreamOrderByWithAggregationInput[]
    by: StreamScalarFieldEnum[] | StreamScalarFieldEnum
    having?: StreamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreamCountAggregateInputType | true
    _avg?: StreamAvgAggregateInputType
    _sum?: StreamSumAggregateInputType
    _min?: StreamMinAggregateInputType
    _max?: StreamMaxAggregateInputType
  }

  export type StreamGroupByOutputType = {
    id: string
    shopId: string
    title: string
    description: string | null
    status: $Enums.StreamStatus
    scheduledAt: Date
    scheduledEndPlanned: Date | null
    timezone: string
    startTime: Date | null
    endTime: Date | null
    durationMinutes: number | null
    cancelledAt: Date | null
    cancelReason: string | null
    hidden: boolean
    visibilityReason: string | null
    platform: $Enums.SocialPlatform
    url: string | null
    extensionCount: number
    reportCount: number
    editCount: number
    lastEditedAt: Date | null
    originalScheduledAt: Date | null
    reprogrammedFromId: string | null
    reprogramReason: string | null
    pendingReprogramNote: string | null
    reprogramBatchId: string | null
    createdAt: Date
    _count: StreamCountAggregateOutputType | null
    _avg: StreamAvgAggregateOutputType | null
    _sum: StreamSumAggregateOutputType | null
    _min: StreamMinAggregateOutputType | null
    _max: StreamMaxAggregateOutputType | null
  }

  type GetStreamGroupByPayload<T extends StreamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreamGroupByOutputType[P]>
            : GetScalarType<T[P], StreamGroupByOutputType[P]>
        }
      >
    >


  export type StreamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    scheduledAt?: boolean
    scheduledEndPlanned?: boolean
    timezone?: boolean
    startTime?: boolean
    endTime?: boolean
    durationMinutes?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    hidden?: boolean
    visibilityReason?: boolean
    platform?: boolean
    url?: boolean
    extensionCount?: boolean
    reportCount?: boolean
    editCount?: boolean
    lastEditedAt?: boolean
    originalScheduledAt?: boolean
    reprogrammedFromId?: boolean
    reprogramReason?: boolean
    pendingReprogramNote?: boolean
    reprogramBatchId?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    reports?: boolean | Stream$reportsArgs<ExtArgs>
    reviews?: boolean | Stream$reviewsArgs<ExtArgs>
    agenda?: boolean | Stream$agendaArgs<ExtArgs>
    _count?: boolean | StreamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stream"]>

  export type StreamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    scheduledAt?: boolean
    scheduledEndPlanned?: boolean
    timezone?: boolean
    startTime?: boolean
    endTime?: boolean
    durationMinutes?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    hidden?: boolean
    visibilityReason?: boolean
    platform?: boolean
    url?: boolean
    extensionCount?: boolean
    reportCount?: boolean
    editCount?: boolean
    lastEditedAt?: boolean
    originalScheduledAt?: boolean
    reprogrammedFromId?: boolean
    reprogramReason?: boolean
    pendingReprogramNote?: boolean
    reprogramBatchId?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stream"]>

  export type StreamSelectScalar = {
    id?: boolean
    shopId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    scheduledAt?: boolean
    scheduledEndPlanned?: boolean
    timezone?: boolean
    startTime?: boolean
    endTime?: boolean
    durationMinutes?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    hidden?: boolean
    visibilityReason?: boolean
    platform?: boolean
    url?: boolean
    extensionCount?: boolean
    reportCount?: boolean
    editCount?: boolean
    lastEditedAt?: boolean
    originalScheduledAt?: boolean
    reprogrammedFromId?: boolean
    reprogramReason?: boolean
    pendingReprogramNote?: boolean
    reprogramBatchId?: boolean
    createdAt?: boolean
  }

  export type StreamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    reports?: boolean | Stream$reportsArgs<ExtArgs>
    reviews?: boolean | Stream$reviewsArgs<ExtArgs>
    agenda?: boolean | Stream$agendaArgs<ExtArgs>
    _count?: boolean | StreamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StreamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $StreamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stream"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      reports: Prisma.$ReportPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      agenda: Prisma.$AgendaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      title: string
      description: string | null
      status: $Enums.StreamStatus
      scheduledAt: Date
      scheduledEndPlanned: Date | null
      timezone: string
      startTime: Date | null
      endTime: Date | null
      durationMinutes: number | null
      cancelledAt: Date | null
      cancelReason: string | null
      hidden: boolean
      visibilityReason: string | null
      platform: $Enums.SocialPlatform
      url: string | null
      extensionCount: number
      reportCount: number
      editCount: number
      lastEditedAt: Date | null
      originalScheduledAt: Date | null
      reprogrammedFromId: string | null
      reprogramReason: string | null
      pendingReprogramNote: string | null
      reprogramBatchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["stream"]>
    composites: {}
  }

  type StreamGetPayload<S extends boolean | null | undefined | StreamDefaultArgs> = $Result.GetResult<Prisma.$StreamPayload, S>

  type StreamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StreamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StreamCountAggregateInputType | true
    }

  export interface StreamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stream'], meta: { name: 'Stream' } }
    /**
     * Find zero or one Stream that matches the filter.
     * @param {StreamFindUniqueArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StreamFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StreamFindUniqueArgs<ExtArgs>>
    ): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Stream that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StreamFindUniqueOrThrowArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StreamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StreamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Stream that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindFirstArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StreamFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StreamFindFirstArgs<ExtArgs>>
    ): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Stream that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindFirstOrThrowArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StreamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StreamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Streams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Streams
     * const streams = await prisma.stream.findMany()
     * 
     * // Get first 10 Streams
     * const streams = await prisma.stream.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const streamWithIdOnly = await prisma.stream.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StreamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StreamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Stream.
     * @param {StreamCreateArgs} args - Arguments to create a Stream.
     * @example
     * // Create one Stream
     * const Stream = await prisma.stream.create({
     *   data: {
     *     // ... data to create a Stream
     *   }
     * })
     * 
    **/
    create<T extends StreamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StreamCreateArgs<ExtArgs>>
    ): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Streams.
     * @param {StreamCreateManyArgs} args - Arguments to create many Streams.
     * @example
     * // Create many Streams
     * const stream = await prisma.stream.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends StreamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StreamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Streams and returns the data saved in the database.
     * @param {StreamCreateManyAndReturnArgs} args - Arguments to create many Streams.
     * @example
     * // Create many Streams
     * const stream = await prisma.stream.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Streams and only return the `id`
     * const streamWithIdOnly = await prisma.stream.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends StreamCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, StreamCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Stream.
     * @param {StreamDeleteArgs} args - Arguments to delete one Stream.
     * @example
     * // Delete one Stream
     * const Stream = await prisma.stream.delete({
     *   where: {
     *     // ... filter to delete one Stream
     *   }
     * })
     * 
    **/
    delete<T extends StreamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StreamDeleteArgs<ExtArgs>>
    ): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Stream.
     * @param {StreamUpdateArgs} args - Arguments to update one Stream.
     * @example
     * // Update one Stream
     * const stream = await prisma.stream.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StreamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StreamUpdateArgs<ExtArgs>>
    ): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Streams.
     * @param {StreamDeleteManyArgs} args - Arguments to filter Streams to delete.
     * @example
     * // Delete a few Streams
     * const { count } = await prisma.stream.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StreamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StreamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Streams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Streams
     * const stream = await prisma.stream.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StreamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StreamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stream.
     * @param {StreamUpsertArgs} args - Arguments to update or create a Stream.
     * @example
     * // Update or create a Stream
     * const stream = await prisma.stream.upsert({
     *   create: {
     *     // ... data to create a Stream
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stream we want to update
     *   }
     * })
    **/
    upsert<T extends StreamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StreamUpsertArgs<ExtArgs>>
    ): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Streams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamCountArgs} args - Arguments to filter Streams to count.
     * @example
     * // Count the number of Streams
     * const count = await prisma.stream.count({
     *   where: {
     *     // ... the filter for the Streams we want to count
     *   }
     * })
    **/
    count<T extends StreamCountArgs>(
      args?: Subset<T, StreamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreamAggregateArgs>(args: Subset<T, StreamAggregateArgs>): Prisma.PrismaPromise<GetStreamAggregateType<T>>

    /**
     * Group by Stream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreamGroupByArgs['orderBy'] }
        : { orderBy?: StreamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stream model
   */
  readonly fields: StreamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stream.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    reports<T extends Stream$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Stream$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    reviews<T extends Stream$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Stream$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    agenda<T extends Stream$agendaArgs<ExtArgs> = {}>(args?: Subset<T, Stream$agendaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Stream model
   */ 
  interface StreamFieldRefs {
    readonly id: FieldRef<"Stream", 'String'>
    readonly shopId: FieldRef<"Stream", 'String'>
    readonly title: FieldRef<"Stream", 'String'>
    readonly description: FieldRef<"Stream", 'String'>
    readonly status: FieldRef<"Stream", 'StreamStatus'>
    readonly scheduledAt: FieldRef<"Stream", 'DateTime'>
    readonly scheduledEndPlanned: FieldRef<"Stream", 'DateTime'>
    readonly timezone: FieldRef<"Stream", 'String'>
    readonly startTime: FieldRef<"Stream", 'DateTime'>
    readonly endTime: FieldRef<"Stream", 'DateTime'>
    readonly durationMinutes: FieldRef<"Stream", 'Int'>
    readonly cancelledAt: FieldRef<"Stream", 'DateTime'>
    readonly cancelReason: FieldRef<"Stream", 'String'>
    readonly hidden: FieldRef<"Stream", 'Boolean'>
    readonly visibilityReason: FieldRef<"Stream", 'String'>
    readonly platform: FieldRef<"Stream", 'SocialPlatform'>
    readonly url: FieldRef<"Stream", 'String'>
    readonly extensionCount: FieldRef<"Stream", 'Int'>
    readonly reportCount: FieldRef<"Stream", 'Int'>
    readonly editCount: FieldRef<"Stream", 'Int'>
    readonly lastEditedAt: FieldRef<"Stream", 'DateTime'>
    readonly originalScheduledAt: FieldRef<"Stream", 'DateTime'>
    readonly reprogrammedFromId: FieldRef<"Stream", 'String'>
    readonly reprogramReason: FieldRef<"Stream", 'String'>
    readonly pendingReprogramNote: FieldRef<"Stream", 'String'>
    readonly reprogramBatchId: FieldRef<"Stream", 'String'>
    readonly createdAt: FieldRef<"Stream", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stream findUnique
   */
  export type StreamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Stream to fetch.
     */
    where: StreamWhereUniqueInput
  }

  /**
   * Stream findUniqueOrThrow
   */
  export type StreamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Stream to fetch.
     */
    where: StreamWhereUniqueInput
  }

  /**
   * Stream findFirst
   */
  export type StreamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Stream to fetch.
     */
    where?: StreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streams.
     */
    cursor?: StreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streams.
     */
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[]
  }

  /**
   * Stream findFirstOrThrow
   */
  export type StreamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Stream to fetch.
     */
    where?: StreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streams.
     */
    cursor?: StreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streams.
     */
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[]
  }

  /**
   * Stream findMany
   */
  export type StreamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Streams to fetch.
     */
    where?: StreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Streams.
     */
    cursor?: StreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streams.
     */
    skip?: number
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[]
  }

  /**
   * Stream create
   */
  export type StreamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * The data needed to create a Stream.
     */
    data: XOR<StreamCreateInput, StreamUncheckedCreateInput>
  }

  /**
   * Stream createMany
   */
  export type StreamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Streams.
     */
    data: StreamCreateManyInput | StreamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stream createManyAndReturn
   */
  export type StreamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Streams.
     */
    data: StreamCreateManyInput | StreamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stream update
   */
  export type StreamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * The data needed to update a Stream.
     */
    data: XOR<StreamUpdateInput, StreamUncheckedUpdateInput>
    /**
     * Choose, which Stream to update.
     */
    where: StreamWhereUniqueInput
  }

  /**
   * Stream updateMany
   */
  export type StreamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Streams.
     */
    data: XOR<StreamUpdateManyMutationInput, StreamUncheckedUpdateManyInput>
    /**
     * Filter which Streams to update
     */
    where?: StreamWhereInput
  }

  /**
   * Stream upsert
   */
  export type StreamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * The filter to search for the Stream to update in case it exists.
     */
    where: StreamWhereUniqueInput
    /**
     * In case the Stream found by the `where` argument doesn't exist, create a new Stream with this data.
     */
    create: XOR<StreamCreateInput, StreamUncheckedCreateInput>
    /**
     * In case the Stream was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreamUpdateInput, StreamUncheckedUpdateInput>
  }

  /**
   * Stream delete
   */
  export type StreamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter which Stream to delete.
     */
    where: StreamWhereUniqueInput
  }

  /**
   * Stream deleteMany
   */
  export type StreamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Streams to delete
     */
    where?: StreamWhereInput
  }

  /**
   * Stream.reports
   */
  export type Stream$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Stream.reviews
   */
  export type Stream$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Stream.agenda
   */
  export type Stream$agendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    where?: AgendaWhereInput
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    cursor?: AgendaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * Stream without action
   */
  export type StreamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
  }


  /**
   * Model Reel
   */

  export type AggregateReel = {
    _count: ReelCountAggregateOutputType | null
    _avg: ReelAvgAggregateOutputType | null
    _sum: ReelSumAggregateOutputType | null
    _min: ReelMinAggregateOutputType | null
    _max: ReelMaxAggregateOutputType | null
  }

  export type ReelAvgAggregateOutputType = {
    views: number | null
  }

  export type ReelSumAggregateOutputType = {
    views: number | null
  }

  export type ReelMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    url: string | null
    platform: $Enums.SocialPlatform | null
    hidden: boolean | null
    views: number | null
    createdAt: Date | null
  }

  export type ReelMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    url: string | null
    platform: $Enums.SocialPlatform | null
    hidden: boolean | null
    views: number | null
    createdAt: Date | null
  }

  export type ReelCountAggregateOutputType = {
    id: number
    shopId: number
    url: number
    platform: number
    hidden: number
    views: number
    createdAt: number
    _all: number
  }


  export type ReelAvgAggregateInputType = {
    views?: true
  }

  export type ReelSumAggregateInputType = {
    views?: true
  }

  export type ReelMinAggregateInputType = {
    id?: true
    shopId?: true
    url?: true
    platform?: true
    hidden?: true
    views?: true
    createdAt?: true
  }

  export type ReelMaxAggregateInputType = {
    id?: true
    shopId?: true
    url?: true
    platform?: true
    hidden?: true
    views?: true
    createdAt?: true
  }

  export type ReelCountAggregateInputType = {
    id?: true
    shopId?: true
    url?: true
    platform?: true
    hidden?: true
    views?: true
    createdAt?: true
    _all?: true
  }

  export type ReelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reel to aggregate.
     */
    where?: ReelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reels to fetch.
     */
    orderBy?: ReelOrderByWithRelationInput | ReelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reels
    **/
    _count?: true | ReelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReelMaxAggregateInputType
  }

  export type GetReelAggregateType<T extends ReelAggregateArgs> = {
        [P in keyof T & keyof AggregateReel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReel[P]>
      : GetScalarType<T[P], AggregateReel[P]>
  }




  export type ReelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReelWhereInput
    orderBy?: ReelOrderByWithAggregationInput | ReelOrderByWithAggregationInput[]
    by: ReelScalarFieldEnum[] | ReelScalarFieldEnum
    having?: ReelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReelCountAggregateInputType | true
    _avg?: ReelAvgAggregateInputType
    _sum?: ReelSumAggregateInputType
    _min?: ReelMinAggregateInputType
    _max?: ReelMaxAggregateInputType
  }

  export type ReelGroupByOutputType = {
    id: string
    shopId: string
    url: string
    platform: $Enums.SocialPlatform
    hidden: boolean
    views: number
    createdAt: Date
    _count: ReelCountAggregateOutputType | null
    _avg: ReelAvgAggregateOutputType | null
    _sum: ReelSumAggregateOutputType | null
    _min: ReelMinAggregateOutputType | null
    _max: ReelMaxAggregateOutputType | null
  }

  type GetReelGroupByPayload<T extends ReelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReelGroupByOutputType[P]>
            : GetScalarType<T[P], ReelGroupByOutputType[P]>
        }
      >
    >


  export type ReelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    url?: boolean
    platform?: boolean
    hidden?: boolean
    views?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reel"]>

  export type ReelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    url?: boolean
    platform?: boolean
    hidden?: boolean
    views?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reel"]>

  export type ReelSelectScalar = {
    id?: boolean
    shopId?: boolean
    url?: boolean
    platform?: boolean
    hidden?: boolean
    views?: boolean
    createdAt?: boolean
  }

  export type ReelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type ReelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $ReelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reel"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      url: string
      platform: $Enums.SocialPlatform
      hidden: boolean
      views: number
      createdAt: Date
    }, ExtArgs["result"]["reel"]>
    composites: {}
  }

  type ReelGetPayload<S extends boolean | null | undefined | ReelDefaultArgs> = $Result.GetResult<Prisma.$ReelPayload, S>

  type ReelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReelCountAggregateInputType | true
    }

  export interface ReelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reel'], meta: { name: 'Reel' } }
    /**
     * Find zero or one Reel that matches the filter.
     * @param {ReelFindUniqueArgs} args - Arguments to find a Reel
     * @example
     * // Get one Reel
     * const reel = await prisma.reel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReelFindUniqueArgs<ExtArgs>>
    ): Prisma__ReelClient<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Reel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReelFindUniqueOrThrowArgs} args - Arguments to find a Reel
     * @example
     * // Get one Reel
     * const reel = await prisma.reel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReelClient<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Reel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReelFindFirstArgs} args - Arguments to find a Reel
     * @example
     * // Get one Reel
     * const reel = await prisma.reel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReelFindFirstArgs<ExtArgs>>
    ): Prisma__ReelClient<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Reel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReelFindFirstOrThrowArgs} args - Arguments to find a Reel
     * @example
     * // Get one Reel
     * const reel = await prisma.reel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReelClient<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reels
     * const reels = await prisma.reel.findMany()
     * 
     * // Get first 10 Reels
     * const reels = await prisma.reel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reelWithIdOnly = await prisma.reel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Reel.
     * @param {ReelCreateArgs} args - Arguments to create a Reel.
     * @example
     * // Create one Reel
     * const Reel = await prisma.reel.create({
     *   data: {
     *     // ... data to create a Reel
     *   }
     * })
     * 
    **/
    create<T extends ReelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReelCreateArgs<ExtArgs>>
    ): Prisma__ReelClient<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reels.
     * @param {ReelCreateManyArgs} args - Arguments to create many Reels.
     * @example
     * // Create many Reels
     * const reel = await prisma.reel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ReelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reels and returns the data saved in the database.
     * @param {ReelCreateManyAndReturnArgs} args - Arguments to create many Reels.
     * @example
     * // Create many Reels
     * const reel = await prisma.reel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reels and only return the `id`
     * const reelWithIdOnly = await prisma.reel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ReelCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ReelCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Reel.
     * @param {ReelDeleteArgs} args - Arguments to delete one Reel.
     * @example
     * // Delete one Reel
     * const Reel = await prisma.reel.delete({
     *   where: {
     *     // ... filter to delete one Reel
     *   }
     * })
     * 
    **/
    delete<T extends ReelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReelDeleteArgs<ExtArgs>>
    ): Prisma__ReelClient<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Reel.
     * @param {ReelUpdateArgs} args - Arguments to update one Reel.
     * @example
     * // Update one Reel
     * const reel = await prisma.reel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReelUpdateArgs<ExtArgs>>
    ): Prisma__ReelClient<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reels.
     * @param {ReelDeleteManyArgs} args - Arguments to filter Reels to delete.
     * @example
     * // Delete a few Reels
     * const { count } = await prisma.reel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reels
     * const reel = await prisma.reel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reel.
     * @param {ReelUpsertArgs} args - Arguments to update or create a Reel.
     * @example
     * // Update or create a Reel
     * const reel = await prisma.reel.upsert({
     *   create: {
     *     // ... data to create a Reel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reel we want to update
     *   }
     * })
    **/
    upsert<T extends ReelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReelUpsertArgs<ExtArgs>>
    ): Prisma__ReelClient<$Result.GetResult<Prisma.$ReelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReelCountArgs} args - Arguments to filter Reels to count.
     * @example
     * // Count the number of Reels
     * const count = await prisma.reel.count({
     *   where: {
     *     // ... the filter for the Reels we want to count
     *   }
     * })
    **/
    count<T extends ReelCountArgs>(
      args?: Subset<T, ReelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReelAggregateArgs>(args: Subset<T, ReelAggregateArgs>): Prisma.PrismaPromise<GetReelAggregateType<T>>

    /**
     * Group by Reel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReelGroupByArgs['orderBy'] }
        : { orderBy?: ReelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reel model
   */
  readonly fields: ReelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Reel model
   */ 
  interface ReelFieldRefs {
    readonly id: FieldRef<"Reel", 'String'>
    readonly shopId: FieldRef<"Reel", 'String'>
    readonly url: FieldRef<"Reel", 'String'>
    readonly platform: FieldRef<"Reel", 'SocialPlatform'>
    readonly hidden: FieldRef<"Reel", 'Boolean'>
    readonly views: FieldRef<"Reel", 'Int'>
    readonly createdAt: FieldRef<"Reel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reel findUnique
   */
  export type ReelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * Filter, which Reel to fetch.
     */
    where: ReelWhereUniqueInput
  }

  /**
   * Reel findUniqueOrThrow
   */
  export type ReelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * Filter, which Reel to fetch.
     */
    where: ReelWhereUniqueInput
  }

  /**
   * Reel findFirst
   */
  export type ReelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * Filter, which Reel to fetch.
     */
    where?: ReelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reels to fetch.
     */
    orderBy?: ReelOrderByWithRelationInput | ReelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reels.
     */
    cursor?: ReelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reels.
     */
    distinct?: ReelScalarFieldEnum | ReelScalarFieldEnum[]
  }

  /**
   * Reel findFirstOrThrow
   */
  export type ReelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * Filter, which Reel to fetch.
     */
    where?: ReelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reels to fetch.
     */
    orderBy?: ReelOrderByWithRelationInput | ReelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reels.
     */
    cursor?: ReelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reels.
     */
    distinct?: ReelScalarFieldEnum | ReelScalarFieldEnum[]
  }

  /**
   * Reel findMany
   */
  export type ReelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * Filter, which Reels to fetch.
     */
    where?: ReelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reels to fetch.
     */
    orderBy?: ReelOrderByWithRelationInput | ReelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reels.
     */
    cursor?: ReelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reels.
     */
    skip?: number
    distinct?: ReelScalarFieldEnum | ReelScalarFieldEnum[]
  }

  /**
   * Reel create
   */
  export type ReelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * The data needed to create a Reel.
     */
    data: XOR<ReelCreateInput, ReelUncheckedCreateInput>
  }

  /**
   * Reel createMany
   */
  export type ReelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reels.
     */
    data: ReelCreateManyInput | ReelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reel createManyAndReturn
   */
  export type ReelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reels.
     */
    data: ReelCreateManyInput | ReelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reel update
   */
  export type ReelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * The data needed to update a Reel.
     */
    data: XOR<ReelUpdateInput, ReelUncheckedUpdateInput>
    /**
     * Choose, which Reel to update.
     */
    where: ReelWhereUniqueInput
  }

  /**
   * Reel updateMany
   */
  export type ReelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reels.
     */
    data: XOR<ReelUpdateManyMutationInput, ReelUncheckedUpdateManyInput>
    /**
     * Filter which Reels to update
     */
    where?: ReelWhereInput
  }

  /**
   * Reel upsert
   */
  export type ReelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * The filter to search for the Reel to update in case it exists.
     */
    where: ReelWhereUniqueInput
    /**
     * In case the Reel found by the `where` argument doesn't exist, create a new Reel with this data.
     */
    create: XOR<ReelCreateInput, ReelUncheckedCreateInput>
    /**
     * In case the Reel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReelUpdateInput, ReelUncheckedUpdateInput>
  }

  /**
   * Reel delete
   */
  export type ReelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
    /**
     * Filter which Reel to delete.
     */
    where: ReelWhereUniqueInput
  }

  /**
   * Reel deleteMany
   */
  export type ReelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reels to delete
     */
    where?: ReelWhereInput
  }

  /**
   * Reel without action
   */
  export type ReelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reel
     */
    select?: ReelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReelInclude<ExtArgs> | null
  }


  /**
   * Model ShopSocialHandle
   */

  export type AggregateShopSocialHandle = {
    _count: ShopSocialHandleCountAggregateOutputType | null
    _min: ShopSocialHandleMinAggregateOutputType | null
    _max: ShopSocialHandleMaxAggregateOutputType | null
  }

  export type ShopSocialHandleMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    platform: $Enums.SocialPlatform | null
    handle: string | null
    createdAt: Date | null
  }

  export type ShopSocialHandleMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    platform: $Enums.SocialPlatform | null
    handle: string | null
    createdAt: Date | null
  }

  export type ShopSocialHandleCountAggregateOutputType = {
    id: number
    shopId: number
    platform: number
    handle: number
    createdAt: number
    _all: number
  }


  export type ShopSocialHandleMinAggregateInputType = {
    id?: true
    shopId?: true
    platform?: true
    handle?: true
    createdAt?: true
  }

  export type ShopSocialHandleMaxAggregateInputType = {
    id?: true
    shopId?: true
    platform?: true
    handle?: true
    createdAt?: true
  }

  export type ShopSocialHandleCountAggregateInputType = {
    id?: true
    shopId?: true
    platform?: true
    handle?: true
    createdAt?: true
    _all?: true
  }

  export type ShopSocialHandleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopSocialHandle to aggregate.
     */
    where?: ShopSocialHandleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopSocialHandles to fetch.
     */
    orderBy?: ShopSocialHandleOrderByWithRelationInput | ShopSocialHandleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopSocialHandleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopSocialHandles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopSocialHandles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopSocialHandles
    **/
    _count?: true | ShopSocialHandleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopSocialHandleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopSocialHandleMaxAggregateInputType
  }

  export type GetShopSocialHandleAggregateType<T extends ShopSocialHandleAggregateArgs> = {
        [P in keyof T & keyof AggregateShopSocialHandle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopSocialHandle[P]>
      : GetScalarType<T[P], AggregateShopSocialHandle[P]>
  }




  export type ShopSocialHandleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopSocialHandleWhereInput
    orderBy?: ShopSocialHandleOrderByWithAggregationInput | ShopSocialHandleOrderByWithAggregationInput[]
    by: ShopSocialHandleScalarFieldEnum[] | ShopSocialHandleScalarFieldEnum
    having?: ShopSocialHandleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopSocialHandleCountAggregateInputType | true
    _min?: ShopSocialHandleMinAggregateInputType
    _max?: ShopSocialHandleMaxAggregateInputType
  }

  export type ShopSocialHandleGroupByOutputType = {
    id: string
    shopId: string
    platform: $Enums.SocialPlatform
    handle: string
    createdAt: Date
    _count: ShopSocialHandleCountAggregateOutputType | null
    _min: ShopSocialHandleMinAggregateOutputType | null
    _max: ShopSocialHandleMaxAggregateOutputType | null
  }

  type GetShopSocialHandleGroupByPayload<T extends ShopSocialHandleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopSocialHandleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopSocialHandleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopSocialHandleGroupByOutputType[P]>
            : GetScalarType<T[P], ShopSocialHandleGroupByOutputType[P]>
        }
      >
    >


  export type ShopSocialHandleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    platform?: boolean
    handle?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopSocialHandle"]>

  export type ShopSocialHandleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    platform?: boolean
    handle?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopSocialHandle"]>

  export type ShopSocialHandleSelectScalar = {
    id?: boolean
    shopId?: boolean
    platform?: boolean
    handle?: boolean
    createdAt?: boolean
  }

  export type ShopSocialHandleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type ShopSocialHandleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $ShopSocialHandlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopSocialHandle"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      platform: $Enums.SocialPlatform
      handle: string
      createdAt: Date
    }, ExtArgs["result"]["shopSocialHandle"]>
    composites: {}
  }

  type ShopSocialHandleGetPayload<S extends boolean | null | undefined | ShopSocialHandleDefaultArgs> = $Result.GetResult<Prisma.$ShopSocialHandlePayload, S>

  type ShopSocialHandleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopSocialHandleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopSocialHandleCountAggregateInputType | true
    }

  export interface ShopSocialHandleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopSocialHandle'], meta: { name: 'ShopSocialHandle' } }
    /**
     * Find zero or one ShopSocialHandle that matches the filter.
     * @param {ShopSocialHandleFindUniqueArgs} args - Arguments to find a ShopSocialHandle
     * @example
     * // Get one ShopSocialHandle
     * const shopSocialHandle = await prisma.shopSocialHandle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopSocialHandleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopSocialHandleFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopSocialHandleClient<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShopSocialHandle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShopSocialHandleFindUniqueOrThrowArgs} args - Arguments to find a ShopSocialHandle
     * @example
     * // Get one ShopSocialHandle
     * const shopSocialHandle = await prisma.shopSocialHandle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopSocialHandleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopSocialHandleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopSocialHandleClient<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShopSocialHandle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopSocialHandleFindFirstArgs} args - Arguments to find a ShopSocialHandle
     * @example
     * // Get one ShopSocialHandle
     * const shopSocialHandle = await prisma.shopSocialHandle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopSocialHandleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopSocialHandleFindFirstArgs<ExtArgs>>
    ): Prisma__ShopSocialHandleClient<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShopSocialHandle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopSocialHandleFindFirstOrThrowArgs} args - Arguments to find a ShopSocialHandle
     * @example
     * // Get one ShopSocialHandle
     * const shopSocialHandle = await prisma.shopSocialHandle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopSocialHandleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopSocialHandleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopSocialHandleClient<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShopSocialHandles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopSocialHandleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopSocialHandles
     * const shopSocialHandles = await prisma.shopSocialHandle.findMany()
     * 
     * // Get first 10 ShopSocialHandles
     * const shopSocialHandles = await prisma.shopSocialHandle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopSocialHandleWithIdOnly = await prisma.shopSocialHandle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopSocialHandleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopSocialHandleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShopSocialHandle.
     * @param {ShopSocialHandleCreateArgs} args - Arguments to create a ShopSocialHandle.
     * @example
     * // Create one ShopSocialHandle
     * const ShopSocialHandle = await prisma.shopSocialHandle.create({
     *   data: {
     *     // ... data to create a ShopSocialHandle
     *   }
     * })
     * 
    **/
    create<T extends ShopSocialHandleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopSocialHandleCreateArgs<ExtArgs>>
    ): Prisma__ShopSocialHandleClient<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShopSocialHandles.
     * @param {ShopSocialHandleCreateManyArgs} args - Arguments to create many ShopSocialHandles.
     * @example
     * // Create many ShopSocialHandles
     * const shopSocialHandle = await prisma.shopSocialHandle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ShopSocialHandleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopSocialHandleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopSocialHandles and returns the data saved in the database.
     * @param {ShopSocialHandleCreateManyAndReturnArgs} args - Arguments to create many ShopSocialHandles.
     * @example
     * // Create many ShopSocialHandles
     * const shopSocialHandle = await prisma.shopSocialHandle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopSocialHandles and only return the `id`
     * const shopSocialHandleWithIdOnly = await prisma.shopSocialHandle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ShopSocialHandleCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopSocialHandleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ShopSocialHandle.
     * @param {ShopSocialHandleDeleteArgs} args - Arguments to delete one ShopSocialHandle.
     * @example
     * // Delete one ShopSocialHandle
     * const ShopSocialHandle = await prisma.shopSocialHandle.delete({
     *   where: {
     *     // ... filter to delete one ShopSocialHandle
     *   }
     * })
     * 
    **/
    delete<T extends ShopSocialHandleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopSocialHandleDeleteArgs<ExtArgs>>
    ): Prisma__ShopSocialHandleClient<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShopSocialHandle.
     * @param {ShopSocialHandleUpdateArgs} args - Arguments to update one ShopSocialHandle.
     * @example
     * // Update one ShopSocialHandle
     * const shopSocialHandle = await prisma.shopSocialHandle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopSocialHandleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopSocialHandleUpdateArgs<ExtArgs>>
    ): Prisma__ShopSocialHandleClient<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShopSocialHandles.
     * @param {ShopSocialHandleDeleteManyArgs} args - Arguments to filter ShopSocialHandles to delete.
     * @example
     * // Delete a few ShopSocialHandles
     * const { count } = await prisma.shopSocialHandle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopSocialHandleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopSocialHandleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopSocialHandles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopSocialHandleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopSocialHandles
     * const shopSocialHandle = await prisma.shopSocialHandle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopSocialHandleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopSocialHandleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopSocialHandle.
     * @param {ShopSocialHandleUpsertArgs} args - Arguments to update or create a ShopSocialHandle.
     * @example
     * // Update or create a ShopSocialHandle
     * const shopSocialHandle = await prisma.shopSocialHandle.upsert({
     *   create: {
     *     // ... data to create a ShopSocialHandle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopSocialHandle we want to update
     *   }
     * })
    **/
    upsert<T extends ShopSocialHandleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopSocialHandleUpsertArgs<ExtArgs>>
    ): Prisma__ShopSocialHandleClient<$Result.GetResult<Prisma.$ShopSocialHandlePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShopSocialHandles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopSocialHandleCountArgs} args - Arguments to filter ShopSocialHandles to count.
     * @example
     * // Count the number of ShopSocialHandles
     * const count = await prisma.shopSocialHandle.count({
     *   where: {
     *     // ... the filter for the ShopSocialHandles we want to count
     *   }
     * })
    **/
    count<T extends ShopSocialHandleCountArgs>(
      args?: Subset<T, ShopSocialHandleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopSocialHandleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopSocialHandle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopSocialHandleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopSocialHandleAggregateArgs>(args: Subset<T, ShopSocialHandleAggregateArgs>): Prisma.PrismaPromise<GetShopSocialHandleAggregateType<T>>

    /**
     * Group by ShopSocialHandle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopSocialHandleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopSocialHandleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopSocialHandleGroupByArgs['orderBy'] }
        : { orderBy?: ShopSocialHandleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopSocialHandleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopSocialHandleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopSocialHandle model
   */
  readonly fields: ShopSocialHandleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopSocialHandle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopSocialHandleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShopSocialHandle model
   */ 
  interface ShopSocialHandleFieldRefs {
    readonly id: FieldRef<"ShopSocialHandle", 'String'>
    readonly shopId: FieldRef<"ShopSocialHandle", 'String'>
    readonly platform: FieldRef<"ShopSocialHandle", 'SocialPlatform'>
    readonly handle: FieldRef<"ShopSocialHandle", 'String'>
    readonly createdAt: FieldRef<"ShopSocialHandle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopSocialHandle findUnique
   */
  export type ShopSocialHandleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * Filter, which ShopSocialHandle to fetch.
     */
    where: ShopSocialHandleWhereUniqueInput
  }

  /**
   * ShopSocialHandle findUniqueOrThrow
   */
  export type ShopSocialHandleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * Filter, which ShopSocialHandle to fetch.
     */
    where: ShopSocialHandleWhereUniqueInput
  }

  /**
   * ShopSocialHandle findFirst
   */
  export type ShopSocialHandleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * Filter, which ShopSocialHandle to fetch.
     */
    where?: ShopSocialHandleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopSocialHandles to fetch.
     */
    orderBy?: ShopSocialHandleOrderByWithRelationInput | ShopSocialHandleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopSocialHandles.
     */
    cursor?: ShopSocialHandleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopSocialHandles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopSocialHandles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopSocialHandles.
     */
    distinct?: ShopSocialHandleScalarFieldEnum | ShopSocialHandleScalarFieldEnum[]
  }

  /**
   * ShopSocialHandle findFirstOrThrow
   */
  export type ShopSocialHandleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * Filter, which ShopSocialHandle to fetch.
     */
    where?: ShopSocialHandleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopSocialHandles to fetch.
     */
    orderBy?: ShopSocialHandleOrderByWithRelationInput | ShopSocialHandleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopSocialHandles.
     */
    cursor?: ShopSocialHandleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopSocialHandles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopSocialHandles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopSocialHandles.
     */
    distinct?: ShopSocialHandleScalarFieldEnum | ShopSocialHandleScalarFieldEnum[]
  }

  /**
   * ShopSocialHandle findMany
   */
  export type ShopSocialHandleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * Filter, which ShopSocialHandles to fetch.
     */
    where?: ShopSocialHandleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopSocialHandles to fetch.
     */
    orderBy?: ShopSocialHandleOrderByWithRelationInput | ShopSocialHandleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopSocialHandles.
     */
    cursor?: ShopSocialHandleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopSocialHandles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopSocialHandles.
     */
    skip?: number
    distinct?: ShopSocialHandleScalarFieldEnum | ShopSocialHandleScalarFieldEnum[]
  }

  /**
   * ShopSocialHandle create
   */
  export type ShopSocialHandleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopSocialHandle.
     */
    data: XOR<ShopSocialHandleCreateInput, ShopSocialHandleUncheckedCreateInput>
  }

  /**
   * ShopSocialHandle createMany
   */
  export type ShopSocialHandleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopSocialHandles.
     */
    data: ShopSocialHandleCreateManyInput | ShopSocialHandleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopSocialHandle createManyAndReturn
   */
  export type ShopSocialHandleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShopSocialHandles.
     */
    data: ShopSocialHandleCreateManyInput | ShopSocialHandleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopSocialHandle update
   */
  export type ShopSocialHandleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopSocialHandle.
     */
    data: XOR<ShopSocialHandleUpdateInput, ShopSocialHandleUncheckedUpdateInput>
    /**
     * Choose, which ShopSocialHandle to update.
     */
    where: ShopSocialHandleWhereUniqueInput
  }

  /**
   * ShopSocialHandle updateMany
   */
  export type ShopSocialHandleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopSocialHandles.
     */
    data: XOR<ShopSocialHandleUpdateManyMutationInput, ShopSocialHandleUncheckedUpdateManyInput>
    /**
     * Filter which ShopSocialHandles to update
     */
    where?: ShopSocialHandleWhereInput
  }

  /**
   * ShopSocialHandle upsert
   */
  export type ShopSocialHandleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopSocialHandle to update in case it exists.
     */
    where: ShopSocialHandleWhereUniqueInput
    /**
     * In case the ShopSocialHandle found by the `where` argument doesn't exist, create a new ShopSocialHandle with this data.
     */
    create: XOR<ShopSocialHandleCreateInput, ShopSocialHandleUncheckedCreateInput>
    /**
     * In case the ShopSocialHandle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopSocialHandleUpdateInput, ShopSocialHandleUncheckedUpdateInput>
  }

  /**
   * ShopSocialHandle delete
   */
  export type ShopSocialHandleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
    /**
     * Filter which ShopSocialHandle to delete.
     */
    where: ShopSocialHandleWhereUniqueInput
  }

  /**
   * ShopSocialHandle deleteMany
   */
  export type ShopSocialHandleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopSocialHandles to delete
     */
    where?: ShopSocialHandleWhereInput
  }

  /**
   * ShopSocialHandle without action
   */
  export type ShopSocialHandleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopSocialHandle
     */
    select?: ShopSocialHandleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopSocialHandleInclude<ExtArgs> | null
  }


  /**
   * Model ShopWhatsappLine
   */

  export type AggregateShopWhatsappLine = {
    _count: ShopWhatsappLineCountAggregateOutputType | null
    _min: ShopWhatsappLineMinAggregateOutputType | null
    _max: ShopWhatsappLineMaxAggregateOutputType | null
  }

  export type ShopWhatsappLineMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    label: string | null
    number: string | null
    createdAt: Date | null
  }

  export type ShopWhatsappLineMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    label: string | null
    number: string | null
    createdAt: Date | null
  }

  export type ShopWhatsappLineCountAggregateOutputType = {
    id: number
    shopId: number
    label: number
    number: number
    createdAt: number
    _all: number
  }


  export type ShopWhatsappLineMinAggregateInputType = {
    id?: true
    shopId?: true
    label?: true
    number?: true
    createdAt?: true
  }

  export type ShopWhatsappLineMaxAggregateInputType = {
    id?: true
    shopId?: true
    label?: true
    number?: true
    createdAt?: true
  }

  export type ShopWhatsappLineCountAggregateInputType = {
    id?: true
    shopId?: true
    label?: true
    number?: true
    createdAt?: true
    _all?: true
  }

  export type ShopWhatsappLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopWhatsappLine to aggregate.
     */
    where?: ShopWhatsappLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopWhatsappLines to fetch.
     */
    orderBy?: ShopWhatsappLineOrderByWithRelationInput | ShopWhatsappLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhatsappLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopWhatsappLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopWhatsappLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopWhatsappLines
    **/
    _count?: true | ShopWhatsappLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopWhatsappLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopWhatsappLineMaxAggregateInputType
  }

  export type GetShopWhatsappLineAggregateType<T extends ShopWhatsappLineAggregateArgs> = {
        [P in keyof T & keyof AggregateShopWhatsappLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopWhatsappLine[P]>
      : GetScalarType<T[P], AggregateShopWhatsappLine[P]>
  }




  export type ShopWhatsappLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhatsappLineWhereInput
    orderBy?: ShopWhatsappLineOrderByWithAggregationInput | ShopWhatsappLineOrderByWithAggregationInput[]
    by: ShopWhatsappLineScalarFieldEnum[] | ShopWhatsappLineScalarFieldEnum
    having?: ShopWhatsappLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopWhatsappLineCountAggregateInputType | true
    _min?: ShopWhatsappLineMinAggregateInputType
    _max?: ShopWhatsappLineMaxAggregateInputType
  }

  export type ShopWhatsappLineGroupByOutputType = {
    id: string
    shopId: string
    label: string
    number: string
    createdAt: Date
    _count: ShopWhatsappLineCountAggregateOutputType | null
    _min: ShopWhatsappLineMinAggregateOutputType | null
    _max: ShopWhatsappLineMaxAggregateOutputType | null
  }

  type GetShopWhatsappLineGroupByPayload<T extends ShopWhatsappLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopWhatsappLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopWhatsappLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopWhatsappLineGroupByOutputType[P]>
            : GetScalarType<T[P], ShopWhatsappLineGroupByOutputType[P]>
        }
      >
    >


  export type ShopWhatsappLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    label?: boolean
    number?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopWhatsappLine"]>

  export type ShopWhatsappLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    label?: boolean
    number?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopWhatsappLine"]>

  export type ShopWhatsappLineSelectScalar = {
    id?: boolean
    shopId?: boolean
    label?: boolean
    number?: boolean
    createdAt?: boolean
  }

  export type ShopWhatsappLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type ShopWhatsappLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $ShopWhatsappLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopWhatsappLine"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      label: string
      number: string
      createdAt: Date
    }, ExtArgs["result"]["shopWhatsappLine"]>
    composites: {}
  }

  type ShopWhatsappLineGetPayload<S extends boolean | null | undefined | ShopWhatsappLineDefaultArgs> = $Result.GetResult<Prisma.$ShopWhatsappLinePayload, S>

  type ShopWhatsappLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopWhatsappLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopWhatsappLineCountAggregateInputType | true
    }

  export interface ShopWhatsappLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopWhatsappLine'], meta: { name: 'ShopWhatsappLine' } }
    /**
     * Find zero or one ShopWhatsappLine that matches the filter.
     * @param {ShopWhatsappLineFindUniqueArgs} args - Arguments to find a ShopWhatsappLine
     * @example
     * // Get one ShopWhatsappLine
     * const shopWhatsappLine = await prisma.shopWhatsappLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopWhatsappLineFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopWhatsappLineFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopWhatsappLineClient<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShopWhatsappLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShopWhatsappLineFindUniqueOrThrowArgs} args - Arguments to find a ShopWhatsappLine
     * @example
     * // Get one ShopWhatsappLine
     * const shopWhatsappLine = await prisma.shopWhatsappLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopWhatsappLineFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopWhatsappLineFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopWhatsappLineClient<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShopWhatsappLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopWhatsappLineFindFirstArgs} args - Arguments to find a ShopWhatsappLine
     * @example
     * // Get one ShopWhatsappLine
     * const shopWhatsappLine = await prisma.shopWhatsappLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopWhatsappLineFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopWhatsappLineFindFirstArgs<ExtArgs>>
    ): Prisma__ShopWhatsappLineClient<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShopWhatsappLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopWhatsappLineFindFirstOrThrowArgs} args - Arguments to find a ShopWhatsappLine
     * @example
     * // Get one ShopWhatsappLine
     * const shopWhatsappLine = await prisma.shopWhatsappLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopWhatsappLineFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopWhatsappLineFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopWhatsappLineClient<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShopWhatsappLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopWhatsappLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopWhatsappLines
     * const shopWhatsappLines = await prisma.shopWhatsappLine.findMany()
     * 
     * // Get first 10 ShopWhatsappLines
     * const shopWhatsappLines = await prisma.shopWhatsappLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWhatsappLineWithIdOnly = await prisma.shopWhatsappLine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopWhatsappLineFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopWhatsappLineFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShopWhatsappLine.
     * @param {ShopWhatsappLineCreateArgs} args - Arguments to create a ShopWhatsappLine.
     * @example
     * // Create one ShopWhatsappLine
     * const ShopWhatsappLine = await prisma.shopWhatsappLine.create({
     *   data: {
     *     // ... data to create a ShopWhatsappLine
     *   }
     * })
     * 
    **/
    create<T extends ShopWhatsappLineCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopWhatsappLineCreateArgs<ExtArgs>>
    ): Prisma__ShopWhatsappLineClient<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShopWhatsappLines.
     * @param {ShopWhatsappLineCreateManyArgs} args - Arguments to create many ShopWhatsappLines.
     * @example
     * // Create many ShopWhatsappLines
     * const shopWhatsappLine = await prisma.shopWhatsappLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ShopWhatsappLineCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopWhatsappLineCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopWhatsappLines and returns the data saved in the database.
     * @param {ShopWhatsappLineCreateManyAndReturnArgs} args - Arguments to create many ShopWhatsappLines.
     * @example
     * // Create many ShopWhatsappLines
     * const shopWhatsappLine = await prisma.shopWhatsappLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopWhatsappLines and only return the `id`
     * const shopWhatsappLineWithIdOnly = await prisma.shopWhatsappLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ShopWhatsappLineCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopWhatsappLineCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a ShopWhatsappLine.
     * @param {ShopWhatsappLineDeleteArgs} args - Arguments to delete one ShopWhatsappLine.
     * @example
     * // Delete one ShopWhatsappLine
     * const ShopWhatsappLine = await prisma.shopWhatsappLine.delete({
     *   where: {
     *     // ... filter to delete one ShopWhatsappLine
     *   }
     * })
     * 
    **/
    delete<T extends ShopWhatsappLineDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopWhatsappLineDeleteArgs<ExtArgs>>
    ): Prisma__ShopWhatsappLineClient<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShopWhatsappLine.
     * @param {ShopWhatsappLineUpdateArgs} args - Arguments to update one ShopWhatsappLine.
     * @example
     * // Update one ShopWhatsappLine
     * const shopWhatsappLine = await prisma.shopWhatsappLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopWhatsappLineUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopWhatsappLineUpdateArgs<ExtArgs>>
    ): Prisma__ShopWhatsappLineClient<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShopWhatsappLines.
     * @param {ShopWhatsappLineDeleteManyArgs} args - Arguments to filter ShopWhatsappLines to delete.
     * @example
     * // Delete a few ShopWhatsappLines
     * const { count } = await prisma.shopWhatsappLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopWhatsappLineDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopWhatsappLineDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopWhatsappLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopWhatsappLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopWhatsappLines
     * const shopWhatsappLine = await prisma.shopWhatsappLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopWhatsappLineUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopWhatsappLineUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopWhatsappLine.
     * @param {ShopWhatsappLineUpsertArgs} args - Arguments to update or create a ShopWhatsappLine.
     * @example
     * // Update or create a ShopWhatsappLine
     * const shopWhatsappLine = await prisma.shopWhatsappLine.upsert({
     *   create: {
     *     // ... data to create a ShopWhatsappLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopWhatsappLine we want to update
     *   }
     * })
    **/
    upsert<T extends ShopWhatsappLineUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopWhatsappLineUpsertArgs<ExtArgs>>
    ): Prisma__ShopWhatsappLineClient<$Result.GetResult<Prisma.$ShopWhatsappLinePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShopWhatsappLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopWhatsappLineCountArgs} args - Arguments to filter ShopWhatsappLines to count.
     * @example
     * // Count the number of ShopWhatsappLines
     * const count = await prisma.shopWhatsappLine.count({
     *   where: {
     *     // ... the filter for the ShopWhatsappLines we want to count
     *   }
     * })
    **/
    count<T extends ShopWhatsappLineCountArgs>(
      args?: Subset<T, ShopWhatsappLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopWhatsappLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopWhatsappLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopWhatsappLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopWhatsappLineAggregateArgs>(args: Subset<T, ShopWhatsappLineAggregateArgs>): Prisma.PrismaPromise<GetShopWhatsappLineAggregateType<T>>

    /**
     * Group by ShopWhatsappLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopWhatsappLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopWhatsappLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopWhatsappLineGroupByArgs['orderBy'] }
        : { orderBy?: ShopWhatsappLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopWhatsappLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopWhatsappLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopWhatsappLine model
   */
  readonly fields: ShopWhatsappLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopWhatsappLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopWhatsappLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShopWhatsappLine model
   */ 
  interface ShopWhatsappLineFieldRefs {
    readonly id: FieldRef<"ShopWhatsappLine", 'String'>
    readonly shopId: FieldRef<"ShopWhatsappLine", 'String'>
    readonly label: FieldRef<"ShopWhatsappLine", 'String'>
    readonly number: FieldRef<"ShopWhatsappLine", 'String'>
    readonly createdAt: FieldRef<"ShopWhatsappLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopWhatsappLine findUnique
   */
  export type ShopWhatsappLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * Filter, which ShopWhatsappLine to fetch.
     */
    where: ShopWhatsappLineWhereUniqueInput
  }

  /**
   * ShopWhatsappLine findUniqueOrThrow
   */
  export type ShopWhatsappLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * Filter, which ShopWhatsappLine to fetch.
     */
    where: ShopWhatsappLineWhereUniqueInput
  }

  /**
   * ShopWhatsappLine findFirst
   */
  export type ShopWhatsappLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * Filter, which ShopWhatsappLine to fetch.
     */
    where?: ShopWhatsappLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopWhatsappLines to fetch.
     */
    orderBy?: ShopWhatsappLineOrderByWithRelationInput | ShopWhatsappLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopWhatsappLines.
     */
    cursor?: ShopWhatsappLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopWhatsappLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopWhatsappLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopWhatsappLines.
     */
    distinct?: ShopWhatsappLineScalarFieldEnum | ShopWhatsappLineScalarFieldEnum[]
  }

  /**
   * ShopWhatsappLine findFirstOrThrow
   */
  export type ShopWhatsappLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * Filter, which ShopWhatsappLine to fetch.
     */
    where?: ShopWhatsappLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopWhatsappLines to fetch.
     */
    orderBy?: ShopWhatsappLineOrderByWithRelationInput | ShopWhatsappLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopWhatsappLines.
     */
    cursor?: ShopWhatsappLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopWhatsappLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopWhatsappLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopWhatsappLines.
     */
    distinct?: ShopWhatsappLineScalarFieldEnum | ShopWhatsappLineScalarFieldEnum[]
  }

  /**
   * ShopWhatsappLine findMany
   */
  export type ShopWhatsappLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * Filter, which ShopWhatsappLines to fetch.
     */
    where?: ShopWhatsappLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopWhatsappLines to fetch.
     */
    orderBy?: ShopWhatsappLineOrderByWithRelationInput | ShopWhatsappLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopWhatsappLines.
     */
    cursor?: ShopWhatsappLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopWhatsappLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopWhatsappLines.
     */
    skip?: number
    distinct?: ShopWhatsappLineScalarFieldEnum | ShopWhatsappLineScalarFieldEnum[]
  }

  /**
   * ShopWhatsappLine create
   */
  export type ShopWhatsappLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopWhatsappLine.
     */
    data: XOR<ShopWhatsappLineCreateInput, ShopWhatsappLineUncheckedCreateInput>
  }

  /**
   * ShopWhatsappLine createMany
   */
  export type ShopWhatsappLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopWhatsappLines.
     */
    data: ShopWhatsappLineCreateManyInput | ShopWhatsappLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopWhatsappLine createManyAndReturn
   */
  export type ShopWhatsappLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShopWhatsappLines.
     */
    data: ShopWhatsappLineCreateManyInput | ShopWhatsappLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopWhatsappLine update
   */
  export type ShopWhatsappLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopWhatsappLine.
     */
    data: XOR<ShopWhatsappLineUpdateInput, ShopWhatsappLineUncheckedUpdateInput>
    /**
     * Choose, which ShopWhatsappLine to update.
     */
    where: ShopWhatsappLineWhereUniqueInput
  }

  /**
   * ShopWhatsappLine updateMany
   */
  export type ShopWhatsappLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopWhatsappLines.
     */
    data: XOR<ShopWhatsappLineUpdateManyMutationInput, ShopWhatsappLineUncheckedUpdateManyInput>
    /**
     * Filter which ShopWhatsappLines to update
     */
    where?: ShopWhatsappLineWhereInput
  }

  /**
   * ShopWhatsappLine upsert
   */
  export type ShopWhatsappLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopWhatsappLine to update in case it exists.
     */
    where: ShopWhatsappLineWhereUniqueInput
    /**
     * In case the ShopWhatsappLine found by the `where` argument doesn't exist, create a new ShopWhatsappLine with this data.
     */
    create: XOR<ShopWhatsappLineCreateInput, ShopWhatsappLineUncheckedCreateInput>
    /**
     * In case the ShopWhatsappLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopWhatsappLineUpdateInput, ShopWhatsappLineUncheckedUpdateInput>
  }

  /**
   * ShopWhatsappLine delete
   */
  export type ShopWhatsappLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
    /**
     * Filter which ShopWhatsappLine to delete.
     */
    where: ShopWhatsappLineWhereUniqueInput
  }

  /**
   * ShopWhatsappLine deleteMany
   */
  export type ShopWhatsappLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopWhatsappLines to delete
     */
    where?: ShopWhatsappLineWhereInput
  }

  /**
   * ShopWhatsappLine without action
   */
  export type ShopWhatsappLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopWhatsappLine
     */
    select?: ShopWhatsappLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopWhatsappLineInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    streamId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    streamId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    streamId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    streamId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    streamId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    streamId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    streamId: string
    rating: number
    comment: string | null
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    streamId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      stream: Prisma.$StreamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streamId: string
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends ReviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ReviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends ReviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stream<T extends StreamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreamDefaultArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly streamId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    streamId: string | null
    userId: string | null
    reason: string | null
    status: $Enums.ReportStatus | null
    resolved: boolean | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    streamId: string | null
    userId: string | null
    reason: string | null
    status: $Enums.ReportStatus | null
    resolved: boolean | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    streamId: number
    userId: number
    reason: number
    status: number
    resolved: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    streamId?: true
    userId?: true
    reason?: true
    status?: true
    resolved?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    streamId?: true
    userId?: true
    reason?: true
    status?: true
    resolved?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    streamId?: true
    userId?: true
    reason?: true
    status?: true
    resolved?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    streamId: string
    userId: string | null
    reason: string
    status: $Enums.ReportStatus
    resolved: boolean
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamId?: boolean
    userId?: boolean
    reason?: boolean
    status?: boolean
    resolved?: boolean
    createdAt?: boolean
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streamId?: boolean
    userId?: boolean
    reason?: boolean
    status?: boolean
    resolved?: boolean
    createdAt?: boolean
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    streamId?: boolean
    userId?: boolean
    reason?: boolean
    status?: boolean
    resolved?: boolean
    createdAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      stream: Prisma.$StreamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      streamId: string
      userId: string | null
      reason: string
      status: $Enums.ReportStatus
      resolved: boolean
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stream<T extends StreamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreamDefaultArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly streamId: FieldRef<"Report", 'String'>
    readonly userId: FieldRef<"Report", 'String'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly resolved: FieldRef<"Report", 'Boolean'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Penalty
   */

  export type AggregatePenalty = {
    _count: PenaltyCountAggregateOutputType | null
    _min: PenaltyMinAggregateOutputType | null
    _max: PenaltyMaxAggregateOutputType | null
  }

  export type PenaltyMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    reason: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type PenaltyMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    reason: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type PenaltyCountAggregateOutputType = {
    id: number
    shopId: number
    reason: number
    active: number
    createdAt: number
    _all: number
  }


  export type PenaltyMinAggregateInputType = {
    id?: true
    shopId?: true
    reason?: true
    active?: true
    createdAt?: true
  }

  export type PenaltyMaxAggregateInputType = {
    id?: true
    shopId?: true
    reason?: true
    active?: true
    createdAt?: true
  }

  export type PenaltyCountAggregateInputType = {
    id?: true
    shopId?: true
    reason?: true
    active?: true
    createdAt?: true
    _all?: true
  }

  export type PenaltyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penalty to aggregate.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Penalties
    **/
    _count?: true | PenaltyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PenaltyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PenaltyMaxAggregateInputType
  }

  export type GetPenaltyAggregateType<T extends PenaltyAggregateArgs> = {
        [P in keyof T & keyof AggregatePenalty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePenalty[P]>
      : GetScalarType<T[P], AggregatePenalty[P]>
  }




  export type PenaltyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenaltyWhereInput
    orderBy?: PenaltyOrderByWithAggregationInput | PenaltyOrderByWithAggregationInput[]
    by: PenaltyScalarFieldEnum[] | PenaltyScalarFieldEnum
    having?: PenaltyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PenaltyCountAggregateInputType | true
    _min?: PenaltyMinAggregateInputType
    _max?: PenaltyMaxAggregateInputType
  }

  export type PenaltyGroupByOutputType = {
    id: string
    shopId: string
    reason: string
    active: boolean
    createdAt: Date
    _count: PenaltyCountAggregateOutputType | null
    _min: PenaltyMinAggregateOutputType | null
    _max: PenaltyMaxAggregateOutputType | null
  }

  type GetPenaltyGroupByPayload<T extends PenaltyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PenaltyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PenaltyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PenaltyGroupByOutputType[P]>
            : GetScalarType<T[P], PenaltyGroupByOutputType[P]>
        }
      >
    >


  export type PenaltySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    reason?: boolean
    active?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    reason?: boolean
    active?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectScalar = {
    id?: boolean
    shopId?: boolean
    reason?: boolean
    active?: boolean
    createdAt?: boolean
  }

  export type PenaltyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type PenaltyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $PenaltyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Penalty"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      reason: string
      active: boolean
      createdAt: Date
    }, ExtArgs["result"]["penalty"]>
    composites: {}
  }

  type PenaltyGetPayload<S extends boolean | null | undefined | PenaltyDefaultArgs> = $Result.GetResult<Prisma.$PenaltyPayload, S>

  type PenaltyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PenaltyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PenaltyCountAggregateInputType | true
    }

  export interface PenaltyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Penalty'], meta: { name: 'Penalty' } }
    /**
     * Find zero or one Penalty that matches the filter.
     * @param {PenaltyFindUniqueArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PenaltyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PenaltyFindUniqueArgs<ExtArgs>>
    ): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Penalty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PenaltyFindUniqueOrThrowArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PenaltyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PenaltyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Penalty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindFirstArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PenaltyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PenaltyFindFirstArgs<ExtArgs>>
    ): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Penalty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindFirstOrThrowArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PenaltyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PenaltyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Penalties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Penalties
     * const penalties = await prisma.penalty.findMany()
     * 
     * // Get first 10 Penalties
     * const penalties = await prisma.penalty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const penaltyWithIdOnly = await prisma.penalty.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PenaltyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PenaltyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Penalty.
     * @param {PenaltyCreateArgs} args - Arguments to create a Penalty.
     * @example
     * // Create one Penalty
     * const Penalty = await prisma.penalty.create({
     *   data: {
     *     // ... data to create a Penalty
     *   }
     * })
     * 
    **/
    create<T extends PenaltyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PenaltyCreateArgs<ExtArgs>>
    ): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Penalties.
     * @param {PenaltyCreateManyArgs} args - Arguments to create many Penalties.
     * @example
     * // Create many Penalties
     * const penalty = await prisma.penalty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PenaltyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PenaltyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Penalties and returns the data saved in the database.
     * @param {PenaltyCreateManyAndReturnArgs} args - Arguments to create many Penalties.
     * @example
     * // Create many Penalties
     * const penalty = await prisma.penalty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Penalties and only return the `id`
     * const penaltyWithIdOnly = await prisma.penalty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PenaltyCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PenaltyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Penalty.
     * @param {PenaltyDeleteArgs} args - Arguments to delete one Penalty.
     * @example
     * // Delete one Penalty
     * const Penalty = await prisma.penalty.delete({
     *   where: {
     *     // ... filter to delete one Penalty
     *   }
     * })
     * 
    **/
    delete<T extends PenaltyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PenaltyDeleteArgs<ExtArgs>>
    ): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Penalty.
     * @param {PenaltyUpdateArgs} args - Arguments to update one Penalty.
     * @example
     * // Update one Penalty
     * const penalty = await prisma.penalty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PenaltyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PenaltyUpdateArgs<ExtArgs>>
    ): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Penalties.
     * @param {PenaltyDeleteManyArgs} args - Arguments to filter Penalties to delete.
     * @example
     * // Delete a few Penalties
     * const { count } = await prisma.penalty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PenaltyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PenaltyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Penalties
     * const penalty = await prisma.penalty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PenaltyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PenaltyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Penalty.
     * @param {PenaltyUpsertArgs} args - Arguments to update or create a Penalty.
     * @example
     * // Update or create a Penalty
     * const penalty = await prisma.penalty.upsert({
     *   create: {
     *     // ... data to create a Penalty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Penalty we want to update
     *   }
     * })
    **/
    upsert<T extends PenaltyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PenaltyUpsertArgs<ExtArgs>>
    ): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Penalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyCountArgs} args - Arguments to filter Penalties to count.
     * @example
     * // Count the number of Penalties
     * const count = await prisma.penalty.count({
     *   where: {
     *     // ... the filter for the Penalties we want to count
     *   }
     * })
    **/
    count<T extends PenaltyCountArgs>(
      args?: Subset<T, PenaltyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PenaltyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Penalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PenaltyAggregateArgs>(args: Subset<T, PenaltyAggregateArgs>): Prisma.PrismaPromise<GetPenaltyAggregateType<T>>

    /**
     * Group by Penalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PenaltyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PenaltyGroupByArgs['orderBy'] }
        : { orderBy?: PenaltyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PenaltyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPenaltyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Penalty model
   */
  readonly fields: PenaltyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Penalty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PenaltyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Penalty model
   */ 
  interface PenaltyFieldRefs {
    readonly id: FieldRef<"Penalty", 'String'>
    readonly shopId: FieldRef<"Penalty", 'String'>
    readonly reason: FieldRef<"Penalty", 'String'>
    readonly active: FieldRef<"Penalty", 'Boolean'>
    readonly createdAt: FieldRef<"Penalty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Penalty findUnique
   */
  export type PenaltyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty findUniqueOrThrow
   */
  export type PenaltyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty findFirst
   */
  export type PenaltyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penalties.
     */
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty findFirstOrThrow
   */
  export type PenaltyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penalties.
     */
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty findMany
   */
  export type PenaltyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalties to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty create
   */
  export type PenaltyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The data needed to create a Penalty.
     */
    data: XOR<PenaltyCreateInput, PenaltyUncheckedCreateInput>
  }

  /**
   * Penalty createMany
   */
  export type PenaltyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Penalties.
     */
    data: PenaltyCreateManyInput | PenaltyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Penalty createManyAndReturn
   */
  export type PenaltyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Penalties.
     */
    data: PenaltyCreateManyInput | PenaltyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Penalty update
   */
  export type PenaltyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The data needed to update a Penalty.
     */
    data: XOR<PenaltyUpdateInput, PenaltyUncheckedUpdateInput>
    /**
     * Choose, which Penalty to update.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty updateMany
   */
  export type PenaltyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Penalties.
     */
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyInput>
    /**
     * Filter which Penalties to update
     */
    where?: PenaltyWhereInput
  }

  /**
   * Penalty upsert
   */
  export type PenaltyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The filter to search for the Penalty to update in case it exists.
     */
    where: PenaltyWhereUniqueInput
    /**
     * In case the Penalty found by the `where` argument doesn't exist, create a new Penalty with this data.
     */
    create: XOR<PenaltyCreateInput, PenaltyUncheckedCreateInput>
    /**
     * In case the Penalty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PenaltyUpdateInput, PenaltyUncheckedUpdateInput>
  }

  /**
   * Penalty delete
   */
  export type PenaltyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter which Penalty to delete.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty deleteMany
   */
  export type PenaltyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penalties to delete
     */
    where?: PenaltyWhereInput
  }

  /**
   * Penalty without action
   */
  export type PenaltyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    shopId: string | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    shopId: string | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    userId: number
    shopId: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    shopId?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    shopId?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    shopId?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    userId: string
    shopId: string
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    shopId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    shopId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    shopId?: boolean
  }

  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      shopId: string
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FavoriteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>
    ): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FavoriteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>
    ): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FavoriteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
    **/
    create<T extends FavoriteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>
    ): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends FavoriteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
    **/
    delete<T extends FavoriteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>
    ): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FavoriteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>
    ): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FavoriteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FavoriteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
    **/
    upsert<T extends FavoriteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>
    ): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Favorite model
   */ 
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly userId: FieldRef<"Favorite", 'String'>
    readonly shopId: FieldRef<"Favorite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model Agenda
   */

  export type AggregateAgenda = {
    _count: AgendaCountAggregateOutputType | null
    _min: AgendaMinAggregateOutputType | null
    _max: AgendaMaxAggregateOutputType | null
  }

  export type AgendaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    streamId: string | null
  }

  export type AgendaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    streamId: string | null
  }

  export type AgendaCountAggregateOutputType = {
    id: number
    userId: number
    streamId: number
    _all: number
  }


  export type AgendaMinAggregateInputType = {
    id?: true
    userId?: true
    streamId?: true
  }

  export type AgendaMaxAggregateInputType = {
    id?: true
    userId?: true
    streamId?: true
  }

  export type AgendaCountAggregateInputType = {
    id?: true
    userId?: true
    streamId?: true
    _all?: true
  }

  export type AgendaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agenda to aggregate.
     */
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     */
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agenda
    **/
    _count?: true | AgendaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaMaxAggregateInputType
  }

  export type GetAgendaAggregateType<T extends AgendaAggregateArgs> = {
        [P in keyof T & keyof AggregateAgenda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgenda[P]>
      : GetScalarType<T[P], AggregateAgenda[P]>
  }




  export type AgendaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaWhereInput
    orderBy?: AgendaOrderByWithAggregationInput | AgendaOrderByWithAggregationInput[]
    by: AgendaScalarFieldEnum[] | AgendaScalarFieldEnum
    having?: AgendaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaCountAggregateInputType | true
    _min?: AgendaMinAggregateInputType
    _max?: AgendaMaxAggregateInputType
  }

  export type AgendaGroupByOutputType = {
    id: string
    userId: string
    streamId: string
    _count: AgendaCountAggregateOutputType | null
    _min: AgendaMinAggregateOutputType | null
    _max: AgendaMaxAggregateOutputType | null
  }

  type GetAgendaGroupByPayload<T extends AgendaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaGroupByOutputType[P]>
        }
      >
    >


  export type AgendaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    streamId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agenda"]>

  export type AgendaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    streamId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agenda"]>

  export type AgendaSelectScalar = {
    id?: boolean
    userId?: boolean
    streamId?: boolean
  }

  export type AgendaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }
  export type AgendaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stream?: boolean | StreamDefaultArgs<ExtArgs>
  }

  export type $AgendaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agenda"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      stream: Prisma.$StreamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      streamId: string
    }, ExtArgs["result"]["agenda"]>
    composites: {}
  }

  type AgendaGetPayload<S extends boolean | null | undefined | AgendaDefaultArgs> = $Result.GetResult<Prisma.$AgendaPayload, S>

  type AgendaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgendaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgendaCountAggregateInputType | true
    }

  export interface AgendaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agenda'], meta: { name: 'Agenda' } }
    /**
     * Find zero or one Agenda that matches the filter.
     * @param {AgendaFindUniqueArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgendaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AgendaFindUniqueArgs<ExtArgs>>
    ): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Agenda that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgendaFindUniqueOrThrowArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgendaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgendaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Agenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindFirstArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgendaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AgendaFindFirstArgs<ExtArgs>>
    ): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Agenda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindFirstOrThrowArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgendaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgendaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Agenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agenda
     * const agenda = await prisma.agenda.findMany()
     * 
     * // Get first 10 Agenda
     * const agenda = await prisma.agenda.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaWithIdOnly = await prisma.agenda.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgendaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgendaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Agenda.
     * @param {AgendaCreateArgs} args - Arguments to create a Agenda.
     * @example
     * // Create one Agenda
     * const Agenda = await prisma.agenda.create({
     *   data: {
     *     // ... data to create a Agenda
     *   }
     * })
     * 
    **/
    create<T extends AgendaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgendaCreateArgs<ExtArgs>>
    ): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Agenda.
     * @param {AgendaCreateManyArgs} args - Arguments to create many Agenda.
     * @example
     * // Create many Agenda
     * const agenda = await prisma.agenda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AgendaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgendaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agenda and returns the data saved in the database.
     * @param {AgendaCreateManyAndReturnArgs} args - Arguments to create many Agenda.
     * @example
     * // Create many Agenda
     * const agenda = await prisma.agenda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agenda and only return the `id`
     * const agendaWithIdOnly = await prisma.agenda.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends AgendaCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, AgendaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Agenda.
     * @param {AgendaDeleteArgs} args - Arguments to delete one Agenda.
     * @example
     * // Delete one Agenda
     * const Agenda = await prisma.agenda.delete({
     *   where: {
     *     // ... filter to delete one Agenda
     *   }
     * })
     * 
    **/
    delete<T extends AgendaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgendaDeleteArgs<ExtArgs>>
    ): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Agenda.
     * @param {AgendaUpdateArgs} args - Arguments to update one Agenda.
     * @example
     * // Update one Agenda
     * const agenda = await prisma.agenda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgendaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgendaUpdateArgs<ExtArgs>>
    ): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Agenda.
     * @param {AgendaDeleteManyArgs} args - Arguments to filter Agenda to delete.
     * @example
     * // Delete a few Agenda
     * const { count } = await prisma.agenda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgendaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgendaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agenda
     * const agenda = await prisma.agenda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgendaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgendaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agenda.
     * @param {AgendaUpsertArgs} args - Arguments to update or create a Agenda.
     * @example
     * // Update or create a Agenda
     * const agenda = await prisma.agenda.upsert({
     *   create: {
     *     // ... data to create a Agenda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agenda we want to update
     *   }
     * })
    **/
    upsert<T extends AgendaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgendaUpsertArgs<ExtArgs>>
    ): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaCountArgs} args - Arguments to filter Agenda to count.
     * @example
     * // Count the number of Agenda
     * const count = await prisma.agenda.count({
     *   where: {
     *     // ... the filter for the Agenda we want to count
     *   }
     * })
    **/
    count<T extends AgendaCountArgs>(
      args?: Subset<T, AgendaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaAggregateArgs>(args: Subset<T, AgendaAggregateArgs>): Prisma.PrismaPromise<GetAgendaAggregateType<T>>

    /**
     * Group by Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaGroupByArgs['orderBy'] }
        : { orderBy?: AgendaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agenda model
   */
  readonly fields: AgendaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agenda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    stream<T extends StreamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreamDefaultArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Agenda model
   */ 
  interface AgendaFieldRefs {
    readonly id: FieldRef<"Agenda", 'String'>
    readonly userId: FieldRef<"Agenda", 'String'>
    readonly streamId: FieldRef<"Agenda", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Agenda findUnique
   */
  export type AgendaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda findUniqueOrThrow
   */
  export type AgendaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda findFirst
   */
  export type AgendaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     */
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agenda.
     */
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agenda.
     */
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * Agenda findFirstOrThrow
   */
  export type AgendaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     */
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agenda.
     */
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agenda.
     */
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * Agenda findMany
   */
  export type AgendaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     */
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agenda.
     */
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     */
    skip?: number
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * Agenda create
   */
  export type AgendaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * The data needed to create a Agenda.
     */
    data: XOR<AgendaCreateInput, AgendaUncheckedCreateInput>
  }

  /**
   * Agenda createMany
   */
  export type AgendaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agenda.
     */
    data: AgendaCreateManyInput | AgendaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agenda createManyAndReturn
   */
  export type AgendaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Agenda.
     */
    data: AgendaCreateManyInput | AgendaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agenda update
   */
  export type AgendaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * The data needed to update a Agenda.
     */
    data: XOR<AgendaUpdateInput, AgendaUncheckedUpdateInput>
    /**
     * Choose, which Agenda to update.
     */
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda updateMany
   */
  export type AgendaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agenda.
     */
    data: XOR<AgendaUpdateManyMutationInput, AgendaUncheckedUpdateManyInput>
    /**
     * Filter which Agenda to update
     */
    where?: AgendaWhereInput
  }

  /**
   * Agenda upsert
   */
  export type AgendaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * The filter to search for the Agenda to update in case it exists.
     */
    where: AgendaWhereUniqueInput
    /**
     * In case the Agenda found by the `where` argument doesn't exist, create a new Agenda with this data.
     */
    create: XOR<AgendaCreateInput, AgendaUncheckedCreateInput>
    /**
     * In case the Agenda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaUpdateInput, AgendaUncheckedUpdateInput>
  }

  /**
   * Agenda delete
   */
  export type AgendaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
    /**
     * Filter which Agenda to delete.
     */
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda deleteMany
   */
  export type AgendaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agenda to delete
     */
    where?: AgendaWhereInput
  }

  /**
   * Agenda without action
   */
  export type AgendaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    message: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model QuotaWallet
   */

  export type AggregateQuotaWallet = {
    _count: QuotaWalletCountAggregateOutputType | null
    _avg: QuotaWalletAvgAggregateOutputType | null
    _sum: QuotaWalletSumAggregateOutputType | null
    _min: QuotaWalletMinAggregateOutputType | null
    _max: QuotaWalletMaxAggregateOutputType | null
  }

  export type QuotaWalletAvgAggregateOutputType = {
    weeklyLiveBaseLimit: number | null
    weeklyLiveUsed: number | null
    liveExtraBalance: number | null
    reelDailyLimit: number | null
    reelDailyUsed: number | null
    reelExtraBalance: number | null
  }

  export type QuotaWalletSumAggregateOutputType = {
    weeklyLiveBaseLimit: number | null
    weeklyLiveUsed: number | null
    liveExtraBalance: number | null
    reelDailyLimit: number | null
    reelDailyUsed: number | null
    reelExtraBalance: number | null
  }

  export type QuotaWalletMinAggregateOutputType = {
    shopId: string | null
    weeklyLiveBaseLimit: number | null
    weeklyLiveUsed: number | null
    weeklyLiveWeekKey: string | null
    liveExtraBalance: number | null
    reelDailyLimit: number | null
    reelDailyUsed: number | null
    reelDailyDateKey: string | null
    reelExtraBalance: number | null
  }

  export type QuotaWalletMaxAggregateOutputType = {
    shopId: string | null
    weeklyLiveBaseLimit: number | null
    weeklyLiveUsed: number | null
    weeklyLiveWeekKey: string | null
    liveExtraBalance: number | null
    reelDailyLimit: number | null
    reelDailyUsed: number | null
    reelDailyDateKey: string | null
    reelExtraBalance: number | null
  }

  export type QuotaWalletCountAggregateOutputType = {
    shopId: number
    weeklyLiveBaseLimit: number
    weeklyLiveUsed: number
    weeklyLiveWeekKey: number
    liveExtraBalance: number
    reelDailyLimit: number
    reelDailyUsed: number
    reelDailyDateKey: number
    reelExtraBalance: number
    _all: number
  }


  export type QuotaWalletAvgAggregateInputType = {
    weeklyLiveBaseLimit?: true
    weeklyLiveUsed?: true
    liveExtraBalance?: true
    reelDailyLimit?: true
    reelDailyUsed?: true
    reelExtraBalance?: true
  }

  export type QuotaWalletSumAggregateInputType = {
    weeklyLiveBaseLimit?: true
    weeklyLiveUsed?: true
    liveExtraBalance?: true
    reelDailyLimit?: true
    reelDailyUsed?: true
    reelExtraBalance?: true
  }

  export type QuotaWalletMinAggregateInputType = {
    shopId?: true
    weeklyLiveBaseLimit?: true
    weeklyLiveUsed?: true
    weeklyLiveWeekKey?: true
    liveExtraBalance?: true
    reelDailyLimit?: true
    reelDailyUsed?: true
    reelDailyDateKey?: true
    reelExtraBalance?: true
  }

  export type QuotaWalletMaxAggregateInputType = {
    shopId?: true
    weeklyLiveBaseLimit?: true
    weeklyLiveUsed?: true
    weeklyLiveWeekKey?: true
    liveExtraBalance?: true
    reelDailyLimit?: true
    reelDailyUsed?: true
    reelDailyDateKey?: true
    reelExtraBalance?: true
  }

  export type QuotaWalletCountAggregateInputType = {
    shopId?: true
    weeklyLiveBaseLimit?: true
    weeklyLiveUsed?: true
    weeklyLiveWeekKey?: true
    liveExtraBalance?: true
    reelDailyLimit?: true
    reelDailyUsed?: true
    reelDailyDateKey?: true
    reelExtraBalance?: true
    _all?: true
  }

  export type QuotaWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotaWallet to aggregate.
     */
    where?: QuotaWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotaWallets to fetch.
     */
    orderBy?: QuotaWalletOrderByWithRelationInput | QuotaWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotaWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotaWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotaWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotaWallets
    **/
    _count?: true | QuotaWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotaWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotaWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotaWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotaWalletMaxAggregateInputType
  }

  export type GetQuotaWalletAggregateType<T extends QuotaWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotaWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotaWallet[P]>
      : GetScalarType<T[P], AggregateQuotaWallet[P]>
  }




  export type QuotaWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotaWalletWhereInput
    orderBy?: QuotaWalletOrderByWithAggregationInput | QuotaWalletOrderByWithAggregationInput[]
    by: QuotaWalletScalarFieldEnum[] | QuotaWalletScalarFieldEnum
    having?: QuotaWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotaWalletCountAggregateInputType | true
    _avg?: QuotaWalletAvgAggregateInputType
    _sum?: QuotaWalletSumAggregateInputType
    _min?: QuotaWalletMinAggregateInputType
    _max?: QuotaWalletMaxAggregateInputType
  }

  export type QuotaWalletGroupByOutputType = {
    shopId: string
    weeklyLiveBaseLimit: number
    weeklyLiveUsed: number
    weeklyLiveWeekKey: string
    liveExtraBalance: number
    reelDailyLimit: number
    reelDailyUsed: number
    reelDailyDateKey: string
    reelExtraBalance: number
    _count: QuotaWalletCountAggregateOutputType | null
    _avg: QuotaWalletAvgAggregateOutputType | null
    _sum: QuotaWalletSumAggregateOutputType | null
    _min: QuotaWalletMinAggregateOutputType | null
    _max: QuotaWalletMaxAggregateOutputType | null
  }

  type GetQuotaWalletGroupByPayload<T extends QuotaWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotaWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotaWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotaWalletGroupByOutputType[P]>
            : GetScalarType<T[P], QuotaWalletGroupByOutputType[P]>
        }
      >
    >


  export type QuotaWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    weeklyLiveBaseLimit?: boolean
    weeklyLiveUsed?: boolean
    weeklyLiveWeekKey?: boolean
    liveExtraBalance?: boolean
    reelDailyLimit?: boolean
    reelDailyUsed?: boolean
    reelDailyDateKey?: boolean
    reelExtraBalance?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotaWallet"]>

  export type QuotaWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    weeklyLiveBaseLimit?: boolean
    weeklyLiveUsed?: boolean
    weeklyLiveWeekKey?: boolean
    liveExtraBalance?: boolean
    reelDailyLimit?: boolean
    reelDailyUsed?: boolean
    reelDailyDateKey?: boolean
    reelExtraBalance?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotaWallet"]>

  export type QuotaWalletSelectScalar = {
    shopId?: boolean
    weeklyLiveBaseLimit?: boolean
    weeklyLiveUsed?: boolean
    weeklyLiveWeekKey?: boolean
    liveExtraBalance?: boolean
    reelDailyLimit?: boolean
    reelDailyUsed?: boolean
    reelDailyDateKey?: boolean
    reelExtraBalance?: boolean
  }

  export type QuotaWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type QuotaWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $QuotaWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotaWallet"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string
      weeklyLiveBaseLimit: number
      weeklyLiveUsed: number
      weeklyLiveWeekKey: string
      liveExtraBalance: number
      reelDailyLimit: number
      reelDailyUsed: number
      reelDailyDateKey: string
      reelExtraBalance: number
    }, ExtArgs["result"]["quotaWallet"]>
    composites: {}
  }

  type QuotaWalletGetPayload<S extends boolean | null | undefined | QuotaWalletDefaultArgs> = $Result.GetResult<Prisma.$QuotaWalletPayload, S>

  type QuotaWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuotaWalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuotaWalletCountAggregateInputType | true
    }

  export interface QuotaWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotaWallet'], meta: { name: 'QuotaWallet' } }
    /**
     * Find zero or one QuotaWallet that matches the filter.
     * @param {QuotaWalletFindUniqueArgs} args - Arguments to find a QuotaWallet
     * @example
     * // Get one QuotaWallet
     * const quotaWallet = await prisma.quotaWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuotaWalletFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaWalletFindUniqueArgs<ExtArgs>>
    ): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one QuotaWallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuotaWalletFindUniqueOrThrowArgs} args - Arguments to find a QuotaWallet
     * @example
     * // Get one QuotaWallet
     * const quotaWallet = await prisma.quotaWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuotaWalletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaWalletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first QuotaWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaWalletFindFirstArgs} args - Arguments to find a QuotaWallet
     * @example
     * // Get one QuotaWallet
     * const quotaWallet = await prisma.quotaWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuotaWalletFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaWalletFindFirstArgs<ExtArgs>>
    ): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first QuotaWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaWalletFindFirstOrThrowArgs} args - Arguments to find a QuotaWallet
     * @example
     * // Get one QuotaWallet
     * const quotaWallet = await prisma.quotaWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuotaWalletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaWalletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more QuotaWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotaWallets
     * const quotaWallets = await prisma.quotaWallet.findMany()
     * 
     * // Get first 10 QuotaWallets
     * const quotaWallets = await prisma.quotaWallet.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const quotaWalletWithShopIdOnly = await prisma.quotaWallet.findMany({ select: { shopId: true } })
     * 
    **/
    findMany<T extends QuotaWalletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaWalletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a QuotaWallet.
     * @param {QuotaWalletCreateArgs} args - Arguments to create a QuotaWallet.
     * @example
     * // Create one QuotaWallet
     * const QuotaWallet = await prisma.quotaWallet.create({
     *   data: {
     *     // ... data to create a QuotaWallet
     *   }
     * })
     * 
    **/
    create<T extends QuotaWalletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaWalletCreateArgs<ExtArgs>>
    ): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many QuotaWallets.
     * @param {QuotaWalletCreateManyArgs} args - Arguments to create many QuotaWallets.
     * @example
     * // Create many QuotaWallets
     * const quotaWallet = await prisma.quotaWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends QuotaWalletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaWalletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotaWallets and returns the data saved in the database.
     * @param {QuotaWalletCreateManyAndReturnArgs} args - Arguments to create many QuotaWallets.
     * @example
     * // Create many QuotaWallets
     * const quotaWallet = await prisma.quotaWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotaWallets and only return the `shopId`
     * const quotaWalletWithShopIdOnly = await prisma.quotaWallet.createManyAndReturn({ 
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends QuotaWalletCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaWalletCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a QuotaWallet.
     * @param {QuotaWalletDeleteArgs} args - Arguments to delete one QuotaWallet.
     * @example
     * // Delete one QuotaWallet
     * const QuotaWallet = await prisma.quotaWallet.delete({
     *   where: {
     *     // ... filter to delete one QuotaWallet
     *   }
     * })
     * 
    **/
    delete<T extends QuotaWalletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaWalletDeleteArgs<ExtArgs>>
    ): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one QuotaWallet.
     * @param {QuotaWalletUpdateArgs} args - Arguments to update one QuotaWallet.
     * @example
     * // Update one QuotaWallet
     * const quotaWallet = await prisma.quotaWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuotaWalletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaWalletUpdateArgs<ExtArgs>>
    ): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more QuotaWallets.
     * @param {QuotaWalletDeleteManyArgs} args - Arguments to filter QuotaWallets to delete.
     * @example
     * // Delete a few QuotaWallets
     * const { count } = await prisma.quotaWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuotaWalletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaWalletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotaWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotaWallets
     * const quotaWallet = await prisma.quotaWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuotaWalletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaWalletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuotaWallet.
     * @param {QuotaWalletUpsertArgs} args - Arguments to update or create a QuotaWallet.
     * @example
     * // Update or create a QuotaWallet
     * const quotaWallet = await prisma.quotaWallet.upsert({
     *   create: {
     *     // ... data to create a QuotaWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotaWallet we want to update
     *   }
     * })
    **/
    upsert<T extends QuotaWalletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaWalletUpsertArgs<ExtArgs>>
    ): Prisma__QuotaWalletClient<$Result.GetResult<Prisma.$QuotaWalletPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of QuotaWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaWalletCountArgs} args - Arguments to filter QuotaWallets to count.
     * @example
     * // Count the number of QuotaWallets
     * const count = await prisma.quotaWallet.count({
     *   where: {
     *     // ... the filter for the QuotaWallets we want to count
     *   }
     * })
    **/
    count<T extends QuotaWalletCountArgs>(
      args?: Subset<T, QuotaWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotaWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotaWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotaWalletAggregateArgs>(args: Subset<T, QuotaWalletAggregateArgs>): Prisma.PrismaPromise<GetQuotaWalletAggregateType<T>>

    /**
     * Group by QuotaWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotaWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotaWalletGroupByArgs['orderBy'] }
        : { orderBy?: QuotaWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotaWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotaWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotaWallet model
   */
  readonly fields: QuotaWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotaWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotaWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the QuotaWallet model
   */ 
  interface QuotaWalletFieldRefs {
    readonly shopId: FieldRef<"QuotaWallet", 'String'>
    readonly weeklyLiveBaseLimit: FieldRef<"QuotaWallet", 'Int'>
    readonly weeklyLiveUsed: FieldRef<"QuotaWallet", 'Int'>
    readonly weeklyLiveWeekKey: FieldRef<"QuotaWallet", 'String'>
    readonly liveExtraBalance: FieldRef<"QuotaWallet", 'Int'>
    readonly reelDailyLimit: FieldRef<"QuotaWallet", 'Int'>
    readonly reelDailyUsed: FieldRef<"QuotaWallet", 'Int'>
    readonly reelDailyDateKey: FieldRef<"QuotaWallet", 'String'>
    readonly reelExtraBalance: FieldRef<"QuotaWallet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuotaWallet findUnique
   */
  export type QuotaWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * Filter, which QuotaWallet to fetch.
     */
    where: QuotaWalletWhereUniqueInput
  }

  /**
   * QuotaWallet findUniqueOrThrow
   */
  export type QuotaWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * Filter, which QuotaWallet to fetch.
     */
    where: QuotaWalletWhereUniqueInput
  }

  /**
   * QuotaWallet findFirst
   */
  export type QuotaWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * Filter, which QuotaWallet to fetch.
     */
    where?: QuotaWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotaWallets to fetch.
     */
    orderBy?: QuotaWalletOrderByWithRelationInput | QuotaWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotaWallets.
     */
    cursor?: QuotaWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotaWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotaWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotaWallets.
     */
    distinct?: QuotaWalletScalarFieldEnum | QuotaWalletScalarFieldEnum[]
  }

  /**
   * QuotaWallet findFirstOrThrow
   */
  export type QuotaWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * Filter, which QuotaWallet to fetch.
     */
    where?: QuotaWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotaWallets to fetch.
     */
    orderBy?: QuotaWalletOrderByWithRelationInput | QuotaWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotaWallets.
     */
    cursor?: QuotaWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotaWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotaWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotaWallets.
     */
    distinct?: QuotaWalletScalarFieldEnum | QuotaWalletScalarFieldEnum[]
  }

  /**
   * QuotaWallet findMany
   */
  export type QuotaWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * Filter, which QuotaWallets to fetch.
     */
    where?: QuotaWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotaWallets to fetch.
     */
    orderBy?: QuotaWalletOrderByWithRelationInput | QuotaWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotaWallets.
     */
    cursor?: QuotaWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotaWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotaWallets.
     */
    skip?: number
    distinct?: QuotaWalletScalarFieldEnum | QuotaWalletScalarFieldEnum[]
  }

  /**
   * QuotaWallet create
   */
  export type QuotaWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotaWallet.
     */
    data: XOR<QuotaWalletCreateInput, QuotaWalletUncheckedCreateInput>
  }

  /**
   * QuotaWallet createMany
   */
  export type QuotaWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotaWallets.
     */
    data: QuotaWalletCreateManyInput | QuotaWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuotaWallet createManyAndReturn
   */
  export type QuotaWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuotaWallets.
     */
    data: QuotaWalletCreateManyInput | QuotaWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotaWallet update
   */
  export type QuotaWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotaWallet.
     */
    data: XOR<QuotaWalletUpdateInput, QuotaWalletUncheckedUpdateInput>
    /**
     * Choose, which QuotaWallet to update.
     */
    where: QuotaWalletWhereUniqueInput
  }

  /**
   * QuotaWallet updateMany
   */
  export type QuotaWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotaWallets.
     */
    data: XOR<QuotaWalletUpdateManyMutationInput, QuotaWalletUncheckedUpdateManyInput>
    /**
     * Filter which QuotaWallets to update
     */
    where?: QuotaWalletWhereInput
  }

  /**
   * QuotaWallet upsert
   */
  export type QuotaWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotaWallet to update in case it exists.
     */
    where: QuotaWalletWhereUniqueInput
    /**
     * In case the QuotaWallet found by the `where` argument doesn't exist, create a new QuotaWallet with this data.
     */
    create: XOR<QuotaWalletCreateInput, QuotaWalletUncheckedCreateInput>
    /**
     * In case the QuotaWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotaWalletUpdateInput, QuotaWalletUncheckedUpdateInput>
  }

  /**
   * QuotaWallet delete
   */
  export type QuotaWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
    /**
     * Filter which QuotaWallet to delete.
     */
    where: QuotaWalletWhereUniqueInput
  }

  /**
   * QuotaWallet deleteMany
   */
  export type QuotaWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotaWallets to delete
     */
    where?: QuotaWalletWhereInput
  }

  /**
   * QuotaWallet without action
   */
  export type QuotaWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaWallet
     */
    select?: QuotaWalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaWalletInclude<ExtArgs> | null
  }


  /**
   * Model QuotaTransaction
   */

  export type AggregateQuotaTransaction = {
    _count: QuotaTransactionCountAggregateOutputType | null
    _avg: QuotaTransactionAvgAggregateOutputType | null
    _sum: QuotaTransactionSumAggregateOutputType | null
    _min: QuotaTransactionMinAggregateOutputType | null
    _max: QuotaTransactionMaxAggregateOutputType | null
  }

  export type QuotaTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type QuotaTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type QuotaTransactionMinAggregateOutputType = {
    txnId: string | null
    shopId: string | null
    resource: $Enums.QuotaResource | null
    direction: $Enums.QuotaDirection | null
    amount: number | null
    reason: $Enums.QuotaReason | null
    refType: $Enums.QuotaRefType | null
    refId: string | null
    actorType: $Enums.QuotaActorType | null
    actorId: string | null
    createdAt: Date | null
  }

  export type QuotaTransactionMaxAggregateOutputType = {
    txnId: string | null
    shopId: string | null
    resource: $Enums.QuotaResource | null
    direction: $Enums.QuotaDirection | null
    amount: number | null
    reason: $Enums.QuotaReason | null
    refType: $Enums.QuotaRefType | null
    refId: string | null
    actorType: $Enums.QuotaActorType | null
    actorId: string | null
    createdAt: Date | null
  }

  export type QuotaTransactionCountAggregateOutputType = {
    txnId: number
    shopId: number
    resource: number
    direction: number
    amount: number
    reason: number
    refType: number
    refId: number
    actorType: number
    actorId: number
    createdAt: number
    _all: number
  }


  export type QuotaTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type QuotaTransactionSumAggregateInputType = {
    amount?: true
  }

  export type QuotaTransactionMinAggregateInputType = {
    txnId?: true
    shopId?: true
    resource?: true
    direction?: true
    amount?: true
    reason?: true
    refType?: true
    refId?: true
    actorType?: true
    actorId?: true
    createdAt?: true
  }

  export type QuotaTransactionMaxAggregateInputType = {
    txnId?: true
    shopId?: true
    resource?: true
    direction?: true
    amount?: true
    reason?: true
    refType?: true
    refId?: true
    actorType?: true
    actorId?: true
    createdAt?: true
  }

  export type QuotaTransactionCountAggregateInputType = {
    txnId?: true
    shopId?: true
    resource?: true
    direction?: true
    amount?: true
    reason?: true
    refType?: true
    refId?: true
    actorType?: true
    actorId?: true
    createdAt?: true
    _all?: true
  }

  export type QuotaTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotaTransaction to aggregate.
     */
    where?: QuotaTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotaTransactions to fetch.
     */
    orderBy?: QuotaTransactionOrderByWithRelationInput | QuotaTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotaTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotaTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotaTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotaTransactions
    **/
    _count?: true | QuotaTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotaTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotaTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotaTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotaTransactionMaxAggregateInputType
  }

  export type GetQuotaTransactionAggregateType<T extends QuotaTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotaTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotaTransaction[P]>
      : GetScalarType<T[P], AggregateQuotaTransaction[P]>
  }




  export type QuotaTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotaTransactionWhereInput
    orderBy?: QuotaTransactionOrderByWithAggregationInput | QuotaTransactionOrderByWithAggregationInput[]
    by: QuotaTransactionScalarFieldEnum[] | QuotaTransactionScalarFieldEnum
    having?: QuotaTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotaTransactionCountAggregateInputType | true
    _avg?: QuotaTransactionAvgAggregateInputType
    _sum?: QuotaTransactionSumAggregateInputType
    _min?: QuotaTransactionMinAggregateInputType
    _max?: QuotaTransactionMaxAggregateInputType
  }

  export type QuotaTransactionGroupByOutputType = {
    txnId: string
    shopId: string
    resource: $Enums.QuotaResource
    direction: $Enums.QuotaDirection
    amount: number
    reason: $Enums.QuotaReason
    refType: $Enums.QuotaRefType | null
    refId: string | null
    actorType: $Enums.QuotaActorType
    actorId: string | null
    createdAt: Date
    _count: QuotaTransactionCountAggregateOutputType | null
    _avg: QuotaTransactionAvgAggregateOutputType | null
    _sum: QuotaTransactionSumAggregateOutputType | null
    _min: QuotaTransactionMinAggregateOutputType | null
    _max: QuotaTransactionMaxAggregateOutputType | null
  }

  type GetQuotaTransactionGroupByPayload<T extends QuotaTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotaTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotaTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotaTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], QuotaTransactionGroupByOutputType[P]>
        }
      >
    >


  export type QuotaTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    txnId?: boolean
    shopId?: boolean
    resource?: boolean
    direction?: boolean
    amount?: boolean
    reason?: boolean
    refType?: boolean
    refId?: boolean
    actorType?: boolean
    actorId?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotaTransaction"]>

  export type QuotaTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    txnId?: boolean
    shopId?: boolean
    resource?: boolean
    direction?: boolean
    amount?: boolean
    reason?: boolean
    refType?: boolean
    refId?: boolean
    actorType?: boolean
    actorId?: boolean
    createdAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotaTransaction"]>

  export type QuotaTransactionSelectScalar = {
    txnId?: boolean
    shopId?: boolean
    resource?: boolean
    direction?: boolean
    amount?: boolean
    reason?: boolean
    refType?: boolean
    refId?: boolean
    actorType?: boolean
    actorId?: boolean
    createdAt?: boolean
  }

  export type QuotaTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type QuotaTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $QuotaTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotaTransaction"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      txnId: string
      shopId: string
      resource: $Enums.QuotaResource
      direction: $Enums.QuotaDirection
      amount: number
      reason: $Enums.QuotaReason
      refType: $Enums.QuotaRefType | null
      refId: string | null
      actorType: $Enums.QuotaActorType
      actorId: string | null
      createdAt: Date
    }, ExtArgs["result"]["quotaTransaction"]>
    composites: {}
  }

  type QuotaTransactionGetPayload<S extends boolean | null | undefined | QuotaTransactionDefaultArgs> = $Result.GetResult<Prisma.$QuotaTransactionPayload, S>

  type QuotaTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuotaTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuotaTransactionCountAggregateInputType | true
    }

  export interface QuotaTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotaTransaction'], meta: { name: 'QuotaTransaction' } }
    /**
     * Find zero or one QuotaTransaction that matches the filter.
     * @param {QuotaTransactionFindUniqueArgs} args - Arguments to find a QuotaTransaction
     * @example
     * // Get one QuotaTransaction
     * const quotaTransaction = await prisma.quotaTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuotaTransactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaTransactionFindUniqueArgs<ExtArgs>>
    ): Prisma__QuotaTransactionClient<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one QuotaTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuotaTransactionFindUniqueOrThrowArgs} args - Arguments to find a QuotaTransaction
     * @example
     * // Get one QuotaTransaction
     * const quotaTransaction = await prisma.quotaTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuotaTransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaTransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuotaTransactionClient<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first QuotaTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaTransactionFindFirstArgs} args - Arguments to find a QuotaTransaction
     * @example
     * // Get one QuotaTransaction
     * const quotaTransaction = await prisma.quotaTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuotaTransactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaTransactionFindFirstArgs<ExtArgs>>
    ): Prisma__QuotaTransactionClient<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first QuotaTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaTransactionFindFirstOrThrowArgs} args - Arguments to find a QuotaTransaction
     * @example
     * // Get one QuotaTransaction
     * const quotaTransaction = await prisma.quotaTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuotaTransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaTransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuotaTransactionClient<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more QuotaTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotaTransactions
     * const quotaTransactions = await prisma.quotaTransaction.findMany()
     * 
     * // Get first 10 QuotaTransactions
     * const quotaTransactions = await prisma.quotaTransaction.findMany({ take: 10 })
     * 
     * // Only select the `txnId`
     * const quotaTransactionWithTxnIdOnly = await prisma.quotaTransaction.findMany({ select: { txnId: true } })
     * 
    **/
    findMany<T extends QuotaTransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaTransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a QuotaTransaction.
     * @param {QuotaTransactionCreateArgs} args - Arguments to create a QuotaTransaction.
     * @example
     * // Create one QuotaTransaction
     * const QuotaTransaction = await prisma.quotaTransaction.create({
     *   data: {
     *     // ... data to create a QuotaTransaction
     *   }
     * })
     * 
    **/
    create<T extends QuotaTransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaTransactionCreateArgs<ExtArgs>>
    ): Prisma__QuotaTransactionClient<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many QuotaTransactions.
     * @param {QuotaTransactionCreateManyArgs} args - Arguments to create many QuotaTransactions.
     * @example
     * // Create many QuotaTransactions
     * const quotaTransaction = await prisma.quotaTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends QuotaTransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaTransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotaTransactions and returns the data saved in the database.
     * @param {QuotaTransactionCreateManyAndReturnArgs} args - Arguments to create many QuotaTransactions.
     * @example
     * // Create many QuotaTransactions
     * const quotaTransaction = await prisma.quotaTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotaTransactions and only return the `txnId`
     * const quotaTransactionWithTxnIdOnly = await prisma.quotaTransaction.createManyAndReturn({ 
     *   select: { txnId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends QuotaTransactionCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaTransactionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a QuotaTransaction.
     * @param {QuotaTransactionDeleteArgs} args - Arguments to delete one QuotaTransaction.
     * @example
     * // Delete one QuotaTransaction
     * const QuotaTransaction = await prisma.quotaTransaction.delete({
     *   where: {
     *     // ... filter to delete one QuotaTransaction
     *   }
     * })
     * 
    **/
    delete<T extends QuotaTransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaTransactionDeleteArgs<ExtArgs>>
    ): Prisma__QuotaTransactionClient<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one QuotaTransaction.
     * @param {QuotaTransactionUpdateArgs} args - Arguments to update one QuotaTransaction.
     * @example
     * // Update one QuotaTransaction
     * const quotaTransaction = await prisma.quotaTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuotaTransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaTransactionUpdateArgs<ExtArgs>>
    ): Prisma__QuotaTransactionClient<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more QuotaTransactions.
     * @param {QuotaTransactionDeleteManyArgs} args - Arguments to filter QuotaTransactions to delete.
     * @example
     * // Delete a few QuotaTransactions
     * const { count } = await prisma.quotaTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuotaTransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuotaTransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotaTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotaTransactions
     * const quotaTransaction = await prisma.quotaTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuotaTransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaTransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuotaTransaction.
     * @param {QuotaTransactionUpsertArgs} args - Arguments to update or create a QuotaTransaction.
     * @example
     * // Update or create a QuotaTransaction
     * const quotaTransaction = await prisma.quotaTransaction.upsert({
     *   create: {
     *     // ... data to create a QuotaTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotaTransaction we want to update
     *   }
     * })
    **/
    upsert<T extends QuotaTransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuotaTransactionUpsertArgs<ExtArgs>>
    ): Prisma__QuotaTransactionClient<$Result.GetResult<Prisma.$QuotaTransactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of QuotaTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaTransactionCountArgs} args - Arguments to filter QuotaTransactions to count.
     * @example
     * // Count the number of QuotaTransactions
     * const count = await prisma.quotaTransaction.count({
     *   where: {
     *     // ... the filter for the QuotaTransactions we want to count
     *   }
     * })
    **/
    count<T extends QuotaTransactionCountArgs>(
      args?: Subset<T, QuotaTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotaTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotaTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotaTransactionAggregateArgs>(args: Subset<T, QuotaTransactionAggregateArgs>): Prisma.PrismaPromise<GetQuotaTransactionAggregateType<T>>

    /**
     * Group by QuotaTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotaTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotaTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotaTransactionGroupByArgs['orderBy'] }
        : { orderBy?: QuotaTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotaTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotaTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotaTransaction model
   */
  readonly fields: QuotaTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotaTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotaTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the QuotaTransaction model
   */ 
  interface QuotaTransactionFieldRefs {
    readonly txnId: FieldRef<"QuotaTransaction", 'String'>
    readonly shopId: FieldRef<"QuotaTransaction", 'String'>
    readonly resource: FieldRef<"QuotaTransaction", 'QuotaResource'>
    readonly direction: FieldRef<"QuotaTransaction", 'QuotaDirection'>
    readonly amount: FieldRef<"QuotaTransaction", 'Int'>
    readonly reason: FieldRef<"QuotaTransaction", 'QuotaReason'>
    readonly refType: FieldRef<"QuotaTransaction", 'QuotaRefType'>
    readonly refId: FieldRef<"QuotaTransaction", 'String'>
    readonly actorType: FieldRef<"QuotaTransaction", 'QuotaActorType'>
    readonly actorId: FieldRef<"QuotaTransaction", 'String'>
    readonly createdAt: FieldRef<"QuotaTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuotaTransaction findUnique
   */
  export type QuotaTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * Filter, which QuotaTransaction to fetch.
     */
    where: QuotaTransactionWhereUniqueInput
  }

  /**
   * QuotaTransaction findUniqueOrThrow
   */
  export type QuotaTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * Filter, which QuotaTransaction to fetch.
     */
    where: QuotaTransactionWhereUniqueInput
  }

  /**
   * QuotaTransaction findFirst
   */
  export type QuotaTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * Filter, which QuotaTransaction to fetch.
     */
    where?: QuotaTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotaTransactions to fetch.
     */
    orderBy?: QuotaTransactionOrderByWithRelationInput | QuotaTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotaTransactions.
     */
    cursor?: QuotaTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotaTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotaTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotaTransactions.
     */
    distinct?: QuotaTransactionScalarFieldEnum | QuotaTransactionScalarFieldEnum[]
  }

  /**
   * QuotaTransaction findFirstOrThrow
   */
  export type QuotaTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * Filter, which QuotaTransaction to fetch.
     */
    where?: QuotaTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotaTransactions to fetch.
     */
    orderBy?: QuotaTransactionOrderByWithRelationInput | QuotaTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotaTransactions.
     */
    cursor?: QuotaTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotaTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotaTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotaTransactions.
     */
    distinct?: QuotaTransactionScalarFieldEnum | QuotaTransactionScalarFieldEnum[]
  }

  /**
   * QuotaTransaction findMany
   */
  export type QuotaTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * Filter, which QuotaTransactions to fetch.
     */
    where?: QuotaTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotaTransactions to fetch.
     */
    orderBy?: QuotaTransactionOrderByWithRelationInput | QuotaTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotaTransactions.
     */
    cursor?: QuotaTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotaTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotaTransactions.
     */
    skip?: number
    distinct?: QuotaTransactionScalarFieldEnum | QuotaTransactionScalarFieldEnum[]
  }

  /**
   * QuotaTransaction create
   */
  export type QuotaTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotaTransaction.
     */
    data: XOR<QuotaTransactionCreateInput, QuotaTransactionUncheckedCreateInput>
  }

  /**
   * QuotaTransaction createMany
   */
  export type QuotaTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotaTransactions.
     */
    data: QuotaTransactionCreateManyInput | QuotaTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuotaTransaction createManyAndReturn
   */
  export type QuotaTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuotaTransactions.
     */
    data: QuotaTransactionCreateManyInput | QuotaTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotaTransaction update
   */
  export type QuotaTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotaTransaction.
     */
    data: XOR<QuotaTransactionUpdateInput, QuotaTransactionUncheckedUpdateInput>
    /**
     * Choose, which QuotaTransaction to update.
     */
    where: QuotaTransactionWhereUniqueInput
  }

  /**
   * QuotaTransaction updateMany
   */
  export type QuotaTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotaTransactions.
     */
    data: XOR<QuotaTransactionUpdateManyMutationInput, QuotaTransactionUncheckedUpdateManyInput>
    /**
     * Filter which QuotaTransactions to update
     */
    where?: QuotaTransactionWhereInput
  }

  /**
   * QuotaTransaction upsert
   */
  export type QuotaTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotaTransaction to update in case it exists.
     */
    where: QuotaTransactionWhereUniqueInput
    /**
     * In case the QuotaTransaction found by the `where` argument doesn't exist, create a new QuotaTransaction with this data.
     */
    create: XOR<QuotaTransactionCreateInput, QuotaTransactionUncheckedCreateInput>
    /**
     * In case the QuotaTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotaTransactionUpdateInput, QuotaTransactionUncheckedUpdateInput>
  }

  /**
   * QuotaTransaction delete
   */
  export type QuotaTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
    /**
     * Filter which QuotaTransaction to delete.
     */
    where: QuotaTransactionWhereUniqueInput
  }

  /**
   * QuotaTransaction deleteMany
   */
  export type QuotaTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotaTransactions to delete
     */
    where?: QuotaTransactionWhereInput
  }

  /**
   * QuotaTransaction without action
   */
  export type QuotaTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotaTransaction
     */
    select?: QuotaTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotaTransactionInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseRequest
   */

  export type AggregatePurchaseRequest = {
    _count: PurchaseRequestCountAggregateOutputType | null
    _avg: PurchaseRequestAvgAggregateOutputType | null
    _sum: PurchaseRequestSumAggregateOutputType | null
    _min: PurchaseRequestMinAggregateOutputType | null
    _max: PurchaseRequestMaxAggregateOutputType | null
  }

  export type PurchaseRequestAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PurchaseRequestSumAggregateOutputType = {
    quantity: number | null
  }

  export type PurchaseRequestMinAggregateOutputType = {
    purchaseId: string | null
    shopId: string | null
    type: $Enums.PurchaseType | null
    quantity: number | null
    status: $Enums.PurchaseStatus | null
    createdAt: Date | null
    approvedAt: Date | null
    approvedByAdminId: string | null
    paymentProofUrl: string | null
    notes: string | null
  }

  export type PurchaseRequestMaxAggregateOutputType = {
    purchaseId: string | null
    shopId: string | null
    type: $Enums.PurchaseType | null
    quantity: number | null
    status: $Enums.PurchaseStatus | null
    createdAt: Date | null
    approvedAt: Date | null
    approvedByAdminId: string | null
    paymentProofUrl: string | null
    notes: string | null
  }

  export type PurchaseRequestCountAggregateOutputType = {
    purchaseId: number
    shopId: number
    type: number
    quantity: number
    status: number
    createdAt: number
    approvedAt: number
    approvedByAdminId: number
    paymentProofUrl: number
    notes: number
    _all: number
  }


  export type PurchaseRequestAvgAggregateInputType = {
    quantity?: true
  }

  export type PurchaseRequestSumAggregateInputType = {
    quantity?: true
  }

  export type PurchaseRequestMinAggregateInputType = {
    purchaseId?: true
    shopId?: true
    type?: true
    quantity?: true
    status?: true
    createdAt?: true
    approvedAt?: true
    approvedByAdminId?: true
    paymentProofUrl?: true
    notes?: true
  }

  export type PurchaseRequestMaxAggregateInputType = {
    purchaseId?: true
    shopId?: true
    type?: true
    quantity?: true
    status?: true
    createdAt?: true
    approvedAt?: true
    approvedByAdminId?: true
    paymentProofUrl?: true
    notes?: true
  }

  export type PurchaseRequestCountAggregateInputType = {
    purchaseId?: true
    shopId?: true
    type?: true
    quantity?: true
    status?: true
    createdAt?: true
    approvedAt?: true
    approvedByAdminId?: true
    paymentProofUrl?: true
    notes?: true
    _all?: true
  }

  export type PurchaseRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseRequest to aggregate.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseRequests
    **/
    _count?: true | PurchaseRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseRequestMaxAggregateInputType
  }

  export type GetPurchaseRequestAggregateType<T extends PurchaseRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseRequest[P]>
      : GetScalarType<T[P], AggregatePurchaseRequest[P]>
  }




  export type PurchaseRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithAggregationInput | PurchaseRequestOrderByWithAggregationInput[]
    by: PurchaseRequestScalarFieldEnum[] | PurchaseRequestScalarFieldEnum
    having?: PurchaseRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseRequestCountAggregateInputType | true
    _avg?: PurchaseRequestAvgAggregateInputType
    _sum?: PurchaseRequestSumAggregateInputType
    _min?: PurchaseRequestMinAggregateInputType
    _max?: PurchaseRequestMaxAggregateInputType
  }

  export type PurchaseRequestGroupByOutputType = {
    purchaseId: string
    shopId: string
    type: $Enums.PurchaseType
    quantity: number
    status: $Enums.PurchaseStatus
    createdAt: Date
    approvedAt: Date | null
    approvedByAdminId: string | null
    paymentProofUrl: string | null
    notes: string | null
    _count: PurchaseRequestCountAggregateOutputType | null
    _avg: PurchaseRequestAvgAggregateOutputType | null
    _sum: PurchaseRequestSumAggregateOutputType | null
    _min: PurchaseRequestMinAggregateOutputType | null
    _max: PurchaseRequestMaxAggregateOutputType | null
  }

  type GetPurchaseRequestGroupByPayload<T extends PurchaseRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseRequestGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    purchaseId?: boolean
    shopId?: boolean
    type?: boolean
    quantity?: boolean
    status?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    approvedByAdminId?: boolean
    paymentProofUrl?: boolean
    notes?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    approvedByAdmin?: boolean | PurchaseRequest$approvedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseRequest"]>

  export type PurchaseRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    purchaseId?: boolean
    shopId?: boolean
    type?: boolean
    quantity?: boolean
    status?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    approvedByAdminId?: boolean
    paymentProofUrl?: boolean
    notes?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    approvedByAdmin?: boolean | PurchaseRequest$approvedByAdminArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseRequest"]>

  export type PurchaseRequestSelectScalar = {
    purchaseId?: boolean
    shopId?: boolean
    type?: boolean
    quantity?: boolean
    status?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    approvedByAdminId?: boolean
    paymentProofUrl?: boolean
    notes?: boolean
  }

  export type PurchaseRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    approvedByAdmin?: boolean | PurchaseRequest$approvedByAdminArgs<ExtArgs>
  }
  export type PurchaseRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    approvedByAdmin?: boolean | PurchaseRequest$approvedByAdminArgs<ExtArgs>
  }

  export type $PurchaseRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseRequest"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      approvedByAdmin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      purchaseId: string
      shopId: string
      type: $Enums.PurchaseType
      quantity: number
      status: $Enums.PurchaseStatus
      createdAt: Date
      approvedAt: Date | null
      approvedByAdminId: string | null
      paymentProofUrl: string | null
      notes: string | null
    }, ExtArgs["result"]["purchaseRequest"]>
    composites: {}
  }

  type PurchaseRequestGetPayload<S extends boolean | null | undefined | PurchaseRequestDefaultArgs> = $Result.GetResult<Prisma.$PurchaseRequestPayload, S>

  type PurchaseRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseRequestCountAggregateInputType | true
    }

  export interface PurchaseRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseRequest'], meta: { name: 'PurchaseRequest' } }
    /**
     * Find zero or one PurchaseRequest that matches the filter.
     * @param {PurchaseRequestFindUniqueArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PurchaseRequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PurchaseRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseRequestFindUniqueOrThrowArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PurchaseRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PurchaseRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindFirstArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PurchaseRequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseRequestFindFirstArgs<ExtArgs>>
    ): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PurchaseRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindFirstOrThrowArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PurchaseRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PurchaseRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseRequests
     * const purchaseRequests = await prisma.purchaseRequest.findMany()
     * 
     * // Get first 10 PurchaseRequests
     * const purchaseRequests = await prisma.purchaseRequest.findMany({ take: 10 })
     * 
     * // Only select the `purchaseId`
     * const purchaseRequestWithPurchaseIdOnly = await prisma.purchaseRequest.findMany({ select: { purchaseId: true } })
     * 
    **/
    findMany<T extends PurchaseRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PurchaseRequest.
     * @param {PurchaseRequestCreateArgs} args - Arguments to create a PurchaseRequest.
     * @example
     * // Create one PurchaseRequest
     * const PurchaseRequest = await prisma.purchaseRequest.create({
     *   data: {
     *     // ... data to create a PurchaseRequest
     *   }
     * })
     * 
    **/
    create<T extends PurchaseRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseRequestCreateArgs<ExtArgs>>
    ): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PurchaseRequests.
     * @param {PurchaseRequestCreateManyArgs} args - Arguments to create many PurchaseRequests.
     * @example
     * // Create many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PurchaseRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseRequests and returns the data saved in the database.
     * @param {PurchaseRequestCreateManyAndReturnArgs} args - Arguments to create many PurchaseRequests.
     * @example
     * // Create many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseRequests and only return the `purchaseId`
     * const purchaseRequestWithPurchaseIdOnly = await prisma.purchaseRequest.createManyAndReturn({ 
     *   select: { purchaseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends PurchaseRequestCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseRequestCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a PurchaseRequest.
     * @param {PurchaseRequestDeleteArgs} args - Arguments to delete one PurchaseRequest.
     * @example
     * // Delete one PurchaseRequest
     * const PurchaseRequest = await prisma.purchaseRequest.delete({
     *   where: {
     *     // ... filter to delete one PurchaseRequest
     *   }
     * })
     * 
    **/
    delete<T extends PurchaseRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseRequestDeleteArgs<ExtArgs>>
    ): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PurchaseRequest.
     * @param {PurchaseRequestUpdateArgs} args - Arguments to update one PurchaseRequest.
     * @example
     * // Update one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PurchaseRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseRequestUpdateArgs<ExtArgs>>
    ): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PurchaseRequests.
     * @param {PurchaseRequestDeleteManyArgs} args - Arguments to filter PurchaseRequests to delete.
     * @example
     * // Delete a few PurchaseRequests
     * const { count } = await prisma.purchaseRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PurchaseRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PurchaseRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PurchaseRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseRequest.
     * @param {PurchaseRequestUpsertArgs} args - Arguments to update or create a PurchaseRequest.
     * @example
     * // Update or create a PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.upsert({
     *   create: {
     *     // ... data to create a PurchaseRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseRequest we want to update
     *   }
     * })
    **/
    upsert<T extends PurchaseRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PurchaseRequestUpsertArgs<ExtArgs>>
    ): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PurchaseRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestCountArgs} args - Arguments to filter PurchaseRequests to count.
     * @example
     * // Count the number of PurchaseRequests
     * const count = await prisma.purchaseRequest.count({
     *   where: {
     *     // ... the filter for the PurchaseRequests we want to count
     *   }
     * })
    **/
    count<T extends PurchaseRequestCountArgs>(
      args?: Subset<T, PurchaseRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseRequestAggregateArgs>(args: Subset<T, PurchaseRequestAggregateArgs>): Prisma.PrismaPromise<GetPurchaseRequestAggregateType<T>>

    /**
     * Group by PurchaseRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseRequestGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseRequest model
   */
  readonly fields: PurchaseRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    approvedByAdmin<T extends PurchaseRequest$approvedByAdminArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseRequest$approvedByAdminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PurchaseRequest model
   */ 
  interface PurchaseRequestFieldRefs {
    readonly purchaseId: FieldRef<"PurchaseRequest", 'String'>
    readonly shopId: FieldRef<"PurchaseRequest", 'String'>
    readonly type: FieldRef<"PurchaseRequest", 'PurchaseType'>
    readonly quantity: FieldRef<"PurchaseRequest", 'Int'>
    readonly status: FieldRef<"PurchaseRequest", 'PurchaseStatus'>
    readonly createdAt: FieldRef<"PurchaseRequest", 'DateTime'>
    readonly approvedAt: FieldRef<"PurchaseRequest", 'DateTime'>
    readonly approvedByAdminId: FieldRef<"PurchaseRequest", 'String'>
    readonly paymentProofUrl: FieldRef<"PurchaseRequest", 'String'>
    readonly notes: FieldRef<"PurchaseRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseRequest findUnique
   */
  export type PurchaseRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest findUniqueOrThrow
   */
  export type PurchaseRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest findFirst
   */
  export type PurchaseRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseRequests.
     */
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest findFirstOrThrow
   */
  export type PurchaseRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseRequests.
     */
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest findMany
   */
  export type PurchaseRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequests to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest create
   */
  export type PurchaseRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseRequest.
     */
    data: XOR<PurchaseRequestCreateInput, PurchaseRequestUncheckedCreateInput>
  }

  /**
   * PurchaseRequest createMany
   */
  export type PurchaseRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseRequests.
     */
    data: PurchaseRequestCreateManyInput | PurchaseRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseRequest createManyAndReturn
   */
  export type PurchaseRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseRequests.
     */
    data: PurchaseRequestCreateManyInput | PurchaseRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseRequest update
   */
  export type PurchaseRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseRequest.
     */
    data: XOR<PurchaseRequestUpdateInput, PurchaseRequestUncheckedUpdateInput>
    /**
     * Choose, which PurchaseRequest to update.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest updateMany
   */
  export type PurchaseRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseRequests.
     */
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseRequests to update
     */
    where?: PurchaseRequestWhereInput
  }

  /**
   * PurchaseRequest upsert
   */
  export type PurchaseRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseRequest to update in case it exists.
     */
    where: PurchaseRequestWhereUniqueInput
    /**
     * In case the PurchaseRequest found by the `where` argument doesn't exist, create a new PurchaseRequest with this data.
     */
    create: XOR<PurchaseRequestCreateInput, PurchaseRequestUncheckedCreateInput>
    /**
     * In case the PurchaseRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseRequestUpdateInput, PurchaseRequestUncheckedUpdateInput>
  }

  /**
   * PurchaseRequest delete
   */
  export type PurchaseRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter which PurchaseRequest to delete.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest deleteMany
   */
  export type PurchaseRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseRequests to delete
     */
    where?: PurchaseRequestWhereInput
  }

  /**
   * PurchaseRequest.approvedByAdmin
   */
  export type PurchaseRequest$approvedByAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * PurchaseRequest without action
   */
  export type PurchaseRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuthUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    userType: 'userType',
    status: 'status',
    createdAt: 'createdAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type AuthUserScalarFieldEnum = (typeof AuthUserScalarFieldEnum)[keyof typeof AuthUserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    authUserId: 'authUserId',
    role: 'role',
    adminStatus: 'adminStatus',
    createdAt: 'createdAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    authUserId: 'authUserId',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logoUrl: 'logoUrl',
    website: 'website',
    authUserId: 'authUserId',
    requiresEmailFix: 'requiresEmailFix',
    razonSocial: 'razonSocial',
    cuit: 'cuit',
    email: 'email',
    password: 'password',
    address: 'address',
    addressDetails: 'addressDetails',
    minimumPurchase: 'minimumPurchase',
    paymentMethods: 'paymentMethods',
    plan: 'plan',
    status: 'status',
    statusReason: 'statusReason',
    statusChangedAt: 'statusChangedAt',
    agendaSuspendedUntil: 'agendaSuspendedUntil',
    agendaSuspendedByAdminId: 'agendaSuspendedByAdminId',
    agendaSuspendedReason: 'agendaSuspendedReason',
    streamQuota: 'streamQuota',
    reelQuota: 'reelQuota',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const StreamScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    title: 'title',
    description: 'description',
    status: 'status',
    scheduledAt: 'scheduledAt',
    scheduledEndPlanned: 'scheduledEndPlanned',
    timezone: 'timezone',
    startTime: 'startTime',
    endTime: 'endTime',
    durationMinutes: 'durationMinutes',
    cancelledAt: 'cancelledAt',
    cancelReason: 'cancelReason',
    hidden: 'hidden',
    visibilityReason: 'visibilityReason',
    platform: 'platform',
    url: 'url',
    extensionCount: 'extensionCount',
    reportCount: 'reportCount',
    editCount: 'editCount',
    lastEditedAt: 'lastEditedAt',
    originalScheduledAt: 'originalScheduledAt',
    reprogrammedFromId: 'reprogrammedFromId',
    reprogramReason: 'reprogramReason',
    pendingReprogramNote: 'pendingReprogramNote',
    reprogramBatchId: 'reprogramBatchId',
    createdAt: 'createdAt'
  };

  export type StreamScalarFieldEnum = (typeof StreamScalarFieldEnum)[keyof typeof StreamScalarFieldEnum]


  export const ReelScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    url: 'url',
    platform: 'platform',
    hidden: 'hidden',
    views: 'views',
    createdAt: 'createdAt'
  };

  export type ReelScalarFieldEnum = (typeof ReelScalarFieldEnum)[keyof typeof ReelScalarFieldEnum]


  export const ShopSocialHandleScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    platform: 'platform',
    handle: 'handle',
    createdAt: 'createdAt'
  };

  export type ShopSocialHandleScalarFieldEnum = (typeof ShopSocialHandleScalarFieldEnum)[keyof typeof ShopSocialHandleScalarFieldEnum]


  export const ShopWhatsappLineScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    label: 'label',
    number: 'number',
    createdAt: 'createdAt'
  };

  export type ShopWhatsappLineScalarFieldEnum = (typeof ShopWhatsappLineScalarFieldEnum)[keyof typeof ShopWhatsappLineScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    streamId: 'streamId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    streamId: 'streamId',
    userId: 'userId',
    reason: 'reason',
    status: 'status',
    resolved: 'resolved',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const PenaltyScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    reason: 'reason',
    active: 'active',
    createdAt: 'createdAt'
  };

  export type PenaltyScalarFieldEnum = (typeof PenaltyScalarFieldEnum)[keyof typeof PenaltyScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    shopId: 'shopId'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const AgendaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    streamId: 'streamId'
  };

  export type AgendaScalarFieldEnum = (typeof AgendaScalarFieldEnum)[keyof typeof AgendaScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const QuotaWalletScalarFieldEnum: {
    shopId: 'shopId',
    weeklyLiveBaseLimit: 'weeklyLiveBaseLimit',
    weeklyLiveUsed: 'weeklyLiveUsed',
    weeklyLiveWeekKey: 'weeklyLiveWeekKey',
    liveExtraBalance: 'liveExtraBalance',
    reelDailyLimit: 'reelDailyLimit',
    reelDailyUsed: 'reelDailyUsed',
    reelDailyDateKey: 'reelDailyDateKey',
    reelExtraBalance: 'reelExtraBalance'
  };

  export type QuotaWalletScalarFieldEnum = (typeof QuotaWalletScalarFieldEnum)[keyof typeof QuotaWalletScalarFieldEnum]


  export const QuotaTransactionScalarFieldEnum: {
    txnId: 'txnId',
    shopId: 'shopId',
    resource: 'resource',
    direction: 'direction',
    amount: 'amount',
    reason: 'reason',
    refType: 'refType',
    refId: 'refId',
    actorType: 'actorType',
    actorId: 'actorId',
    createdAt: 'createdAt'
  };

  export type QuotaTransactionScalarFieldEnum = (typeof QuotaTransactionScalarFieldEnum)[keyof typeof QuotaTransactionScalarFieldEnum]


  export const PurchaseRequestScalarFieldEnum: {
    purchaseId: 'purchaseId',
    shopId: 'shopId',
    type: 'type',
    quantity: 'quantity',
    status: 'status',
    createdAt: 'createdAt',
    approvedAt: 'approvedAt',
    approvedByAdminId: 'approvedByAdminId',
    paymentProofUrl: 'paymentProofUrl',
    notes: 'notes'
  };

  export type PurchaseRequestScalarFieldEnum = (typeof PurchaseRequestScalarFieldEnum)[keyof typeof PurchaseRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AuthUserType'
   */
  export type EnumAuthUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthUserType'>
    


  /**
   * Reference to a field of type 'AuthUserType[]'
   */
  export type ListEnumAuthUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthUserType[]'>
    


  /**
   * Reference to a field of type 'AuthUserStatus'
   */
  export type EnumAuthUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthUserStatus'>
    


  /**
   * Reference to a field of type 'AuthUserStatus[]'
   */
  export type ListEnumAuthUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthUserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AdminRole'
   */
  export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


  /**
   * Reference to a field of type 'AdminRole[]'
   */
  export type ListEnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole[]'>
    


  /**
   * Reference to a field of type 'AdminStatus'
   */
  export type EnumAdminStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminStatus'>
    


  /**
   * Reference to a field of type 'AdminStatus[]'
   */
  export type ListEnumAdminStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ShopStatus'
   */
  export type EnumShopStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopStatus'>
    


  /**
   * Reference to a field of type 'ShopStatus[]'
   */
  export type ListEnumShopStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopStatus[]'>
    


  /**
   * Reference to a field of type 'StreamStatus'
   */
  export type EnumStreamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StreamStatus'>
    


  /**
   * Reference to a field of type 'StreamStatus[]'
   */
  export type ListEnumStreamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StreamStatus[]'>
    


  /**
   * Reference to a field of type 'SocialPlatform'
   */
  export type EnumSocialPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialPlatform'>
    


  /**
   * Reference to a field of type 'SocialPlatform[]'
   */
  export type ListEnumSocialPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialPlatform[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'QuotaResource'
   */
  export type EnumQuotaResourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaResource'>
    


  /**
   * Reference to a field of type 'QuotaResource[]'
   */
  export type ListEnumQuotaResourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaResource[]'>
    


  /**
   * Reference to a field of type 'QuotaDirection'
   */
  export type EnumQuotaDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaDirection'>
    


  /**
   * Reference to a field of type 'QuotaDirection[]'
   */
  export type ListEnumQuotaDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaDirection[]'>
    


  /**
   * Reference to a field of type 'QuotaReason'
   */
  export type EnumQuotaReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaReason'>
    


  /**
   * Reference to a field of type 'QuotaReason[]'
   */
  export type ListEnumQuotaReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaReason[]'>
    


  /**
   * Reference to a field of type 'QuotaRefType'
   */
  export type EnumQuotaRefTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaRefType'>
    


  /**
   * Reference to a field of type 'QuotaRefType[]'
   */
  export type ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaRefType[]'>
    


  /**
   * Reference to a field of type 'QuotaActorType'
   */
  export type EnumQuotaActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaActorType'>
    


  /**
   * Reference to a field of type 'QuotaActorType[]'
   */
  export type ListEnumQuotaActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotaActorType[]'>
    


  /**
   * Reference to a field of type 'PurchaseType'
   */
  export type EnumPurchaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseType'>
    


  /**
   * Reference to a field of type 'PurchaseType[]'
   */
  export type ListEnumPurchaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseType[]'>
    


  /**
   * Reference to a field of type 'PurchaseStatus'
   */
  export type EnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus'>
    


  /**
   * Reference to a field of type 'PurchaseStatus[]'
   */
  export type ListEnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AuthUserWhereInput = {
    AND?: AuthUserWhereInput | AuthUserWhereInput[]
    OR?: AuthUserWhereInput[]
    NOT?: AuthUserWhereInput | AuthUserWhereInput[]
    id?: StringFilter<"AuthUser"> | string
    email?: StringFilter<"AuthUser"> | string
    passwordHash?: StringNullableFilter<"AuthUser"> | string | null
    userType?: EnumAuthUserTypeFilter<"AuthUser"> | $Enums.AuthUserType
    status?: EnumAuthUserStatusFilter<"AuthUser"> | $Enums.AuthUserStatus
    createdAt?: DateTimeFilter<"AuthUser"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"AuthUser"> | Date | string | null
    shop?: XOR<ShopNullableRelationFilter, ShopWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }

  export type AuthUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    userType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    shop?: ShopOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type AuthUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AuthUserWhereInput | AuthUserWhereInput[]
    OR?: AuthUserWhereInput[]
    NOT?: AuthUserWhereInput | AuthUserWhereInput[]
    passwordHash?: StringNullableFilter<"AuthUser"> | string | null
    userType?: EnumAuthUserTypeFilter<"AuthUser"> | $Enums.AuthUserType
    status?: EnumAuthUserStatusFilter<"AuthUser"> | $Enums.AuthUserStatus
    createdAt?: DateTimeFilter<"AuthUser"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"AuthUser"> | Date | string | null
    shop?: XOR<ShopNullableRelationFilter, ShopWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }, "id" | "email">

  export type AuthUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    userType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: AuthUserCountOrderByAggregateInput
    _max?: AuthUserMaxOrderByAggregateInput
    _min?: AuthUserMinOrderByAggregateInput
  }

  export type AuthUserScalarWhereWithAggregatesInput = {
    AND?: AuthUserScalarWhereWithAggregatesInput | AuthUserScalarWhereWithAggregatesInput[]
    OR?: AuthUserScalarWhereWithAggregatesInput[]
    NOT?: AuthUserScalarWhereWithAggregatesInput | AuthUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuthUser"> | string
    email?: StringWithAggregatesFilter<"AuthUser"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"AuthUser"> | string | null
    userType?: EnumAuthUserTypeWithAggregatesFilter<"AuthUser"> | $Enums.AuthUserType
    status?: EnumAuthUserStatusWithAggregatesFilter<"AuthUser"> | $Enums.AuthUserStatus
    createdAt?: DateTimeWithAggregatesFilter<"AuthUser"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"AuthUser"> | Date | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    authUserId?: StringFilter<"Admin"> | string
    role?: EnumAdminRoleFilter<"Admin"> | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    authUser?: XOR<AuthUserRelationFilter, AuthUserWhereInput>
    approvedPurchaseRequests?: PurchaseRequestListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    authUserId?: SortOrder
    role?: SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
    authUser?: AuthUserOrderByWithRelationInput
    approvedPurchaseRequests?: PurchaseRequestOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    authUserId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    role?: EnumAdminRoleFilter<"Admin"> | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    authUser?: XOR<AuthUserRelationFilter, AuthUserWhereInput>
    approvedPurchaseRequests?: PurchaseRequestListRelationFilter
  }, "authUserId">

  export type AdminOrderByWithAggregationInput = {
    authUserId?: SortOrder
    role?: SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    authUserId?: StringWithAggregatesFilter<"Admin"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"Admin"> | $Enums.AdminRole
    adminStatus?: EnumAdminStatusWithAggregatesFilter<"Admin"> | $Enums.AdminStatus
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    authUserId?: StringFilter<"Client"> | string
    displayName?: StringNullableFilter<"Client"> | string | null
    avatarUrl?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    authUser?: XOR<AuthUserRelationFilter, AuthUserWhereInput>
  }

  export type ClientOrderByWithRelationInput = {
    authUserId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    authUser?: AuthUserOrderByWithRelationInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    authUserId?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    displayName?: StringNullableFilter<"Client"> | string | null
    avatarUrl?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    authUser?: XOR<AuthUserRelationFilter, AuthUserWhereInput>
  }, "authUserId">

  export type ClientOrderByWithAggregationInput = {
    authUserId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    authUserId?: StringWithAggregatesFilter<"Client"> | string
    displayName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    favorites?: FavoriteListRelationFilter
    agenda?: AgendaListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    favorites?: FavoriteOrderByRelationAggregateInput
    agenda?: AgendaOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    favorites?: FavoriteListRelationFilter
    agenda?: AgendaListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ShopWhereInput = {
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    id?: StringFilter<"Shop"> | string
    name?: StringFilter<"Shop"> | string
    slug?: StringFilter<"Shop"> | string
    logoUrl?: StringNullableFilter<"Shop"> | string | null
    website?: StringNullableFilter<"Shop"> | string | null
    authUserId?: StringNullableFilter<"Shop"> | string | null
    requiresEmailFix?: BoolFilter<"Shop"> | boolean
    razonSocial?: StringNullableFilter<"Shop"> | string | null
    cuit?: StringNullableFilter<"Shop"> | string | null
    email?: StringNullableFilter<"Shop"> | string | null
    password?: StringNullableFilter<"Shop"> | string | null
    address?: StringNullableFilter<"Shop"> | string | null
    addressDetails?: JsonNullableFilter<"Shop">
    minimumPurchase?: IntNullableFilter<"Shop"> | number | null
    paymentMethods?: StringNullableListFilter<"Shop">
    plan?: StringFilter<"Shop"> | string
    status?: EnumShopStatusFilter<"Shop"> | $Enums.ShopStatus
    statusReason?: StringNullableFilter<"Shop"> | string | null
    statusChangedAt?: DateTimeNullableFilter<"Shop"> | Date | string | null
    agendaSuspendedUntil?: DateTimeNullableFilter<"Shop"> | Date | string | null
    agendaSuspendedByAdminId?: StringNullableFilter<"Shop"> | string | null
    agendaSuspendedReason?: StringNullableFilter<"Shop"> | string | null
    streamQuota?: IntFilter<"Shop"> | number
    reelQuota?: IntFilter<"Shop"> | number
    active?: BoolFilter<"Shop"> | boolean
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    authUser?: XOR<AuthUserNullableRelationFilter, AuthUserWhereInput> | null
    streams?: StreamListRelationFilter
    reels?: ReelListRelationFilter
    penalties?: PenaltyListRelationFilter
    socialHandles?: ShopSocialHandleListRelationFilter
    whatsappLines?: ShopWhatsappLineListRelationFilter
    favorites?: FavoriteListRelationFilter
    quotaWallet?: XOR<QuotaWalletNullableRelationFilter, QuotaWalletWhereInput> | null
    quotaTransactions?: QuotaTransactionListRelationFilter
    purchaseRequests?: PurchaseRequestListRelationFilter
  }

  export type ShopOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    authUserId?: SortOrderInput | SortOrder
    requiresEmailFix?: SortOrder
    razonSocial?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    addressDetails?: SortOrderInput | SortOrder
    minimumPurchase?: SortOrderInput | SortOrder
    paymentMethods?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    statusChangedAt?: SortOrderInput | SortOrder
    agendaSuspendedUntil?: SortOrderInput | SortOrder
    agendaSuspendedByAdminId?: SortOrderInput | SortOrder
    agendaSuspendedReason?: SortOrderInput | SortOrder
    streamQuota?: SortOrder
    reelQuota?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authUser?: AuthUserOrderByWithRelationInput
    streams?: StreamOrderByRelationAggregateInput
    reels?: ReelOrderByRelationAggregateInput
    penalties?: PenaltyOrderByRelationAggregateInput
    socialHandles?: ShopSocialHandleOrderByRelationAggregateInput
    whatsappLines?: ShopWhatsappLineOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    quotaWallet?: QuotaWalletOrderByWithRelationInput
    quotaTransactions?: QuotaTransactionOrderByRelationAggregateInput
    purchaseRequests?: PurchaseRequestOrderByRelationAggregateInput
  }

  export type ShopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    authUserId?: string
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    name?: StringFilter<"Shop"> | string
    logoUrl?: StringNullableFilter<"Shop"> | string | null
    website?: StringNullableFilter<"Shop"> | string | null
    requiresEmailFix?: BoolFilter<"Shop"> | boolean
    razonSocial?: StringNullableFilter<"Shop"> | string | null
    cuit?: StringNullableFilter<"Shop"> | string | null
    email?: StringNullableFilter<"Shop"> | string | null
    password?: StringNullableFilter<"Shop"> | string | null
    address?: StringNullableFilter<"Shop"> | string | null
    addressDetails?: JsonNullableFilter<"Shop">
    minimumPurchase?: IntNullableFilter<"Shop"> | number | null
    paymentMethods?: StringNullableListFilter<"Shop">
    plan?: StringFilter<"Shop"> | string
    status?: EnumShopStatusFilter<"Shop"> | $Enums.ShopStatus
    statusReason?: StringNullableFilter<"Shop"> | string | null
    statusChangedAt?: DateTimeNullableFilter<"Shop"> | Date | string | null
    agendaSuspendedUntil?: DateTimeNullableFilter<"Shop"> | Date | string | null
    agendaSuspendedByAdminId?: StringNullableFilter<"Shop"> | string | null
    agendaSuspendedReason?: StringNullableFilter<"Shop"> | string | null
    streamQuota?: IntFilter<"Shop"> | number
    reelQuota?: IntFilter<"Shop"> | number
    active?: BoolFilter<"Shop"> | boolean
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    authUser?: XOR<AuthUserNullableRelationFilter, AuthUserWhereInput> | null
    streams?: StreamListRelationFilter
    reels?: ReelListRelationFilter
    penalties?: PenaltyListRelationFilter
    socialHandles?: ShopSocialHandleListRelationFilter
    whatsappLines?: ShopWhatsappLineListRelationFilter
    favorites?: FavoriteListRelationFilter
    quotaWallet?: XOR<QuotaWalletNullableRelationFilter, QuotaWalletWhereInput> | null
    quotaTransactions?: QuotaTransactionListRelationFilter
    purchaseRequests?: PurchaseRequestListRelationFilter
  }, "id" | "slug" | "authUserId">

  export type ShopOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    authUserId?: SortOrderInput | SortOrder
    requiresEmailFix?: SortOrder
    razonSocial?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    addressDetails?: SortOrderInput | SortOrder
    minimumPurchase?: SortOrderInput | SortOrder
    paymentMethods?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    statusChangedAt?: SortOrderInput | SortOrder
    agendaSuspendedUntil?: SortOrderInput | SortOrder
    agendaSuspendedByAdminId?: SortOrderInput | SortOrder
    agendaSuspendedReason?: SortOrderInput | SortOrder
    streamQuota?: SortOrder
    reelQuota?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopCountOrderByAggregateInput
    _avg?: ShopAvgOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
    _sum?: ShopSumOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    OR?: ShopScalarWhereWithAggregatesInput[]
    NOT?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shop"> | string
    name?: StringWithAggregatesFilter<"Shop"> | string
    slug?: StringWithAggregatesFilter<"Shop"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    website?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    authUserId?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    requiresEmailFix?: BoolWithAggregatesFilter<"Shop"> | boolean
    razonSocial?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    cuit?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    email?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    password?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    address?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    addressDetails?: JsonNullableWithAggregatesFilter<"Shop">
    minimumPurchase?: IntNullableWithAggregatesFilter<"Shop"> | number | null
    paymentMethods?: StringNullableListFilter<"Shop">
    plan?: StringWithAggregatesFilter<"Shop"> | string
    status?: EnumShopStatusWithAggregatesFilter<"Shop"> | $Enums.ShopStatus
    statusReason?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    statusChangedAt?: DateTimeNullableWithAggregatesFilter<"Shop"> | Date | string | null
    agendaSuspendedUntil?: DateTimeNullableWithAggregatesFilter<"Shop"> | Date | string | null
    agendaSuspendedByAdminId?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    agendaSuspendedReason?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    streamQuota?: IntWithAggregatesFilter<"Shop"> | number
    reelQuota?: IntWithAggregatesFilter<"Shop"> | number
    active?: BoolWithAggregatesFilter<"Shop"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
  }

  export type StreamWhereInput = {
    AND?: StreamWhereInput | StreamWhereInput[]
    OR?: StreamWhereInput[]
    NOT?: StreamWhereInput | StreamWhereInput[]
    id?: StringFilter<"Stream"> | string
    shopId?: StringFilter<"Stream"> | string
    title?: StringFilter<"Stream"> | string
    description?: StringNullableFilter<"Stream"> | string | null
    status?: EnumStreamStatusFilter<"Stream"> | $Enums.StreamStatus
    scheduledAt?: DateTimeFilter<"Stream"> | Date | string
    scheduledEndPlanned?: DateTimeNullableFilter<"Stream"> | Date | string | null
    timezone?: StringFilter<"Stream"> | string
    startTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    durationMinutes?: IntNullableFilter<"Stream"> | number | null
    cancelledAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    cancelReason?: StringNullableFilter<"Stream"> | string | null
    hidden?: BoolFilter<"Stream"> | boolean
    visibilityReason?: StringNullableFilter<"Stream"> | string | null
    platform?: EnumSocialPlatformFilter<"Stream"> | $Enums.SocialPlatform
    url?: StringNullableFilter<"Stream"> | string | null
    extensionCount?: IntFilter<"Stream"> | number
    reportCount?: IntFilter<"Stream"> | number
    editCount?: IntFilter<"Stream"> | number
    lastEditedAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    originalScheduledAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    reprogrammedFromId?: StringNullableFilter<"Stream"> | string | null
    reprogramReason?: StringNullableFilter<"Stream"> | string | null
    pendingReprogramNote?: StringNullableFilter<"Stream"> | string | null
    reprogramBatchId?: StringNullableFilter<"Stream"> | string | null
    createdAt?: DateTimeFilter<"Stream"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    reports?: ReportListRelationFilter
    reviews?: ReviewListRelationFilter
    agenda?: AgendaListRelationFilter
  }

  export type StreamOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    scheduledEndPlanned?: SortOrderInput | SortOrder
    timezone?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    hidden?: SortOrder
    visibilityReason?: SortOrderInput | SortOrder
    platform?: SortOrder
    url?: SortOrderInput | SortOrder
    extensionCount?: SortOrder
    reportCount?: SortOrder
    editCount?: SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    originalScheduledAt?: SortOrderInput | SortOrder
    reprogrammedFromId?: SortOrderInput | SortOrder
    reprogramReason?: SortOrderInput | SortOrder
    pendingReprogramNote?: SortOrderInput | SortOrder
    reprogramBatchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    agenda?: AgendaOrderByRelationAggregateInput
  }

  export type StreamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StreamWhereInput | StreamWhereInput[]
    OR?: StreamWhereInput[]
    NOT?: StreamWhereInput | StreamWhereInput[]
    shopId?: StringFilter<"Stream"> | string
    title?: StringFilter<"Stream"> | string
    description?: StringNullableFilter<"Stream"> | string | null
    status?: EnumStreamStatusFilter<"Stream"> | $Enums.StreamStatus
    scheduledAt?: DateTimeFilter<"Stream"> | Date | string
    scheduledEndPlanned?: DateTimeNullableFilter<"Stream"> | Date | string | null
    timezone?: StringFilter<"Stream"> | string
    startTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    durationMinutes?: IntNullableFilter<"Stream"> | number | null
    cancelledAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    cancelReason?: StringNullableFilter<"Stream"> | string | null
    hidden?: BoolFilter<"Stream"> | boolean
    visibilityReason?: StringNullableFilter<"Stream"> | string | null
    platform?: EnumSocialPlatformFilter<"Stream"> | $Enums.SocialPlatform
    url?: StringNullableFilter<"Stream"> | string | null
    extensionCount?: IntFilter<"Stream"> | number
    reportCount?: IntFilter<"Stream"> | number
    editCount?: IntFilter<"Stream"> | number
    lastEditedAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    originalScheduledAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    reprogrammedFromId?: StringNullableFilter<"Stream"> | string | null
    reprogramReason?: StringNullableFilter<"Stream"> | string | null
    pendingReprogramNote?: StringNullableFilter<"Stream"> | string | null
    reprogramBatchId?: StringNullableFilter<"Stream"> | string | null
    createdAt?: DateTimeFilter<"Stream"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    reports?: ReportListRelationFilter
    reviews?: ReviewListRelationFilter
    agenda?: AgendaListRelationFilter
  }, "id">

  export type StreamOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    scheduledEndPlanned?: SortOrderInput | SortOrder
    timezone?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    hidden?: SortOrder
    visibilityReason?: SortOrderInput | SortOrder
    platform?: SortOrder
    url?: SortOrderInput | SortOrder
    extensionCount?: SortOrder
    reportCount?: SortOrder
    editCount?: SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    originalScheduledAt?: SortOrderInput | SortOrder
    reprogrammedFromId?: SortOrderInput | SortOrder
    reprogramReason?: SortOrderInput | SortOrder
    pendingReprogramNote?: SortOrderInput | SortOrder
    reprogramBatchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StreamCountOrderByAggregateInput
    _avg?: StreamAvgOrderByAggregateInput
    _max?: StreamMaxOrderByAggregateInput
    _min?: StreamMinOrderByAggregateInput
    _sum?: StreamSumOrderByAggregateInput
  }

  export type StreamScalarWhereWithAggregatesInput = {
    AND?: StreamScalarWhereWithAggregatesInput | StreamScalarWhereWithAggregatesInput[]
    OR?: StreamScalarWhereWithAggregatesInput[]
    NOT?: StreamScalarWhereWithAggregatesInput | StreamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stream"> | string
    shopId?: StringWithAggregatesFilter<"Stream"> | string
    title?: StringWithAggregatesFilter<"Stream"> | string
    description?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    status?: EnumStreamStatusWithAggregatesFilter<"Stream"> | $Enums.StreamStatus
    scheduledAt?: DateTimeWithAggregatesFilter<"Stream"> | Date | string
    scheduledEndPlanned?: DateTimeNullableWithAggregatesFilter<"Stream"> | Date | string | null
    timezone?: StringWithAggregatesFilter<"Stream"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"Stream"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Stream"> | Date | string | null
    durationMinutes?: IntNullableWithAggregatesFilter<"Stream"> | number | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Stream"> | Date | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    hidden?: BoolWithAggregatesFilter<"Stream"> | boolean
    visibilityReason?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    platform?: EnumSocialPlatformWithAggregatesFilter<"Stream"> | $Enums.SocialPlatform
    url?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    extensionCount?: IntWithAggregatesFilter<"Stream"> | number
    reportCount?: IntWithAggregatesFilter<"Stream"> | number
    editCount?: IntWithAggregatesFilter<"Stream"> | number
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"Stream"> | Date | string | null
    originalScheduledAt?: DateTimeNullableWithAggregatesFilter<"Stream"> | Date | string | null
    reprogrammedFromId?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    reprogramReason?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    pendingReprogramNote?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    reprogramBatchId?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Stream"> | Date | string
  }

  export type ReelWhereInput = {
    AND?: ReelWhereInput | ReelWhereInput[]
    OR?: ReelWhereInput[]
    NOT?: ReelWhereInput | ReelWhereInput[]
    id?: StringFilter<"Reel"> | string
    shopId?: StringFilter<"Reel"> | string
    url?: StringFilter<"Reel"> | string
    platform?: EnumSocialPlatformFilter<"Reel"> | $Enums.SocialPlatform
    hidden?: BoolFilter<"Reel"> | boolean
    views?: IntFilter<"Reel"> | number
    createdAt?: DateTimeFilter<"Reel"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type ReelOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    url?: SortOrder
    platform?: SortOrder
    hidden?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type ReelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReelWhereInput | ReelWhereInput[]
    OR?: ReelWhereInput[]
    NOT?: ReelWhereInput | ReelWhereInput[]
    shopId?: StringFilter<"Reel"> | string
    url?: StringFilter<"Reel"> | string
    platform?: EnumSocialPlatformFilter<"Reel"> | $Enums.SocialPlatform
    hidden?: BoolFilter<"Reel"> | boolean
    views?: IntFilter<"Reel"> | number
    createdAt?: DateTimeFilter<"Reel"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id">

  export type ReelOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    url?: SortOrder
    platform?: SortOrder
    hidden?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    _count?: ReelCountOrderByAggregateInput
    _avg?: ReelAvgOrderByAggregateInput
    _max?: ReelMaxOrderByAggregateInput
    _min?: ReelMinOrderByAggregateInput
    _sum?: ReelSumOrderByAggregateInput
  }

  export type ReelScalarWhereWithAggregatesInput = {
    AND?: ReelScalarWhereWithAggregatesInput | ReelScalarWhereWithAggregatesInput[]
    OR?: ReelScalarWhereWithAggregatesInput[]
    NOT?: ReelScalarWhereWithAggregatesInput | ReelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reel"> | string
    shopId?: StringWithAggregatesFilter<"Reel"> | string
    url?: StringWithAggregatesFilter<"Reel"> | string
    platform?: EnumSocialPlatformWithAggregatesFilter<"Reel"> | $Enums.SocialPlatform
    hidden?: BoolWithAggregatesFilter<"Reel"> | boolean
    views?: IntWithAggregatesFilter<"Reel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Reel"> | Date | string
  }

  export type ShopSocialHandleWhereInput = {
    AND?: ShopSocialHandleWhereInput | ShopSocialHandleWhereInput[]
    OR?: ShopSocialHandleWhereInput[]
    NOT?: ShopSocialHandleWhereInput | ShopSocialHandleWhereInput[]
    id?: StringFilter<"ShopSocialHandle"> | string
    shopId?: StringFilter<"ShopSocialHandle"> | string
    platform?: EnumSocialPlatformFilter<"ShopSocialHandle"> | $Enums.SocialPlatform
    handle?: StringFilter<"ShopSocialHandle"> | string
    createdAt?: DateTimeFilter<"ShopSocialHandle"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type ShopSocialHandleOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type ShopSocialHandleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shopId_platform?: ShopSocialHandleShopIdPlatformCompoundUniqueInput
    AND?: ShopSocialHandleWhereInput | ShopSocialHandleWhereInput[]
    OR?: ShopSocialHandleWhereInput[]
    NOT?: ShopSocialHandleWhereInput | ShopSocialHandleWhereInput[]
    shopId?: StringFilter<"ShopSocialHandle"> | string
    platform?: EnumSocialPlatformFilter<"ShopSocialHandle"> | $Enums.SocialPlatform
    handle?: StringFilter<"ShopSocialHandle"> | string
    createdAt?: DateTimeFilter<"ShopSocialHandle"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id" | "shopId_platform">

  export type ShopSocialHandleOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
    _count?: ShopSocialHandleCountOrderByAggregateInput
    _max?: ShopSocialHandleMaxOrderByAggregateInput
    _min?: ShopSocialHandleMinOrderByAggregateInput
  }

  export type ShopSocialHandleScalarWhereWithAggregatesInput = {
    AND?: ShopSocialHandleScalarWhereWithAggregatesInput | ShopSocialHandleScalarWhereWithAggregatesInput[]
    OR?: ShopSocialHandleScalarWhereWithAggregatesInput[]
    NOT?: ShopSocialHandleScalarWhereWithAggregatesInput | ShopSocialHandleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopSocialHandle"> | string
    shopId?: StringWithAggregatesFilter<"ShopSocialHandle"> | string
    platform?: EnumSocialPlatformWithAggregatesFilter<"ShopSocialHandle"> | $Enums.SocialPlatform
    handle?: StringWithAggregatesFilter<"ShopSocialHandle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ShopSocialHandle"> | Date | string
  }

  export type ShopWhatsappLineWhereInput = {
    AND?: ShopWhatsappLineWhereInput | ShopWhatsappLineWhereInput[]
    OR?: ShopWhatsappLineWhereInput[]
    NOT?: ShopWhatsappLineWhereInput | ShopWhatsappLineWhereInput[]
    id?: StringFilter<"ShopWhatsappLine"> | string
    shopId?: StringFilter<"ShopWhatsappLine"> | string
    label?: StringFilter<"ShopWhatsappLine"> | string
    number?: StringFilter<"ShopWhatsappLine"> | string
    createdAt?: DateTimeFilter<"ShopWhatsappLine"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type ShopWhatsappLineOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    label?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type ShopWhatsappLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopWhatsappLineWhereInput | ShopWhatsappLineWhereInput[]
    OR?: ShopWhatsappLineWhereInput[]
    NOT?: ShopWhatsappLineWhereInput | ShopWhatsappLineWhereInput[]
    shopId?: StringFilter<"ShopWhatsappLine"> | string
    label?: StringFilter<"ShopWhatsappLine"> | string
    number?: StringFilter<"ShopWhatsappLine"> | string
    createdAt?: DateTimeFilter<"ShopWhatsappLine"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id">

  export type ShopWhatsappLineOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    label?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
    _count?: ShopWhatsappLineCountOrderByAggregateInput
    _max?: ShopWhatsappLineMaxOrderByAggregateInput
    _min?: ShopWhatsappLineMinOrderByAggregateInput
  }

  export type ShopWhatsappLineScalarWhereWithAggregatesInput = {
    AND?: ShopWhatsappLineScalarWhereWithAggregatesInput | ShopWhatsappLineScalarWhereWithAggregatesInput[]
    OR?: ShopWhatsappLineScalarWhereWithAggregatesInput[]
    NOT?: ShopWhatsappLineScalarWhereWithAggregatesInput | ShopWhatsappLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopWhatsappLine"> | string
    shopId?: StringWithAggregatesFilter<"ShopWhatsappLine"> | string
    label?: StringWithAggregatesFilter<"ShopWhatsappLine"> | string
    number?: StringWithAggregatesFilter<"ShopWhatsappLine"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ShopWhatsappLine"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    streamId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    stream?: XOR<StreamRelationFilter, StreamWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    streamId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    stream?: StreamOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    streamId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    stream?: XOR<StreamRelationFilter, StreamWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    streamId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    streamId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    streamId?: StringFilter<"Report"> | string
    userId?: StringNullableFilter<"Report"> | string | null
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    resolved?: BoolFilter<"Report"> | boolean
    createdAt?: DateTimeFilter<"Report"> | Date | string
    stream?: XOR<StreamRelationFilter, StreamWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    streamId?: SortOrder
    userId?: SortOrderInput | SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    stream?: StreamOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    streamId?: StringFilter<"Report"> | string
    userId?: StringNullableFilter<"Report"> | string | null
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    resolved?: BoolFilter<"Report"> | boolean
    createdAt?: DateTimeFilter<"Report"> | Date | string
    stream?: XOR<StreamRelationFilter, StreamWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    streamId?: SortOrder
    userId?: SortOrderInput | SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    streamId?: StringWithAggregatesFilter<"Report"> | string
    userId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reason?: StringWithAggregatesFilter<"Report"> | string
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    resolved?: BoolWithAggregatesFilter<"Report"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type PenaltyWhereInput = {
    AND?: PenaltyWhereInput | PenaltyWhereInput[]
    OR?: PenaltyWhereInput[]
    NOT?: PenaltyWhereInput | PenaltyWhereInput[]
    id?: StringFilter<"Penalty"> | string
    shopId?: StringFilter<"Penalty"> | string
    reason?: StringFilter<"Penalty"> | string
    active?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type PenaltyOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    reason?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type PenaltyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PenaltyWhereInput | PenaltyWhereInput[]
    OR?: PenaltyWhereInput[]
    NOT?: PenaltyWhereInput | PenaltyWhereInput[]
    shopId?: StringFilter<"Penalty"> | string
    reason?: StringFilter<"Penalty"> | string
    active?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id">

  export type PenaltyOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    reason?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    _count?: PenaltyCountOrderByAggregateInput
    _max?: PenaltyMaxOrderByAggregateInput
    _min?: PenaltyMinOrderByAggregateInput
  }

  export type PenaltyScalarWhereWithAggregatesInput = {
    AND?: PenaltyScalarWhereWithAggregatesInput | PenaltyScalarWhereWithAggregatesInput[]
    OR?: PenaltyScalarWhereWithAggregatesInput[]
    NOT?: PenaltyScalarWhereWithAggregatesInput | PenaltyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Penalty"> | string
    shopId?: StringWithAggregatesFilter<"Penalty"> | string
    reason?: StringWithAggregatesFilter<"Penalty"> | string
    active?: BoolWithAggregatesFilter<"Penalty"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    shopId?: StringFilter<"Favorite"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    shopId?: SortOrder
    user?: UserOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userId?: StringFilter<"Favorite"> | string
    shopId?: StringFilter<"Favorite"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    shopId?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Favorite"> | string
    userId?: StringWithAggregatesFilter<"Favorite"> | string
    shopId?: StringWithAggregatesFilter<"Favorite"> | string
  }

  export type AgendaWhereInput = {
    AND?: AgendaWhereInput | AgendaWhereInput[]
    OR?: AgendaWhereInput[]
    NOT?: AgendaWhereInput | AgendaWhereInput[]
    id?: StringFilter<"Agenda"> | string
    userId?: StringFilter<"Agenda"> | string
    streamId?: StringFilter<"Agenda"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    stream?: XOR<StreamRelationFilter, StreamWhereInput>
  }

  export type AgendaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    streamId?: SortOrder
    user?: UserOrderByWithRelationInput
    stream?: StreamOrderByWithRelationInput
  }

  export type AgendaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgendaWhereInput | AgendaWhereInput[]
    OR?: AgendaWhereInput[]
    NOT?: AgendaWhereInput | AgendaWhereInput[]
    userId?: StringFilter<"Agenda"> | string
    streamId?: StringFilter<"Agenda"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    stream?: XOR<StreamRelationFilter, StreamWhereInput>
  }, "id">

  export type AgendaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    streamId?: SortOrder
    _count?: AgendaCountOrderByAggregateInput
    _max?: AgendaMaxOrderByAggregateInput
    _min?: AgendaMinOrderByAggregateInput
  }

  export type AgendaScalarWhereWithAggregatesInput = {
    AND?: AgendaScalarWhereWithAggregatesInput | AgendaScalarWhereWithAggregatesInput[]
    OR?: AgendaScalarWhereWithAggregatesInput[]
    NOT?: AgendaScalarWhereWithAggregatesInput | AgendaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agenda"> | string
    userId?: StringWithAggregatesFilter<"Agenda"> | string
    streamId?: StringWithAggregatesFilter<"Agenda"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type QuotaWalletWhereInput = {
    AND?: QuotaWalletWhereInput | QuotaWalletWhereInput[]
    OR?: QuotaWalletWhereInput[]
    NOT?: QuotaWalletWhereInput | QuotaWalletWhereInput[]
    shopId?: StringFilter<"QuotaWallet"> | string
    weeklyLiveBaseLimit?: IntFilter<"QuotaWallet"> | number
    weeklyLiveUsed?: IntFilter<"QuotaWallet"> | number
    weeklyLiveWeekKey?: StringFilter<"QuotaWallet"> | string
    liveExtraBalance?: IntFilter<"QuotaWallet"> | number
    reelDailyLimit?: IntFilter<"QuotaWallet"> | number
    reelDailyUsed?: IntFilter<"QuotaWallet"> | number
    reelDailyDateKey?: StringFilter<"QuotaWallet"> | string
    reelExtraBalance?: IntFilter<"QuotaWallet"> | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type QuotaWalletOrderByWithRelationInput = {
    shopId?: SortOrder
    weeklyLiveBaseLimit?: SortOrder
    weeklyLiveUsed?: SortOrder
    weeklyLiveWeekKey?: SortOrder
    liveExtraBalance?: SortOrder
    reelDailyLimit?: SortOrder
    reelDailyUsed?: SortOrder
    reelDailyDateKey?: SortOrder
    reelExtraBalance?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type QuotaWalletWhereUniqueInput = Prisma.AtLeast<{
    shopId?: string
    AND?: QuotaWalletWhereInput | QuotaWalletWhereInput[]
    OR?: QuotaWalletWhereInput[]
    NOT?: QuotaWalletWhereInput | QuotaWalletWhereInput[]
    weeklyLiveBaseLimit?: IntFilter<"QuotaWallet"> | number
    weeklyLiveUsed?: IntFilter<"QuotaWallet"> | number
    weeklyLiveWeekKey?: StringFilter<"QuotaWallet"> | string
    liveExtraBalance?: IntFilter<"QuotaWallet"> | number
    reelDailyLimit?: IntFilter<"QuotaWallet"> | number
    reelDailyUsed?: IntFilter<"QuotaWallet"> | number
    reelDailyDateKey?: StringFilter<"QuotaWallet"> | string
    reelExtraBalance?: IntFilter<"QuotaWallet"> | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "shopId">

  export type QuotaWalletOrderByWithAggregationInput = {
    shopId?: SortOrder
    weeklyLiveBaseLimit?: SortOrder
    weeklyLiveUsed?: SortOrder
    weeklyLiveWeekKey?: SortOrder
    liveExtraBalance?: SortOrder
    reelDailyLimit?: SortOrder
    reelDailyUsed?: SortOrder
    reelDailyDateKey?: SortOrder
    reelExtraBalance?: SortOrder
    _count?: QuotaWalletCountOrderByAggregateInput
    _avg?: QuotaWalletAvgOrderByAggregateInput
    _max?: QuotaWalletMaxOrderByAggregateInput
    _min?: QuotaWalletMinOrderByAggregateInput
    _sum?: QuotaWalletSumOrderByAggregateInput
  }

  export type QuotaWalletScalarWhereWithAggregatesInput = {
    AND?: QuotaWalletScalarWhereWithAggregatesInput | QuotaWalletScalarWhereWithAggregatesInput[]
    OR?: QuotaWalletScalarWhereWithAggregatesInput[]
    NOT?: QuotaWalletScalarWhereWithAggregatesInput | QuotaWalletScalarWhereWithAggregatesInput[]
    shopId?: StringWithAggregatesFilter<"QuotaWallet"> | string
    weeklyLiveBaseLimit?: IntWithAggregatesFilter<"QuotaWallet"> | number
    weeklyLiveUsed?: IntWithAggregatesFilter<"QuotaWallet"> | number
    weeklyLiveWeekKey?: StringWithAggregatesFilter<"QuotaWallet"> | string
    liveExtraBalance?: IntWithAggregatesFilter<"QuotaWallet"> | number
    reelDailyLimit?: IntWithAggregatesFilter<"QuotaWallet"> | number
    reelDailyUsed?: IntWithAggregatesFilter<"QuotaWallet"> | number
    reelDailyDateKey?: StringWithAggregatesFilter<"QuotaWallet"> | string
    reelExtraBalance?: IntWithAggregatesFilter<"QuotaWallet"> | number
  }

  export type QuotaTransactionWhereInput = {
    AND?: QuotaTransactionWhereInput | QuotaTransactionWhereInput[]
    OR?: QuotaTransactionWhereInput[]
    NOT?: QuotaTransactionWhereInput | QuotaTransactionWhereInput[]
    txnId?: StringFilter<"QuotaTransaction"> | string
    shopId?: StringFilter<"QuotaTransaction"> | string
    resource?: EnumQuotaResourceFilter<"QuotaTransaction"> | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFilter<"QuotaTransaction"> | $Enums.QuotaDirection
    amount?: IntFilter<"QuotaTransaction"> | number
    reason?: EnumQuotaReasonFilter<"QuotaTransaction"> | $Enums.QuotaReason
    refType?: EnumQuotaRefTypeNullableFilter<"QuotaTransaction"> | $Enums.QuotaRefType | null
    refId?: StringNullableFilter<"QuotaTransaction"> | string | null
    actorType?: EnumQuotaActorTypeFilter<"QuotaTransaction"> | $Enums.QuotaActorType
    actorId?: StringNullableFilter<"QuotaTransaction"> | string | null
    createdAt?: DateTimeFilter<"QuotaTransaction"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type QuotaTransactionOrderByWithRelationInput = {
    txnId?: SortOrder
    shopId?: SortOrder
    resource?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    actorType?: SortOrder
    actorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type QuotaTransactionWhereUniqueInput = Prisma.AtLeast<{
    txnId?: string
    AND?: QuotaTransactionWhereInput | QuotaTransactionWhereInput[]
    OR?: QuotaTransactionWhereInput[]
    NOT?: QuotaTransactionWhereInput | QuotaTransactionWhereInput[]
    shopId?: StringFilter<"QuotaTransaction"> | string
    resource?: EnumQuotaResourceFilter<"QuotaTransaction"> | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFilter<"QuotaTransaction"> | $Enums.QuotaDirection
    amount?: IntFilter<"QuotaTransaction"> | number
    reason?: EnumQuotaReasonFilter<"QuotaTransaction"> | $Enums.QuotaReason
    refType?: EnumQuotaRefTypeNullableFilter<"QuotaTransaction"> | $Enums.QuotaRefType | null
    refId?: StringNullableFilter<"QuotaTransaction"> | string | null
    actorType?: EnumQuotaActorTypeFilter<"QuotaTransaction"> | $Enums.QuotaActorType
    actorId?: StringNullableFilter<"QuotaTransaction"> | string | null
    createdAt?: DateTimeFilter<"QuotaTransaction"> | Date | string
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "txnId">

  export type QuotaTransactionOrderByWithAggregationInput = {
    txnId?: SortOrder
    shopId?: SortOrder
    resource?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    actorType?: SortOrder
    actorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuotaTransactionCountOrderByAggregateInput
    _avg?: QuotaTransactionAvgOrderByAggregateInput
    _max?: QuotaTransactionMaxOrderByAggregateInput
    _min?: QuotaTransactionMinOrderByAggregateInput
    _sum?: QuotaTransactionSumOrderByAggregateInput
  }

  export type QuotaTransactionScalarWhereWithAggregatesInput = {
    AND?: QuotaTransactionScalarWhereWithAggregatesInput | QuotaTransactionScalarWhereWithAggregatesInput[]
    OR?: QuotaTransactionScalarWhereWithAggregatesInput[]
    NOT?: QuotaTransactionScalarWhereWithAggregatesInput | QuotaTransactionScalarWhereWithAggregatesInput[]
    txnId?: StringWithAggregatesFilter<"QuotaTransaction"> | string
    shopId?: StringWithAggregatesFilter<"QuotaTransaction"> | string
    resource?: EnumQuotaResourceWithAggregatesFilter<"QuotaTransaction"> | $Enums.QuotaResource
    direction?: EnumQuotaDirectionWithAggregatesFilter<"QuotaTransaction"> | $Enums.QuotaDirection
    amount?: IntWithAggregatesFilter<"QuotaTransaction"> | number
    reason?: EnumQuotaReasonWithAggregatesFilter<"QuotaTransaction"> | $Enums.QuotaReason
    refType?: EnumQuotaRefTypeNullableWithAggregatesFilter<"QuotaTransaction"> | $Enums.QuotaRefType | null
    refId?: StringNullableWithAggregatesFilter<"QuotaTransaction"> | string | null
    actorType?: EnumQuotaActorTypeWithAggregatesFilter<"QuotaTransaction"> | $Enums.QuotaActorType
    actorId?: StringNullableWithAggregatesFilter<"QuotaTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuotaTransaction"> | Date | string
  }

  export type PurchaseRequestWhereInput = {
    AND?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    OR?: PurchaseRequestWhereInput[]
    NOT?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    purchaseId?: StringFilter<"PurchaseRequest"> | string
    shopId?: StringFilter<"PurchaseRequest"> | string
    type?: EnumPurchaseTypeFilter<"PurchaseRequest"> | $Enums.PurchaseType
    quantity?: IntFilter<"PurchaseRequest"> | number
    status?: EnumPurchaseStatusFilter<"PurchaseRequest"> | $Enums.PurchaseStatus
    createdAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    approvedAt?: DateTimeNullableFilter<"PurchaseRequest"> | Date | string | null
    approvedByAdminId?: StringNullableFilter<"PurchaseRequest"> | string | null
    paymentProofUrl?: StringNullableFilter<"PurchaseRequest"> | string | null
    notes?: StringNullableFilter<"PurchaseRequest"> | string | null
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    approvedByAdmin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }

  export type PurchaseRequestOrderByWithRelationInput = {
    purchaseId?: SortOrder
    shopId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedByAdminId?: SortOrderInput | SortOrder
    paymentProofUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    shop?: ShopOrderByWithRelationInput
    approvedByAdmin?: AdminOrderByWithRelationInput
  }

  export type PurchaseRequestWhereUniqueInput = Prisma.AtLeast<{
    purchaseId?: string
    AND?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    OR?: PurchaseRequestWhereInput[]
    NOT?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    shopId?: StringFilter<"PurchaseRequest"> | string
    type?: EnumPurchaseTypeFilter<"PurchaseRequest"> | $Enums.PurchaseType
    quantity?: IntFilter<"PurchaseRequest"> | number
    status?: EnumPurchaseStatusFilter<"PurchaseRequest"> | $Enums.PurchaseStatus
    createdAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    approvedAt?: DateTimeNullableFilter<"PurchaseRequest"> | Date | string | null
    approvedByAdminId?: StringNullableFilter<"PurchaseRequest"> | string | null
    paymentProofUrl?: StringNullableFilter<"PurchaseRequest"> | string | null
    notes?: StringNullableFilter<"PurchaseRequest"> | string | null
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
    approvedByAdmin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }, "purchaseId">

  export type PurchaseRequestOrderByWithAggregationInput = {
    purchaseId?: SortOrder
    shopId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedByAdminId?: SortOrderInput | SortOrder
    paymentProofUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: PurchaseRequestCountOrderByAggregateInput
    _avg?: PurchaseRequestAvgOrderByAggregateInput
    _max?: PurchaseRequestMaxOrderByAggregateInput
    _min?: PurchaseRequestMinOrderByAggregateInput
    _sum?: PurchaseRequestSumOrderByAggregateInput
  }

  export type PurchaseRequestScalarWhereWithAggregatesInput = {
    AND?: PurchaseRequestScalarWhereWithAggregatesInput | PurchaseRequestScalarWhereWithAggregatesInput[]
    OR?: PurchaseRequestScalarWhereWithAggregatesInput[]
    NOT?: PurchaseRequestScalarWhereWithAggregatesInput | PurchaseRequestScalarWhereWithAggregatesInput[]
    purchaseId?: StringWithAggregatesFilter<"PurchaseRequest"> | string
    shopId?: StringWithAggregatesFilter<"PurchaseRequest"> | string
    type?: EnumPurchaseTypeWithAggregatesFilter<"PurchaseRequest"> | $Enums.PurchaseType
    quantity?: IntWithAggregatesFilter<"PurchaseRequest"> | number
    status?: EnumPurchaseStatusWithAggregatesFilter<"PurchaseRequest"> | $Enums.PurchaseStatus
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseRequest"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseRequest"> | Date | string | null
    approvedByAdminId?: StringNullableWithAggregatesFilter<"PurchaseRequest"> | string | null
    paymentProofUrl?: StringNullableWithAggregatesFilter<"PurchaseRequest"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PurchaseRequest"> | string | null
  }

  export type AuthUserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    shop?: ShopCreateNestedOneWithoutAuthUserInput
    admin?: AdminCreateNestedOneWithoutAuthUserInput
    client?: ClientCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    shop?: ShopUncheckedCreateNestedOneWithoutAuthUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutAuthUserInput
    client?: ClientUncheckedCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUpdateOneWithoutAuthUserNestedInput
    admin?: AdminUpdateOneWithoutAuthUserNestedInput
    client?: ClientUpdateOneWithoutAuthUserNestedInput
  }

  export type AuthUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUncheckedUpdateOneWithoutAuthUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutAuthUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutAuthUserNestedInput
  }

  export type AuthUserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type AuthUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuthUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateInput = {
    role?: $Enums.AdminRole
    adminStatus?: $Enums.AdminStatus
    createdAt?: Date | string
    authUser: AuthUserCreateNestedOneWithoutAdminInput
    approvedPurchaseRequests?: PurchaseRequestCreateNestedManyWithoutApprovedByAdminInput
  }

  export type AdminUncheckedCreateInput = {
    authUserId: string
    role?: $Enums.AdminRole
    adminStatus?: $Enums.AdminStatus
    createdAt?: Date | string
    approvedPurchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutApprovedByAdminInput
  }

  export type AdminUpdateInput = {
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneRequiredWithoutAdminNestedInput
    approvedPurchaseRequests?: PurchaseRequestUpdateManyWithoutApprovedByAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    authUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedPurchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutApprovedByAdminNestedInput
  }

  export type AdminCreateManyInput = {
    authUserId: string
    role?: $Enums.AdminRole
    adminStatus?: $Enums.AdminStatus
    createdAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    authUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    displayName?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    authUser: AuthUserCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    authUserId: string
    displayName?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
  }

  export type ClientUpdateInput = {
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneRequiredWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    authUserId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateManyInput = {
    authUserId: string
    displayName?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    authUserId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    agenda?: AgendaCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    agenda?: AgendaUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    agenda?: AgendaUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    agenda?: AgendaUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopCreateInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateManyInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutStreamsInput
    reports?: ReportCreateNestedManyWithoutStreamInput
    reviews?: ReviewCreateNestedManyWithoutStreamInput
    agenda?: AgendaCreateNestedManyWithoutStreamInput
  }

  export type StreamUncheckedCreateInput = {
    id?: string
    shopId: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutStreamInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutStreamInput
    agenda?: AgendaUncheckedCreateNestedManyWithoutStreamInput
  }

  export type StreamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutStreamsNestedInput
    reports?: ReportUpdateManyWithoutStreamNestedInput
    reviews?: ReviewUpdateManyWithoutStreamNestedInput
    agenda?: AgendaUpdateManyWithoutStreamNestedInput
  }

  export type StreamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutStreamNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutStreamNestedInput
    agenda?: AgendaUncheckedUpdateManyWithoutStreamNestedInput
  }

  export type StreamCreateManyInput = {
    id?: string
    shopId: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
  }

  export type StreamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReelCreateInput = {
    id?: string
    url: string
    platform?: $Enums.SocialPlatform
    hidden?: boolean
    views?: number
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutReelsInput
  }

  export type ReelUncheckedCreateInput = {
    id?: string
    shopId: string
    url: string
    platform?: $Enums.SocialPlatform
    hidden?: boolean
    views?: number
    createdAt?: Date | string
  }

  export type ReelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    hidden?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutReelsNestedInput
  }

  export type ReelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    hidden?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReelCreateManyInput = {
    id?: string
    shopId: string
    url: string
    platform?: $Enums.SocialPlatform
    hidden?: boolean
    views?: number
    createdAt?: Date | string
  }

  export type ReelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    hidden?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    hidden?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopSocialHandleCreateInput = {
    id?: string
    platform: $Enums.SocialPlatform
    handle: string
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutSocialHandlesInput
  }

  export type ShopSocialHandleUncheckedCreateInput = {
    id?: string
    shopId: string
    platform: $Enums.SocialPlatform
    handle: string
    createdAt?: Date | string
  }

  export type ShopSocialHandleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutSocialHandlesNestedInput
  }

  export type ShopSocialHandleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopSocialHandleCreateManyInput = {
    id?: string
    shopId: string
    platform: $Enums.SocialPlatform
    handle: string
    createdAt?: Date | string
  }

  export type ShopSocialHandleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopSocialHandleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopWhatsappLineCreateInput = {
    id?: string
    label: string
    number: string
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutWhatsappLinesInput
  }

  export type ShopWhatsappLineUncheckedCreateInput = {
    id?: string
    shopId: string
    label: string
    number: string
    createdAt?: Date | string
  }

  export type ShopWhatsappLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutWhatsappLinesNestedInput
  }

  export type ShopWhatsappLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopWhatsappLineCreateManyInput = {
    id?: string
    shopId: string
    label: string
    number: string
    createdAt?: Date | string
  }

  export type ShopWhatsappLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopWhatsappLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    stream: StreamCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    streamId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stream?: StreamUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    streamId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    userId?: string | null
    reason: string
    status?: $Enums.ReportStatus
    resolved?: boolean
    createdAt?: Date | string
    stream: StreamCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    streamId: string
    userId?: string | null
    reason: string
    status?: $Enums.ReportStatus
    resolved?: boolean
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stream?: StreamUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    streamId: string
    userId?: string | null
    reason: string
    status?: $Enums.ReportStatus
    resolved?: boolean
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateInput = {
    id?: string
    reason: string
    active?: boolean
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutPenaltiesInput
  }

  export type PenaltyUncheckedCreateInput = {
    id?: string
    shopId: string
    reason: string
    active?: boolean
    createdAt?: Date | string
  }

  export type PenaltyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutPenaltiesNestedInput
  }

  export type PenaltyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateManyInput = {
    id?: string
    shopId: string
    reason: string
    active?: boolean
    createdAt?: Date | string
  }

  export type PenaltyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutFavoritesInput
    shop: ShopCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    userId: string
    shopId: string
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    shop?: ShopUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteCreateManyInput = {
    id?: string
    userId: string
    shopId: string
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutAgendaInput
    stream: StreamCreateNestedOneWithoutAgendaInput
  }

  export type AgendaUncheckedCreateInput = {
    id?: string
    userId: string
    streamId: string
  }

  export type AgendaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAgendaNestedInput
    stream?: StreamUpdateOneRequiredWithoutAgendaNestedInput
  }

  export type AgendaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    streamId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaCreateManyInput = {
    id?: string
    userId: string
    streamId: string
  }

  export type AgendaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    streamId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    message: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotaWalletCreateInput = {
    weeklyLiveBaseLimit: number
    weeklyLiveUsed: number
    weeklyLiveWeekKey: string
    liveExtraBalance: number
    reelDailyLimit: number
    reelDailyUsed: number
    reelDailyDateKey: string
    reelExtraBalance: number
    shop: ShopCreateNestedOneWithoutQuotaWalletInput
  }

  export type QuotaWalletUncheckedCreateInput = {
    shopId: string
    weeklyLiveBaseLimit: number
    weeklyLiveUsed: number
    weeklyLiveWeekKey: string
    liveExtraBalance: number
    reelDailyLimit: number
    reelDailyUsed: number
    reelDailyDateKey: string
    reelExtraBalance: number
  }

  export type QuotaWalletUpdateInput = {
    weeklyLiveBaseLimit?: IntFieldUpdateOperationsInput | number
    weeklyLiveUsed?: IntFieldUpdateOperationsInput | number
    weeklyLiveWeekKey?: StringFieldUpdateOperationsInput | string
    liveExtraBalance?: IntFieldUpdateOperationsInput | number
    reelDailyLimit?: IntFieldUpdateOperationsInput | number
    reelDailyUsed?: IntFieldUpdateOperationsInput | number
    reelDailyDateKey?: StringFieldUpdateOperationsInput | string
    reelExtraBalance?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutQuotaWalletNestedInput
  }

  export type QuotaWalletUncheckedUpdateInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    weeklyLiveBaseLimit?: IntFieldUpdateOperationsInput | number
    weeklyLiveUsed?: IntFieldUpdateOperationsInput | number
    weeklyLiveWeekKey?: StringFieldUpdateOperationsInput | string
    liveExtraBalance?: IntFieldUpdateOperationsInput | number
    reelDailyLimit?: IntFieldUpdateOperationsInput | number
    reelDailyUsed?: IntFieldUpdateOperationsInput | number
    reelDailyDateKey?: StringFieldUpdateOperationsInput | string
    reelExtraBalance?: IntFieldUpdateOperationsInput | number
  }

  export type QuotaWalletCreateManyInput = {
    shopId: string
    weeklyLiveBaseLimit: number
    weeklyLiveUsed: number
    weeklyLiveWeekKey: string
    liveExtraBalance: number
    reelDailyLimit: number
    reelDailyUsed: number
    reelDailyDateKey: string
    reelExtraBalance: number
  }

  export type QuotaWalletUpdateManyMutationInput = {
    weeklyLiveBaseLimit?: IntFieldUpdateOperationsInput | number
    weeklyLiveUsed?: IntFieldUpdateOperationsInput | number
    weeklyLiveWeekKey?: StringFieldUpdateOperationsInput | string
    liveExtraBalance?: IntFieldUpdateOperationsInput | number
    reelDailyLimit?: IntFieldUpdateOperationsInput | number
    reelDailyUsed?: IntFieldUpdateOperationsInput | number
    reelDailyDateKey?: StringFieldUpdateOperationsInput | string
    reelExtraBalance?: IntFieldUpdateOperationsInput | number
  }

  export type QuotaWalletUncheckedUpdateManyInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    weeklyLiveBaseLimit?: IntFieldUpdateOperationsInput | number
    weeklyLiveUsed?: IntFieldUpdateOperationsInput | number
    weeklyLiveWeekKey?: StringFieldUpdateOperationsInput | string
    liveExtraBalance?: IntFieldUpdateOperationsInput | number
    reelDailyLimit?: IntFieldUpdateOperationsInput | number
    reelDailyUsed?: IntFieldUpdateOperationsInput | number
    reelDailyDateKey?: StringFieldUpdateOperationsInput | string
    reelExtraBalance?: IntFieldUpdateOperationsInput | number
  }

  export type QuotaTransactionCreateInput = {
    txnId?: string
    resource: $Enums.QuotaResource
    direction: $Enums.QuotaDirection
    amount: number
    reason: $Enums.QuotaReason
    refType?: $Enums.QuotaRefType | null
    refId?: string | null
    actorType: $Enums.QuotaActorType
    actorId?: string | null
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutQuotaTransactionsInput
  }

  export type QuotaTransactionUncheckedCreateInput = {
    txnId?: string
    shopId: string
    resource: $Enums.QuotaResource
    direction: $Enums.QuotaDirection
    amount: number
    reason: $Enums.QuotaReason
    refType?: $Enums.QuotaRefType | null
    refId?: string | null
    actorType: $Enums.QuotaActorType
    actorId?: string | null
    createdAt?: Date | string
  }

  export type QuotaTransactionUpdateInput = {
    txnId?: StringFieldUpdateOperationsInput | string
    resource?: EnumQuotaResourceFieldUpdateOperationsInput | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFieldUpdateOperationsInput | $Enums.QuotaDirection
    amount?: IntFieldUpdateOperationsInput | number
    reason?: EnumQuotaReasonFieldUpdateOperationsInput | $Enums.QuotaReason
    refType?: NullableEnumQuotaRefTypeFieldUpdateOperationsInput | $Enums.QuotaRefType | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumQuotaActorTypeFieldUpdateOperationsInput | $Enums.QuotaActorType
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutQuotaTransactionsNestedInput
  }

  export type QuotaTransactionUncheckedUpdateInput = {
    txnId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    resource?: EnumQuotaResourceFieldUpdateOperationsInput | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFieldUpdateOperationsInput | $Enums.QuotaDirection
    amount?: IntFieldUpdateOperationsInput | number
    reason?: EnumQuotaReasonFieldUpdateOperationsInput | $Enums.QuotaReason
    refType?: NullableEnumQuotaRefTypeFieldUpdateOperationsInput | $Enums.QuotaRefType | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumQuotaActorTypeFieldUpdateOperationsInput | $Enums.QuotaActorType
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotaTransactionCreateManyInput = {
    txnId?: string
    shopId: string
    resource: $Enums.QuotaResource
    direction: $Enums.QuotaDirection
    amount: number
    reason: $Enums.QuotaReason
    refType?: $Enums.QuotaRefType | null
    refId?: string | null
    actorType: $Enums.QuotaActorType
    actorId?: string | null
    createdAt?: Date | string
  }

  export type QuotaTransactionUpdateManyMutationInput = {
    txnId?: StringFieldUpdateOperationsInput | string
    resource?: EnumQuotaResourceFieldUpdateOperationsInput | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFieldUpdateOperationsInput | $Enums.QuotaDirection
    amount?: IntFieldUpdateOperationsInput | number
    reason?: EnumQuotaReasonFieldUpdateOperationsInput | $Enums.QuotaReason
    refType?: NullableEnumQuotaRefTypeFieldUpdateOperationsInput | $Enums.QuotaRefType | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumQuotaActorTypeFieldUpdateOperationsInput | $Enums.QuotaActorType
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotaTransactionUncheckedUpdateManyInput = {
    txnId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    resource?: EnumQuotaResourceFieldUpdateOperationsInput | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFieldUpdateOperationsInput | $Enums.QuotaDirection
    amount?: IntFieldUpdateOperationsInput | number
    reason?: EnumQuotaReasonFieldUpdateOperationsInput | $Enums.QuotaReason
    refType?: NullableEnumQuotaRefTypeFieldUpdateOperationsInput | $Enums.QuotaRefType | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumQuotaActorTypeFieldUpdateOperationsInput | $Enums.QuotaActorType
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestCreateInput = {
    purchaseId?: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    paymentProofUrl?: string | null
    notes?: string | null
    shop: ShopCreateNestedOneWithoutPurchaseRequestsInput
    approvedByAdmin?: AdminCreateNestedOneWithoutApprovedPurchaseRequestsInput
  }

  export type PurchaseRequestUncheckedCreateInput = {
    purchaseId?: string
    shopId: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedByAdminId?: string | null
    paymentProofUrl?: string | null
    notes?: string | null
  }

  export type PurchaseRequestUpdateInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shop?: ShopUpdateOneRequiredWithoutPurchaseRequestsNestedInput
    approvedByAdmin?: AdminUpdateOneWithoutApprovedPurchaseRequestsNestedInput
  }

  export type PurchaseRequestUncheckedUpdateInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseRequestCreateManyInput = {
    purchaseId?: string
    shopId: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedByAdminId?: string | null
    paymentProofUrl?: string | null
    notes?: string | null
  }

  export type PurchaseRequestUpdateManyMutationInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseRequestUncheckedUpdateManyInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAuthUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthUserType | EnumAuthUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthUserType[] | ListEnumAuthUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthUserType[] | ListEnumAuthUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthUserTypeFilter<$PrismaModel> | $Enums.AuthUserType
  }

  export type EnumAuthUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthUserStatus | EnumAuthUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuthUserStatus[] | ListEnumAuthUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthUserStatus[] | ListEnumAuthUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthUserStatusFilter<$PrismaModel> | $Enums.AuthUserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ShopNullableRelationFilter = {
    is?: ShopWhereInput | null
    isNot?: ShopWhereInput | null
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuthUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type AuthUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type AuthUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAuthUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthUserType | EnumAuthUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthUserType[] | ListEnumAuthUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthUserType[] | ListEnumAuthUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthUserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthUserTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthUserTypeFilter<$PrismaModel>
  }

  export type EnumAuthUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthUserStatus | EnumAuthUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuthUserStatus[] | ListEnumAuthUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthUserStatus[] | ListEnumAuthUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuthUserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthUserStatusFilter<$PrismaModel>
    _max?: NestedEnumAuthUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type EnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type AuthUserRelationFilter = {
    is?: AuthUserWhereInput
    isNot?: AuthUserWhereInput
  }

  export type PurchaseRequestListRelationFilter = {
    every?: PurchaseRequestWhereInput
    some?: PurchaseRequestWhereInput
    none?: PurchaseRequestWhereInput
  }

  export type PurchaseRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    authUserId?: SortOrder
    role?: SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    authUserId?: SortOrder
    role?: SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    authUserId?: SortOrder
    role?: SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type EnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type ClientCountOrderByAggregateInput = {
    authUserId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    authUserId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    authUserId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type AgendaListRelationFilter = {
    every?: AgendaWhereInput
    some?: AgendaWhereInput
    none?: AgendaWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgendaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumShopStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopStatus | EnumShopStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShopStatus[] | ListEnumShopStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopStatus[] | ListEnumShopStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShopStatusFilter<$PrismaModel> | $Enums.ShopStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AuthUserNullableRelationFilter = {
    is?: AuthUserWhereInput | null
    isNot?: AuthUserWhereInput | null
  }

  export type StreamListRelationFilter = {
    every?: StreamWhereInput
    some?: StreamWhereInput
    none?: StreamWhereInput
  }

  export type ReelListRelationFilter = {
    every?: ReelWhereInput
    some?: ReelWhereInput
    none?: ReelWhereInput
  }

  export type PenaltyListRelationFilter = {
    every?: PenaltyWhereInput
    some?: PenaltyWhereInput
    none?: PenaltyWhereInput
  }

  export type ShopSocialHandleListRelationFilter = {
    every?: ShopSocialHandleWhereInput
    some?: ShopSocialHandleWhereInput
    none?: ShopSocialHandleWhereInput
  }

  export type ShopWhatsappLineListRelationFilter = {
    every?: ShopWhatsappLineWhereInput
    some?: ShopWhatsappLineWhereInput
    none?: ShopWhatsappLineWhereInput
  }

  export type QuotaWalletNullableRelationFilter = {
    is?: QuotaWalletWhereInput | null
    isNot?: QuotaWalletWhereInput | null
  }

  export type QuotaTransactionListRelationFilter = {
    every?: QuotaTransactionWhereInput
    some?: QuotaTransactionWhereInput
    none?: QuotaTransactionWhereInput
  }

  export type StreamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PenaltyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopSocialHandleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopWhatsappLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotaTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    authUserId?: SortOrder
    requiresEmailFix?: SortOrder
    razonSocial?: SortOrder
    cuit?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    addressDetails?: SortOrder
    minimumPurchase?: SortOrder
    paymentMethods?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    statusChangedAt?: SortOrder
    agendaSuspendedUntil?: SortOrder
    agendaSuspendedByAdminId?: SortOrder
    agendaSuspendedReason?: SortOrder
    streamQuota?: SortOrder
    reelQuota?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopAvgOrderByAggregateInput = {
    minimumPurchase?: SortOrder
    streamQuota?: SortOrder
    reelQuota?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    authUserId?: SortOrder
    requiresEmailFix?: SortOrder
    razonSocial?: SortOrder
    cuit?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    minimumPurchase?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    statusChangedAt?: SortOrder
    agendaSuspendedUntil?: SortOrder
    agendaSuspendedByAdminId?: SortOrder
    agendaSuspendedReason?: SortOrder
    streamQuota?: SortOrder
    reelQuota?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    authUserId?: SortOrder
    requiresEmailFix?: SortOrder
    razonSocial?: SortOrder
    cuit?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    minimumPurchase?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    statusChangedAt?: SortOrder
    agendaSuspendedUntil?: SortOrder
    agendaSuspendedByAdminId?: SortOrder
    agendaSuspendedReason?: SortOrder
    streamQuota?: SortOrder
    reelQuota?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopSumOrderByAggregateInput = {
    minimumPurchase?: SortOrder
    streamQuota?: SortOrder
    reelQuota?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumShopStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopStatus | EnumShopStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShopStatus[] | ListEnumShopStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopStatus[] | ListEnumShopStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShopStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShopStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShopStatusFilter<$PrismaModel>
    _max?: NestedEnumShopStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumStreamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StreamStatus | EnumStreamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStreamStatusFilter<$PrismaModel> | $Enums.StreamStatus
  }

  export type EnumSocialPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformFilter<$PrismaModel> | $Enums.SocialPlatform
  }

  export type ShopRelationFilter = {
    is?: ShopWhereInput
    isNot?: ShopWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StreamCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    scheduledEndPlanned?: SortOrder
    timezone?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    durationMinutes?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    hidden?: SortOrder
    visibilityReason?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    extensionCount?: SortOrder
    reportCount?: SortOrder
    editCount?: SortOrder
    lastEditedAt?: SortOrder
    originalScheduledAt?: SortOrder
    reprogrammedFromId?: SortOrder
    reprogramReason?: SortOrder
    pendingReprogramNote?: SortOrder
    reprogramBatchId?: SortOrder
    createdAt?: SortOrder
  }

  export type StreamAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
    extensionCount?: SortOrder
    reportCount?: SortOrder
    editCount?: SortOrder
  }

  export type StreamMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    scheduledEndPlanned?: SortOrder
    timezone?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    durationMinutes?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    hidden?: SortOrder
    visibilityReason?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    extensionCount?: SortOrder
    reportCount?: SortOrder
    editCount?: SortOrder
    lastEditedAt?: SortOrder
    originalScheduledAt?: SortOrder
    reprogrammedFromId?: SortOrder
    reprogramReason?: SortOrder
    pendingReprogramNote?: SortOrder
    reprogramBatchId?: SortOrder
    createdAt?: SortOrder
  }

  export type StreamMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    scheduledEndPlanned?: SortOrder
    timezone?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    durationMinutes?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    hidden?: SortOrder
    visibilityReason?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    extensionCount?: SortOrder
    reportCount?: SortOrder
    editCount?: SortOrder
    lastEditedAt?: SortOrder
    originalScheduledAt?: SortOrder
    reprogrammedFromId?: SortOrder
    reprogramReason?: SortOrder
    pendingReprogramNote?: SortOrder
    reprogramBatchId?: SortOrder
    createdAt?: SortOrder
  }

  export type StreamSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
    extensionCount?: SortOrder
    reportCount?: SortOrder
    editCount?: SortOrder
  }

  export type EnumStreamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StreamStatus | EnumStreamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStreamStatusWithAggregatesFilter<$PrismaModel> | $Enums.StreamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStreamStatusFilter<$PrismaModel>
    _max?: NestedEnumStreamStatusFilter<$PrismaModel>
  }

  export type EnumSocialPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel> | $Enums.SocialPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialPlatformFilter<$PrismaModel>
    _max?: NestedEnumSocialPlatformFilter<$PrismaModel>
  }

  export type ReelCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    url?: SortOrder
    platform?: SortOrder
    hidden?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
  }

  export type ReelAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type ReelMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    url?: SortOrder
    platform?: SortOrder
    hidden?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
  }

  export type ReelMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    url?: SortOrder
    platform?: SortOrder
    hidden?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
  }

  export type ReelSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type ShopSocialHandleShopIdPlatformCompoundUniqueInput = {
    shopId: string
    platform: $Enums.SocialPlatform
  }

  export type ShopSocialHandleCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
  }

  export type ShopSocialHandleMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
  }

  export type ShopSocialHandleMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
  }

  export type ShopWhatsappLineCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    label?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
  }

  export type ShopWhatsappLineMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    label?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
  }

  export type ShopWhatsappLineMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    label?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
  }

  export type StreamRelationFilter = {
    is?: StreamWhereInput
    isNot?: StreamWhereInput
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    streamId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    streamId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    streamId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    streamId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    streamId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    streamId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type PenaltyCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    reason?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type PenaltyMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    reason?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type PenaltyMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    reason?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    shopId?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    shopId?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    shopId?: SortOrder
  }

  export type AgendaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    streamId?: SortOrder
  }

  export type AgendaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    streamId?: SortOrder
  }

  export type AgendaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    streamId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotaWalletCountOrderByAggregateInput = {
    shopId?: SortOrder
    weeklyLiveBaseLimit?: SortOrder
    weeklyLiveUsed?: SortOrder
    weeklyLiveWeekKey?: SortOrder
    liveExtraBalance?: SortOrder
    reelDailyLimit?: SortOrder
    reelDailyUsed?: SortOrder
    reelDailyDateKey?: SortOrder
    reelExtraBalance?: SortOrder
  }

  export type QuotaWalletAvgOrderByAggregateInput = {
    weeklyLiveBaseLimit?: SortOrder
    weeklyLiveUsed?: SortOrder
    liveExtraBalance?: SortOrder
    reelDailyLimit?: SortOrder
    reelDailyUsed?: SortOrder
    reelExtraBalance?: SortOrder
  }

  export type QuotaWalletMaxOrderByAggregateInput = {
    shopId?: SortOrder
    weeklyLiveBaseLimit?: SortOrder
    weeklyLiveUsed?: SortOrder
    weeklyLiveWeekKey?: SortOrder
    liveExtraBalance?: SortOrder
    reelDailyLimit?: SortOrder
    reelDailyUsed?: SortOrder
    reelDailyDateKey?: SortOrder
    reelExtraBalance?: SortOrder
  }

  export type QuotaWalletMinOrderByAggregateInput = {
    shopId?: SortOrder
    weeklyLiveBaseLimit?: SortOrder
    weeklyLiveUsed?: SortOrder
    weeklyLiveWeekKey?: SortOrder
    liveExtraBalance?: SortOrder
    reelDailyLimit?: SortOrder
    reelDailyUsed?: SortOrder
    reelDailyDateKey?: SortOrder
    reelExtraBalance?: SortOrder
  }

  export type QuotaWalletSumOrderByAggregateInput = {
    weeklyLiveBaseLimit?: SortOrder
    weeklyLiveUsed?: SortOrder
    liveExtraBalance?: SortOrder
    reelDailyLimit?: SortOrder
    reelDailyUsed?: SortOrder
    reelExtraBalance?: SortOrder
  }

  export type EnumQuotaResourceFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaResource | EnumQuotaResourceFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaResource[] | ListEnumQuotaResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaResource[] | ListEnumQuotaResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaResourceFilter<$PrismaModel> | $Enums.QuotaResource
  }

  export type EnumQuotaDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaDirection | EnumQuotaDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaDirection[] | ListEnumQuotaDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaDirection[] | ListEnumQuotaDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaDirectionFilter<$PrismaModel> | $Enums.QuotaDirection
  }

  export type EnumQuotaReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaReason | EnumQuotaReasonFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaReason[] | ListEnumQuotaReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaReason[] | ListEnumQuotaReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaReasonFilter<$PrismaModel> | $Enums.QuotaReason
  }

  export type EnumQuotaRefTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaRefType | EnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.QuotaRefType[] | ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QuotaRefType[] | ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQuotaRefTypeNullableFilter<$PrismaModel> | $Enums.QuotaRefType | null
  }

  export type EnumQuotaActorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaActorType | EnumQuotaActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaActorType[] | ListEnumQuotaActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaActorType[] | ListEnumQuotaActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaActorTypeFilter<$PrismaModel> | $Enums.QuotaActorType
  }

  export type QuotaTransactionCountOrderByAggregateInput = {
    txnId?: SortOrder
    shopId?: SortOrder
    resource?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotaTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type QuotaTransactionMaxOrderByAggregateInput = {
    txnId?: SortOrder
    shopId?: SortOrder
    resource?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotaTransactionMinOrderByAggregateInput = {
    txnId?: SortOrder
    shopId?: SortOrder
    resource?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    actorType?: SortOrder
    actorId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotaTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumQuotaResourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaResource | EnumQuotaResourceFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaResource[] | ListEnumQuotaResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaResource[] | ListEnumQuotaResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaResourceWithAggregatesFilter<$PrismaModel> | $Enums.QuotaResource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotaResourceFilter<$PrismaModel>
    _max?: NestedEnumQuotaResourceFilter<$PrismaModel>
  }

  export type EnumQuotaDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaDirection | EnumQuotaDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaDirection[] | ListEnumQuotaDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaDirection[] | ListEnumQuotaDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaDirectionWithAggregatesFilter<$PrismaModel> | $Enums.QuotaDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotaDirectionFilter<$PrismaModel>
    _max?: NestedEnumQuotaDirectionFilter<$PrismaModel>
  }

  export type EnumQuotaReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaReason | EnumQuotaReasonFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaReason[] | ListEnumQuotaReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaReason[] | ListEnumQuotaReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaReasonWithAggregatesFilter<$PrismaModel> | $Enums.QuotaReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotaReasonFilter<$PrismaModel>
    _max?: NestedEnumQuotaReasonFilter<$PrismaModel>
  }

  export type EnumQuotaRefTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaRefType | EnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.QuotaRefType[] | ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QuotaRefType[] | ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQuotaRefTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.QuotaRefType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumQuotaRefTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumQuotaRefTypeNullableFilter<$PrismaModel>
  }

  export type EnumQuotaActorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaActorType | EnumQuotaActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaActorType[] | ListEnumQuotaActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaActorType[] | ListEnumQuotaActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaActorTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuotaActorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotaActorTypeFilter<$PrismaModel>
    _max?: NestedEnumQuotaActorTypeFilter<$PrismaModel>
  }

  export type EnumPurchaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseType | EnumPurchaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseTypeFilter<$PrismaModel> | $Enums.PurchaseType
  }

  export type EnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type PurchaseRequestCountOrderByAggregateInput = {
    purchaseId?: SortOrder
    shopId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    approvedByAdminId?: SortOrder
    paymentProofUrl?: SortOrder
    notes?: SortOrder
  }

  export type PurchaseRequestAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PurchaseRequestMaxOrderByAggregateInput = {
    purchaseId?: SortOrder
    shopId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    approvedByAdminId?: SortOrder
    paymentProofUrl?: SortOrder
    notes?: SortOrder
  }

  export type PurchaseRequestMinOrderByAggregateInput = {
    purchaseId?: SortOrder
    shopId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    approvedByAdminId?: SortOrder
    paymentProofUrl?: SortOrder
    notes?: SortOrder
  }

  export type PurchaseRequestSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumPurchaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseType | EnumPurchaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseTypeFilter<$PrismaModel>
    _max?: NestedEnumPurchaseTypeFilter<$PrismaModel>
  }

  export type EnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type ShopCreateNestedOneWithoutAuthUserInput = {
    create?: XOR<ShopCreateWithoutAuthUserInput, ShopUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAuthUserInput
    connect?: ShopWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutAuthUserInput = {
    create?: XOR<AdminCreateWithoutAuthUserInput, AdminUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAuthUserInput = {
    create?: XOR<ClientCreateWithoutAuthUserInput, ClientUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAuthUserInput
    connect?: ClientWhereUniqueInput
  }

  export type ShopUncheckedCreateNestedOneWithoutAuthUserInput = {
    create?: XOR<ShopCreateWithoutAuthUserInput, ShopUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAuthUserInput
    connect?: ShopWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutAuthUserInput = {
    create?: XOR<AdminCreateWithoutAuthUserInput, AdminUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutAuthUserInput = {
    create?: XOR<ClientCreateWithoutAuthUserInput, ClientUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAuthUserInput
    connect?: ClientWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAuthUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuthUserType
  }

  export type EnumAuthUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuthUserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ShopUpdateOneWithoutAuthUserNestedInput = {
    create?: XOR<ShopCreateWithoutAuthUserInput, ShopUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAuthUserInput
    upsert?: ShopUpsertWithoutAuthUserInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutAuthUserInput, ShopUpdateWithoutAuthUserInput>, ShopUncheckedUpdateWithoutAuthUserInput>
  }

  export type AdminUpdateOneWithoutAuthUserNestedInput = {
    create?: XOR<AdminCreateWithoutAuthUserInput, AdminUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthUserInput
    upsert?: AdminUpsertWithoutAuthUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAuthUserInput, AdminUpdateWithoutAuthUserInput>, AdminUncheckedUpdateWithoutAuthUserInput>
  }

  export type ClientUpdateOneWithoutAuthUserNestedInput = {
    create?: XOR<ClientCreateWithoutAuthUserInput, ClientUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAuthUserInput
    upsert?: ClientUpsertWithoutAuthUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAuthUserInput, ClientUpdateWithoutAuthUserInput>, ClientUncheckedUpdateWithoutAuthUserInput>
  }

  export type ShopUncheckedUpdateOneWithoutAuthUserNestedInput = {
    create?: XOR<ShopCreateWithoutAuthUserInput, ShopUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAuthUserInput
    upsert?: ShopUpsertWithoutAuthUserInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutAuthUserInput, ShopUpdateWithoutAuthUserInput>, ShopUncheckedUpdateWithoutAuthUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutAuthUserNestedInput = {
    create?: XOR<AdminCreateWithoutAuthUserInput, AdminUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthUserInput
    upsert?: AdminUpsertWithoutAuthUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAuthUserInput, AdminUpdateWithoutAuthUserInput>, AdminUncheckedUpdateWithoutAuthUserInput>
  }

  export type ClientUncheckedUpdateOneWithoutAuthUserNestedInput = {
    create?: XOR<ClientCreateWithoutAuthUserInput, ClientUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAuthUserInput
    upsert?: ClientUpsertWithoutAuthUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAuthUserInput, ClientUpdateWithoutAuthUserInput>, ClientUncheckedUpdateWithoutAuthUserInput>
  }

  export type AuthUserCreateNestedOneWithoutAdminInput = {
    create?: XOR<AuthUserCreateWithoutAdminInput, AuthUserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutAdminInput
    connect?: AuthUserWhereUniqueInput
  }

  export type PurchaseRequestCreateNestedManyWithoutApprovedByAdminInput = {
    create?: XOR<PurchaseRequestCreateWithoutApprovedByAdminInput, PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput> | PurchaseRequestCreateWithoutApprovedByAdminInput[] | PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput | PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput[]
    createMany?: PurchaseRequestCreateManyApprovedByAdminInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type PurchaseRequestUncheckedCreateNestedManyWithoutApprovedByAdminInput = {
    create?: XOR<PurchaseRequestCreateWithoutApprovedByAdminInput, PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput> | PurchaseRequestCreateWithoutApprovedByAdminInput[] | PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput | PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput[]
    createMany?: PurchaseRequestCreateManyApprovedByAdminInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type EnumAdminRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdminRole
  }

  export type EnumAdminStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdminStatus
  }

  export type AuthUserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<AuthUserCreateWithoutAdminInput, AuthUserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutAdminInput
    upsert?: AuthUserUpsertWithoutAdminInput
    connect?: AuthUserWhereUniqueInput
    update?: XOR<XOR<AuthUserUpdateToOneWithWhereWithoutAdminInput, AuthUserUpdateWithoutAdminInput>, AuthUserUncheckedUpdateWithoutAdminInput>
  }

  export type PurchaseRequestUpdateManyWithoutApprovedByAdminNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutApprovedByAdminInput, PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput> | PurchaseRequestCreateWithoutApprovedByAdminInput[] | PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput | PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutApprovedByAdminInput | PurchaseRequestUpsertWithWhereUniqueWithoutApprovedByAdminInput[]
    createMany?: PurchaseRequestCreateManyApprovedByAdminInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutApprovedByAdminInput | PurchaseRequestUpdateWithWhereUniqueWithoutApprovedByAdminInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutApprovedByAdminInput | PurchaseRequestUpdateManyWithWhereWithoutApprovedByAdminInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutApprovedByAdminNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutApprovedByAdminInput, PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput> | PurchaseRequestCreateWithoutApprovedByAdminInput[] | PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput | PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutApprovedByAdminInput | PurchaseRequestUpsertWithWhereUniqueWithoutApprovedByAdminInput[]
    createMany?: PurchaseRequestCreateManyApprovedByAdminInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutApprovedByAdminInput | PurchaseRequestUpdateWithWhereUniqueWithoutApprovedByAdminInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutApprovedByAdminInput | PurchaseRequestUpdateManyWithWhereWithoutApprovedByAdminInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type AuthUserCreateNestedOneWithoutClientInput = {
    create?: XOR<AuthUserCreateWithoutClientInput, AuthUserUncheckedCreateWithoutClientInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutClientInput
    connect?: AuthUserWhereUniqueInput
  }

  export type AuthUserUpdateOneRequiredWithoutClientNestedInput = {
    create?: XOR<AuthUserCreateWithoutClientInput, AuthUserUncheckedCreateWithoutClientInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutClientInput
    upsert?: AuthUserUpsertWithoutClientInput
    connect?: AuthUserWhereUniqueInput
    update?: XOR<XOR<AuthUserUpdateToOneWithWhereWithoutClientInput, AuthUserUpdateWithoutClientInput>, AuthUserUncheckedUpdateWithoutClientInput>
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type AgendaCreateNestedManyWithoutUserInput = {
    create?: XOR<AgendaCreateWithoutUserInput, AgendaUncheckedCreateWithoutUserInput> | AgendaCreateWithoutUserInput[] | AgendaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgendaCreateOrConnectWithoutUserInput | AgendaCreateOrConnectWithoutUserInput[]
    createMany?: AgendaCreateManyUserInputEnvelope
    connect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type AgendaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AgendaCreateWithoutUserInput, AgendaUncheckedCreateWithoutUserInput> | AgendaCreateWithoutUserInput[] | AgendaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgendaCreateOrConnectWithoutUserInput | AgendaCreateOrConnectWithoutUserInput[]
    createMany?: AgendaCreateManyUserInputEnvelope
    connect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type AgendaUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgendaCreateWithoutUserInput, AgendaUncheckedCreateWithoutUserInput> | AgendaCreateWithoutUserInput[] | AgendaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgendaCreateOrConnectWithoutUserInput | AgendaCreateOrConnectWithoutUserInput[]
    upsert?: AgendaUpsertWithWhereUniqueWithoutUserInput | AgendaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgendaCreateManyUserInputEnvelope
    set?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    disconnect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    delete?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    connect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    update?: AgendaUpdateWithWhereUniqueWithoutUserInput | AgendaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgendaUpdateManyWithWhereWithoutUserInput | AgendaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgendaScalarWhereInput | AgendaScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type AgendaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgendaCreateWithoutUserInput, AgendaUncheckedCreateWithoutUserInput> | AgendaCreateWithoutUserInput[] | AgendaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgendaCreateOrConnectWithoutUserInput | AgendaCreateOrConnectWithoutUserInput[]
    upsert?: AgendaUpsertWithWhereUniqueWithoutUserInput | AgendaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgendaCreateManyUserInputEnvelope
    set?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    disconnect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    delete?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    connect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    update?: AgendaUpdateWithWhereUniqueWithoutUserInput | AgendaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgendaUpdateManyWithWhereWithoutUserInput | AgendaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgendaScalarWhereInput | AgendaScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ShopCreatepaymentMethodsInput = {
    set: string[]
  }

  export type AuthUserCreateNestedOneWithoutShopInput = {
    create?: XOR<AuthUserCreateWithoutShopInput, AuthUserUncheckedCreateWithoutShopInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutShopInput
    connect?: AuthUserWhereUniqueInput
  }

  export type StreamCreateNestedManyWithoutShopInput = {
    create?: XOR<StreamCreateWithoutShopInput, StreamUncheckedCreateWithoutShopInput> | StreamCreateWithoutShopInput[] | StreamUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StreamCreateOrConnectWithoutShopInput | StreamCreateOrConnectWithoutShopInput[]
    createMany?: StreamCreateManyShopInputEnvelope
    connect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
  }

  export type ReelCreateNestedManyWithoutShopInput = {
    create?: XOR<ReelCreateWithoutShopInput, ReelUncheckedCreateWithoutShopInput> | ReelCreateWithoutShopInput[] | ReelUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ReelCreateOrConnectWithoutShopInput | ReelCreateOrConnectWithoutShopInput[]
    createMany?: ReelCreateManyShopInputEnvelope
    connect?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
  }

  export type PenaltyCreateNestedManyWithoutShopInput = {
    create?: XOR<PenaltyCreateWithoutShopInput, PenaltyUncheckedCreateWithoutShopInput> | PenaltyCreateWithoutShopInput[] | PenaltyUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutShopInput | PenaltyCreateOrConnectWithoutShopInput[]
    createMany?: PenaltyCreateManyShopInputEnvelope
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
  }

  export type ShopSocialHandleCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopSocialHandleCreateWithoutShopInput, ShopSocialHandleUncheckedCreateWithoutShopInput> | ShopSocialHandleCreateWithoutShopInput[] | ShopSocialHandleUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopSocialHandleCreateOrConnectWithoutShopInput | ShopSocialHandleCreateOrConnectWithoutShopInput[]
    createMany?: ShopSocialHandleCreateManyShopInputEnvelope
    connect?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
  }

  export type ShopWhatsappLineCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopWhatsappLineCreateWithoutShopInput, ShopWhatsappLineUncheckedCreateWithoutShopInput> | ShopWhatsappLineCreateWithoutShopInput[] | ShopWhatsappLineUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopWhatsappLineCreateOrConnectWithoutShopInput | ShopWhatsappLineCreateOrConnectWithoutShopInput[]
    createMany?: ShopWhatsappLineCreateManyShopInputEnvelope
    connect?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutShopInput = {
    create?: XOR<FavoriteCreateWithoutShopInput, FavoriteUncheckedCreateWithoutShopInput> | FavoriteCreateWithoutShopInput[] | FavoriteUncheckedCreateWithoutShopInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutShopInput | FavoriteCreateOrConnectWithoutShopInput[]
    createMany?: FavoriteCreateManyShopInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type QuotaWalletCreateNestedOneWithoutShopInput = {
    create?: XOR<QuotaWalletCreateWithoutShopInput, QuotaWalletUncheckedCreateWithoutShopInput>
    connectOrCreate?: QuotaWalletCreateOrConnectWithoutShopInput
    connect?: QuotaWalletWhereUniqueInput
  }

  export type QuotaTransactionCreateNestedManyWithoutShopInput = {
    create?: XOR<QuotaTransactionCreateWithoutShopInput, QuotaTransactionUncheckedCreateWithoutShopInput> | QuotaTransactionCreateWithoutShopInput[] | QuotaTransactionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: QuotaTransactionCreateOrConnectWithoutShopInput | QuotaTransactionCreateOrConnectWithoutShopInput[]
    createMany?: QuotaTransactionCreateManyShopInputEnvelope
    connect?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
  }

  export type PurchaseRequestCreateNestedManyWithoutShopInput = {
    create?: XOR<PurchaseRequestCreateWithoutShopInput, PurchaseRequestUncheckedCreateWithoutShopInput> | PurchaseRequestCreateWithoutShopInput[] | PurchaseRequestUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutShopInput | PurchaseRequestCreateOrConnectWithoutShopInput[]
    createMany?: PurchaseRequestCreateManyShopInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type StreamUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<StreamCreateWithoutShopInput, StreamUncheckedCreateWithoutShopInput> | StreamCreateWithoutShopInput[] | StreamUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StreamCreateOrConnectWithoutShopInput | StreamCreateOrConnectWithoutShopInput[]
    createMany?: StreamCreateManyShopInputEnvelope
    connect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
  }

  export type ReelUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ReelCreateWithoutShopInput, ReelUncheckedCreateWithoutShopInput> | ReelCreateWithoutShopInput[] | ReelUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ReelCreateOrConnectWithoutShopInput | ReelCreateOrConnectWithoutShopInput[]
    createMany?: ReelCreateManyShopInputEnvelope
    connect?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
  }

  export type PenaltyUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<PenaltyCreateWithoutShopInput, PenaltyUncheckedCreateWithoutShopInput> | PenaltyCreateWithoutShopInput[] | PenaltyUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutShopInput | PenaltyCreateOrConnectWithoutShopInput[]
    createMany?: PenaltyCreateManyShopInputEnvelope
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
  }

  export type ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopSocialHandleCreateWithoutShopInput, ShopSocialHandleUncheckedCreateWithoutShopInput> | ShopSocialHandleCreateWithoutShopInput[] | ShopSocialHandleUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopSocialHandleCreateOrConnectWithoutShopInput | ShopSocialHandleCreateOrConnectWithoutShopInput[]
    createMany?: ShopSocialHandleCreateManyShopInputEnvelope
    connect?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
  }

  export type ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopWhatsappLineCreateWithoutShopInput, ShopWhatsappLineUncheckedCreateWithoutShopInput> | ShopWhatsappLineCreateWithoutShopInput[] | ShopWhatsappLineUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopWhatsappLineCreateOrConnectWithoutShopInput | ShopWhatsappLineCreateOrConnectWithoutShopInput[]
    createMany?: ShopWhatsappLineCreateManyShopInputEnvelope
    connect?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<FavoriteCreateWithoutShopInput, FavoriteUncheckedCreateWithoutShopInput> | FavoriteCreateWithoutShopInput[] | FavoriteUncheckedCreateWithoutShopInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutShopInput | FavoriteCreateOrConnectWithoutShopInput[]
    createMany?: FavoriteCreateManyShopInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type QuotaWalletUncheckedCreateNestedOneWithoutShopInput = {
    create?: XOR<QuotaWalletCreateWithoutShopInput, QuotaWalletUncheckedCreateWithoutShopInput>
    connectOrCreate?: QuotaWalletCreateOrConnectWithoutShopInput
    connect?: QuotaWalletWhereUniqueInput
  }

  export type QuotaTransactionUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<QuotaTransactionCreateWithoutShopInput, QuotaTransactionUncheckedCreateWithoutShopInput> | QuotaTransactionCreateWithoutShopInput[] | QuotaTransactionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: QuotaTransactionCreateOrConnectWithoutShopInput | QuotaTransactionCreateOrConnectWithoutShopInput[]
    createMany?: QuotaTransactionCreateManyShopInputEnvelope
    connect?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
  }

  export type PurchaseRequestUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<PurchaseRequestCreateWithoutShopInput, PurchaseRequestUncheckedCreateWithoutShopInput> | PurchaseRequestCreateWithoutShopInput[] | PurchaseRequestUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutShopInput | PurchaseRequestCreateOrConnectWithoutShopInput[]
    createMany?: PurchaseRequestCreateManyShopInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ShopUpdatepaymentMethodsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumShopStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShopStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuthUserUpdateOneWithoutShopNestedInput = {
    create?: XOR<AuthUserCreateWithoutShopInput, AuthUserUncheckedCreateWithoutShopInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutShopInput
    upsert?: AuthUserUpsertWithoutShopInput
    disconnect?: AuthUserWhereInput | boolean
    delete?: AuthUserWhereInput | boolean
    connect?: AuthUserWhereUniqueInput
    update?: XOR<XOR<AuthUserUpdateToOneWithWhereWithoutShopInput, AuthUserUpdateWithoutShopInput>, AuthUserUncheckedUpdateWithoutShopInput>
  }

  export type StreamUpdateManyWithoutShopNestedInput = {
    create?: XOR<StreamCreateWithoutShopInput, StreamUncheckedCreateWithoutShopInput> | StreamCreateWithoutShopInput[] | StreamUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StreamCreateOrConnectWithoutShopInput | StreamCreateOrConnectWithoutShopInput[]
    upsert?: StreamUpsertWithWhereUniqueWithoutShopInput | StreamUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: StreamCreateManyShopInputEnvelope
    set?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    disconnect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    delete?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    connect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    update?: StreamUpdateWithWhereUniqueWithoutShopInput | StreamUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: StreamUpdateManyWithWhereWithoutShopInput | StreamUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: StreamScalarWhereInput | StreamScalarWhereInput[]
  }

  export type ReelUpdateManyWithoutShopNestedInput = {
    create?: XOR<ReelCreateWithoutShopInput, ReelUncheckedCreateWithoutShopInput> | ReelCreateWithoutShopInput[] | ReelUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ReelCreateOrConnectWithoutShopInput | ReelCreateOrConnectWithoutShopInput[]
    upsert?: ReelUpsertWithWhereUniqueWithoutShopInput | ReelUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ReelCreateManyShopInputEnvelope
    set?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
    disconnect?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
    delete?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
    connect?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
    update?: ReelUpdateWithWhereUniqueWithoutShopInput | ReelUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ReelUpdateManyWithWhereWithoutShopInput | ReelUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ReelScalarWhereInput | ReelScalarWhereInput[]
  }

  export type PenaltyUpdateManyWithoutShopNestedInput = {
    create?: XOR<PenaltyCreateWithoutShopInput, PenaltyUncheckedCreateWithoutShopInput> | PenaltyCreateWithoutShopInput[] | PenaltyUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutShopInput | PenaltyCreateOrConnectWithoutShopInput[]
    upsert?: PenaltyUpsertWithWhereUniqueWithoutShopInput | PenaltyUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: PenaltyCreateManyShopInputEnvelope
    set?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    disconnect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    delete?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    update?: PenaltyUpdateWithWhereUniqueWithoutShopInput | PenaltyUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: PenaltyUpdateManyWithWhereWithoutShopInput | PenaltyUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
  }

  export type ShopSocialHandleUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopSocialHandleCreateWithoutShopInput, ShopSocialHandleUncheckedCreateWithoutShopInput> | ShopSocialHandleCreateWithoutShopInput[] | ShopSocialHandleUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopSocialHandleCreateOrConnectWithoutShopInput | ShopSocialHandleCreateOrConnectWithoutShopInput[]
    upsert?: ShopSocialHandleUpsertWithWhereUniqueWithoutShopInput | ShopSocialHandleUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopSocialHandleCreateManyShopInputEnvelope
    set?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
    disconnect?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
    delete?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
    connect?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
    update?: ShopSocialHandleUpdateWithWhereUniqueWithoutShopInput | ShopSocialHandleUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopSocialHandleUpdateManyWithWhereWithoutShopInput | ShopSocialHandleUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopSocialHandleScalarWhereInput | ShopSocialHandleScalarWhereInput[]
  }

  export type ShopWhatsappLineUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopWhatsappLineCreateWithoutShopInput, ShopWhatsappLineUncheckedCreateWithoutShopInput> | ShopWhatsappLineCreateWithoutShopInput[] | ShopWhatsappLineUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopWhatsappLineCreateOrConnectWithoutShopInput | ShopWhatsappLineCreateOrConnectWithoutShopInput[]
    upsert?: ShopWhatsappLineUpsertWithWhereUniqueWithoutShopInput | ShopWhatsappLineUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopWhatsappLineCreateManyShopInputEnvelope
    set?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
    disconnect?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
    delete?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
    connect?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
    update?: ShopWhatsappLineUpdateWithWhereUniqueWithoutShopInput | ShopWhatsappLineUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopWhatsappLineUpdateManyWithWhereWithoutShopInput | ShopWhatsappLineUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopWhatsappLineScalarWhereInput | ShopWhatsappLineScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutShopNestedInput = {
    create?: XOR<FavoriteCreateWithoutShopInput, FavoriteUncheckedCreateWithoutShopInput> | FavoriteCreateWithoutShopInput[] | FavoriteUncheckedCreateWithoutShopInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutShopInput | FavoriteCreateOrConnectWithoutShopInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutShopInput | FavoriteUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: FavoriteCreateManyShopInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutShopInput | FavoriteUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutShopInput | FavoriteUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type QuotaWalletUpdateOneWithoutShopNestedInput = {
    create?: XOR<QuotaWalletCreateWithoutShopInput, QuotaWalletUncheckedCreateWithoutShopInput>
    connectOrCreate?: QuotaWalletCreateOrConnectWithoutShopInput
    upsert?: QuotaWalletUpsertWithoutShopInput
    disconnect?: QuotaWalletWhereInput | boolean
    delete?: QuotaWalletWhereInput | boolean
    connect?: QuotaWalletWhereUniqueInput
    update?: XOR<XOR<QuotaWalletUpdateToOneWithWhereWithoutShopInput, QuotaWalletUpdateWithoutShopInput>, QuotaWalletUncheckedUpdateWithoutShopInput>
  }

  export type QuotaTransactionUpdateManyWithoutShopNestedInput = {
    create?: XOR<QuotaTransactionCreateWithoutShopInput, QuotaTransactionUncheckedCreateWithoutShopInput> | QuotaTransactionCreateWithoutShopInput[] | QuotaTransactionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: QuotaTransactionCreateOrConnectWithoutShopInput | QuotaTransactionCreateOrConnectWithoutShopInput[]
    upsert?: QuotaTransactionUpsertWithWhereUniqueWithoutShopInput | QuotaTransactionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: QuotaTransactionCreateManyShopInputEnvelope
    set?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
    disconnect?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
    delete?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
    connect?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
    update?: QuotaTransactionUpdateWithWhereUniqueWithoutShopInput | QuotaTransactionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: QuotaTransactionUpdateManyWithWhereWithoutShopInput | QuotaTransactionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: QuotaTransactionScalarWhereInput | QuotaTransactionScalarWhereInput[]
  }

  export type PurchaseRequestUpdateManyWithoutShopNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutShopInput, PurchaseRequestUncheckedCreateWithoutShopInput> | PurchaseRequestCreateWithoutShopInput[] | PurchaseRequestUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutShopInput | PurchaseRequestCreateOrConnectWithoutShopInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutShopInput | PurchaseRequestUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: PurchaseRequestCreateManyShopInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutShopInput | PurchaseRequestUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutShopInput | PurchaseRequestUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type StreamUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<StreamCreateWithoutShopInput, StreamUncheckedCreateWithoutShopInput> | StreamCreateWithoutShopInput[] | StreamUncheckedCreateWithoutShopInput[]
    connectOrCreate?: StreamCreateOrConnectWithoutShopInput | StreamCreateOrConnectWithoutShopInput[]
    upsert?: StreamUpsertWithWhereUniqueWithoutShopInput | StreamUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: StreamCreateManyShopInputEnvelope
    set?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    disconnect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    delete?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    connect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    update?: StreamUpdateWithWhereUniqueWithoutShopInput | StreamUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: StreamUpdateManyWithWhereWithoutShopInput | StreamUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: StreamScalarWhereInput | StreamScalarWhereInput[]
  }

  export type ReelUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ReelCreateWithoutShopInput, ReelUncheckedCreateWithoutShopInput> | ReelCreateWithoutShopInput[] | ReelUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ReelCreateOrConnectWithoutShopInput | ReelCreateOrConnectWithoutShopInput[]
    upsert?: ReelUpsertWithWhereUniqueWithoutShopInput | ReelUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ReelCreateManyShopInputEnvelope
    set?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
    disconnect?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
    delete?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
    connect?: ReelWhereUniqueInput | ReelWhereUniqueInput[]
    update?: ReelUpdateWithWhereUniqueWithoutShopInput | ReelUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ReelUpdateManyWithWhereWithoutShopInput | ReelUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ReelScalarWhereInput | ReelScalarWhereInput[]
  }

  export type PenaltyUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<PenaltyCreateWithoutShopInput, PenaltyUncheckedCreateWithoutShopInput> | PenaltyCreateWithoutShopInput[] | PenaltyUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutShopInput | PenaltyCreateOrConnectWithoutShopInput[]
    upsert?: PenaltyUpsertWithWhereUniqueWithoutShopInput | PenaltyUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: PenaltyCreateManyShopInputEnvelope
    set?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    disconnect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    delete?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    update?: PenaltyUpdateWithWhereUniqueWithoutShopInput | PenaltyUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: PenaltyUpdateManyWithWhereWithoutShopInput | PenaltyUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
  }

  export type ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopSocialHandleCreateWithoutShopInput, ShopSocialHandleUncheckedCreateWithoutShopInput> | ShopSocialHandleCreateWithoutShopInput[] | ShopSocialHandleUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopSocialHandleCreateOrConnectWithoutShopInput | ShopSocialHandleCreateOrConnectWithoutShopInput[]
    upsert?: ShopSocialHandleUpsertWithWhereUniqueWithoutShopInput | ShopSocialHandleUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopSocialHandleCreateManyShopInputEnvelope
    set?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
    disconnect?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
    delete?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
    connect?: ShopSocialHandleWhereUniqueInput | ShopSocialHandleWhereUniqueInput[]
    update?: ShopSocialHandleUpdateWithWhereUniqueWithoutShopInput | ShopSocialHandleUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopSocialHandleUpdateManyWithWhereWithoutShopInput | ShopSocialHandleUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopSocialHandleScalarWhereInput | ShopSocialHandleScalarWhereInput[]
  }

  export type ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopWhatsappLineCreateWithoutShopInput, ShopWhatsappLineUncheckedCreateWithoutShopInput> | ShopWhatsappLineCreateWithoutShopInput[] | ShopWhatsappLineUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopWhatsappLineCreateOrConnectWithoutShopInput | ShopWhatsappLineCreateOrConnectWithoutShopInput[]
    upsert?: ShopWhatsappLineUpsertWithWhereUniqueWithoutShopInput | ShopWhatsappLineUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopWhatsappLineCreateManyShopInputEnvelope
    set?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
    disconnect?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
    delete?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
    connect?: ShopWhatsappLineWhereUniqueInput | ShopWhatsappLineWhereUniqueInput[]
    update?: ShopWhatsappLineUpdateWithWhereUniqueWithoutShopInput | ShopWhatsappLineUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopWhatsappLineUpdateManyWithWhereWithoutShopInput | ShopWhatsappLineUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopWhatsappLineScalarWhereInput | ShopWhatsappLineScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<FavoriteCreateWithoutShopInput, FavoriteUncheckedCreateWithoutShopInput> | FavoriteCreateWithoutShopInput[] | FavoriteUncheckedCreateWithoutShopInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutShopInput | FavoriteCreateOrConnectWithoutShopInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutShopInput | FavoriteUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: FavoriteCreateManyShopInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutShopInput | FavoriteUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutShopInput | FavoriteUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type QuotaWalletUncheckedUpdateOneWithoutShopNestedInput = {
    create?: XOR<QuotaWalletCreateWithoutShopInput, QuotaWalletUncheckedCreateWithoutShopInput>
    connectOrCreate?: QuotaWalletCreateOrConnectWithoutShopInput
    upsert?: QuotaWalletUpsertWithoutShopInput
    disconnect?: QuotaWalletWhereInput | boolean
    delete?: QuotaWalletWhereInput | boolean
    connect?: QuotaWalletWhereUniqueInput
    update?: XOR<XOR<QuotaWalletUpdateToOneWithWhereWithoutShopInput, QuotaWalletUpdateWithoutShopInput>, QuotaWalletUncheckedUpdateWithoutShopInput>
  }

  export type QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<QuotaTransactionCreateWithoutShopInput, QuotaTransactionUncheckedCreateWithoutShopInput> | QuotaTransactionCreateWithoutShopInput[] | QuotaTransactionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: QuotaTransactionCreateOrConnectWithoutShopInput | QuotaTransactionCreateOrConnectWithoutShopInput[]
    upsert?: QuotaTransactionUpsertWithWhereUniqueWithoutShopInput | QuotaTransactionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: QuotaTransactionCreateManyShopInputEnvelope
    set?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
    disconnect?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
    delete?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
    connect?: QuotaTransactionWhereUniqueInput | QuotaTransactionWhereUniqueInput[]
    update?: QuotaTransactionUpdateWithWhereUniqueWithoutShopInput | QuotaTransactionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: QuotaTransactionUpdateManyWithWhereWithoutShopInput | QuotaTransactionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: QuotaTransactionScalarWhereInput | QuotaTransactionScalarWhereInput[]
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutShopInput, PurchaseRequestUncheckedCreateWithoutShopInput> | PurchaseRequestCreateWithoutShopInput[] | PurchaseRequestUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutShopInput | PurchaseRequestCreateOrConnectWithoutShopInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutShopInput | PurchaseRequestUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: PurchaseRequestCreateManyShopInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutShopInput | PurchaseRequestUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutShopInput | PurchaseRequestUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutStreamsInput = {
    create?: XOR<ShopCreateWithoutStreamsInput, ShopUncheckedCreateWithoutStreamsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutStreamsInput
    connect?: ShopWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutStreamInput = {
    create?: XOR<ReportCreateWithoutStreamInput, ReportUncheckedCreateWithoutStreamInput> | ReportCreateWithoutStreamInput[] | ReportUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutStreamInput | ReportCreateOrConnectWithoutStreamInput[]
    createMany?: ReportCreateManyStreamInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutStreamInput = {
    create?: XOR<ReviewCreateWithoutStreamInput, ReviewUncheckedCreateWithoutStreamInput> | ReviewCreateWithoutStreamInput[] | ReviewUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutStreamInput | ReviewCreateOrConnectWithoutStreamInput[]
    createMany?: ReviewCreateManyStreamInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type AgendaCreateNestedManyWithoutStreamInput = {
    create?: XOR<AgendaCreateWithoutStreamInput, AgendaUncheckedCreateWithoutStreamInput> | AgendaCreateWithoutStreamInput[] | AgendaUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: AgendaCreateOrConnectWithoutStreamInput | AgendaCreateOrConnectWithoutStreamInput[]
    createMany?: AgendaCreateManyStreamInputEnvelope
    connect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutStreamInput = {
    create?: XOR<ReportCreateWithoutStreamInput, ReportUncheckedCreateWithoutStreamInput> | ReportCreateWithoutStreamInput[] | ReportUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutStreamInput | ReportCreateOrConnectWithoutStreamInput[]
    createMany?: ReportCreateManyStreamInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutStreamInput = {
    create?: XOR<ReviewCreateWithoutStreamInput, ReviewUncheckedCreateWithoutStreamInput> | ReviewCreateWithoutStreamInput[] | ReviewUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutStreamInput | ReviewCreateOrConnectWithoutStreamInput[]
    createMany?: ReviewCreateManyStreamInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type AgendaUncheckedCreateNestedManyWithoutStreamInput = {
    create?: XOR<AgendaCreateWithoutStreamInput, AgendaUncheckedCreateWithoutStreamInput> | AgendaCreateWithoutStreamInput[] | AgendaUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: AgendaCreateOrConnectWithoutStreamInput | AgendaCreateOrConnectWithoutStreamInput[]
    createMany?: AgendaCreateManyStreamInputEnvelope
    connect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
  }

  export type EnumStreamStatusFieldUpdateOperationsInput = {
    set?: $Enums.StreamStatus
  }

  export type EnumSocialPlatformFieldUpdateOperationsInput = {
    set?: $Enums.SocialPlatform
  }

  export type ShopUpdateOneRequiredWithoutStreamsNestedInput = {
    create?: XOR<ShopCreateWithoutStreamsInput, ShopUncheckedCreateWithoutStreamsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutStreamsInput
    upsert?: ShopUpsertWithoutStreamsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutStreamsInput, ShopUpdateWithoutStreamsInput>, ShopUncheckedUpdateWithoutStreamsInput>
  }

  export type ReportUpdateManyWithoutStreamNestedInput = {
    create?: XOR<ReportCreateWithoutStreamInput, ReportUncheckedCreateWithoutStreamInput> | ReportCreateWithoutStreamInput[] | ReportUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutStreamInput | ReportCreateOrConnectWithoutStreamInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutStreamInput | ReportUpsertWithWhereUniqueWithoutStreamInput[]
    createMany?: ReportCreateManyStreamInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutStreamInput | ReportUpdateWithWhereUniqueWithoutStreamInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutStreamInput | ReportUpdateManyWithWhereWithoutStreamInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutStreamNestedInput = {
    create?: XOR<ReviewCreateWithoutStreamInput, ReviewUncheckedCreateWithoutStreamInput> | ReviewCreateWithoutStreamInput[] | ReviewUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutStreamInput | ReviewCreateOrConnectWithoutStreamInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutStreamInput | ReviewUpsertWithWhereUniqueWithoutStreamInput[]
    createMany?: ReviewCreateManyStreamInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutStreamInput | ReviewUpdateWithWhereUniqueWithoutStreamInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutStreamInput | ReviewUpdateManyWithWhereWithoutStreamInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type AgendaUpdateManyWithoutStreamNestedInput = {
    create?: XOR<AgendaCreateWithoutStreamInput, AgendaUncheckedCreateWithoutStreamInput> | AgendaCreateWithoutStreamInput[] | AgendaUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: AgendaCreateOrConnectWithoutStreamInput | AgendaCreateOrConnectWithoutStreamInput[]
    upsert?: AgendaUpsertWithWhereUniqueWithoutStreamInput | AgendaUpsertWithWhereUniqueWithoutStreamInput[]
    createMany?: AgendaCreateManyStreamInputEnvelope
    set?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    disconnect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    delete?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    connect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    update?: AgendaUpdateWithWhereUniqueWithoutStreamInput | AgendaUpdateWithWhereUniqueWithoutStreamInput[]
    updateMany?: AgendaUpdateManyWithWhereWithoutStreamInput | AgendaUpdateManyWithWhereWithoutStreamInput[]
    deleteMany?: AgendaScalarWhereInput | AgendaScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutStreamNestedInput = {
    create?: XOR<ReportCreateWithoutStreamInput, ReportUncheckedCreateWithoutStreamInput> | ReportCreateWithoutStreamInput[] | ReportUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutStreamInput | ReportCreateOrConnectWithoutStreamInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutStreamInput | ReportUpsertWithWhereUniqueWithoutStreamInput[]
    createMany?: ReportCreateManyStreamInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutStreamInput | ReportUpdateWithWhereUniqueWithoutStreamInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutStreamInput | ReportUpdateManyWithWhereWithoutStreamInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutStreamNestedInput = {
    create?: XOR<ReviewCreateWithoutStreamInput, ReviewUncheckedCreateWithoutStreamInput> | ReviewCreateWithoutStreamInput[] | ReviewUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutStreamInput | ReviewCreateOrConnectWithoutStreamInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutStreamInput | ReviewUpsertWithWhereUniqueWithoutStreamInput[]
    createMany?: ReviewCreateManyStreamInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutStreamInput | ReviewUpdateWithWhereUniqueWithoutStreamInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutStreamInput | ReviewUpdateManyWithWhereWithoutStreamInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type AgendaUncheckedUpdateManyWithoutStreamNestedInput = {
    create?: XOR<AgendaCreateWithoutStreamInput, AgendaUncheckedCreateWithoutStreamInput> | AgendaCreateWithoutStreamInput[] | AgendaUncheckedCreateWithoutStreamInput[]
    connectOrCreate?: AgendaCreateOrConnectWithoutStreamInput | AgendaCreateOrConnectWithoutStreamInput[]
    upsert?: AgendaUpsertWithWhereUniqueWithoutStreamInput | AgendaUpsertWithWhereUniqueWithoutStreamInput[]
    createMany?: AgendaCreateManyStreamInputEnvelope
    set?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    disconnect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    delete?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    connect?: AgendaWhereUniqueInput | AgendaWhereUniqueInput[]
    update?: AgendaUpdateWithWhereUniqueWithoutStreamInput | AgendaUpdateWithWhereUniqueWithoutStreamInput[]
    updateMany?: AgendaUpdateManyWithWhereWithoutStreamInput | AgendaUpdateManyWithWhereWithoutStreamInput[]
    deleteMany?: AgendaScalarWhereInput | AgendaScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutReelsInput = {
    create?: XOR<ShopCreateWithoutReelsInput, ShopUncheckedCreateWithoutReelsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutReelsInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutReelsNestedInput = {
    create?: XOR<ShopCreateWithoutReelsInput, ShopUncheckedCreateWithoutReelsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutReelsInput
    upsert?: ShopUpsertWithoutReelsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutReelsInput, ShopUpdateWithoutReelsInput>, ShopUncheckedUpdateWithoutReelsInput>
  }

  export type ShopCreateNestedOneWithoutSocialHandlesInput = {
    create?: XOR<ShopCreateWithoutSocialHandlesInput, ShopUncheckedCreateWithoutSocialHandlesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutSocialHandlesInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutSocialHandlesNestedInput = {
    create?: XOR<ShopCreateWithoutSocialHandlesInput, ShopUncheckedCreateWithoutSocialHandlesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutSocialHandlesInput
    upsert?: ShopUpsertWithoutSocialHandlesInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutSocialHandlesInput, ShopUpdateWithoutSocialHandlesInput>, ShopUncheckedUpdateWithoutSocialHandlesInput>
  }

  export type ShopCreateNestedOneWithoutWhatsappLinesInput = {
    create?: XOR<ShopCreateWithoutWhatsappLinesInput, ShopUncheckedCreateWithoutWhatsappLinesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutWhatsappLinesInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutWhatsappLinesNestedInput = {
    create?: XOR<ShopCreateWithoutWhatsappLinesInput, ShopUncheckedCreateWithoutWhatsappLinesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutWhatsappLinesInput
    upsert?: ShopUpsertWithoutWhatsappLinesInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutWhatsappLinesInput, ShopUpdateWithoutWhatsappLinesInput>, ShopUncheckedUpdateWithoutWhatsappLinesInput>
  }

  export type StreamCreateNestedOneWithoutReviewsInput = {
    create?: XOR<StreamCreateWithoutReviewsInput, StreamUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: StreamCreateOrConnectWithoutReviewsInput
    connect?: StreamWhereUniqueInput
  }

  export type StreamUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<StreamCreateWithoutReviewsInput, StreamUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: StreamCreateOrConnectWithoutReviewsInput
    upsert?: StreamUpsertWithoutReviewsInput
    connect?: StreamWhereUniqueInput
    update?: XOR<XOR<StreamUpdateToOneWithWhereWithoutReviewsInput, StreamUpdateWithoutReviewsInput>, StreamUncheckedUpdateWithoutReviewsInput>
  }

  export type StreamCreateNestedOneWithoutReportsInput = {
    create?: XOR<StreamCreateWithoutReportsInput, StreamUncheckedCreateWithoutReportsInput>
    connectOrCreate?: StreamCreateOrConnectWithoutReportsInput
    connect?: StreamWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type StreamUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<StreamCreateWithoutReportsInput, StreamUncheckedCreateWithoutReportsInput>
    connectOrCreate?: StreamCreateOrConnectWithoutReportsInput
    upsert?: StreamUpsertWithoutReportsInput
    connect?: StreamWhereUniqueInput
    update?: XOR<XOR<StreamUpdateToOneWithWhereWithoutReportsInput, StreamUpdateWithoutReportsInput>, StreamUncheckedUpdateWithoutReportsInput>
  }

  export type ShopCreateNestedOneWithoutPenaltiesInput = {
    create?: XOR<ShopCreateWithoutPenaltiesInput, ShopUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPenaltiesInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutPenaltiesNestedInput = {
    create?: XOR<ShopCreateWithoutPenaltiesInput, ShopUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPenaltiesInput
    upsert?: ShopUpsertWithoutPenaltiesInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutPenaltiesInput, ShopUpdateWithoutPenaltiesInput>, ShopUncheckedUpdateWithoutPenaltiesInput>
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ShopCreateWithoutFavoritesInput, ShopUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutFavoritesInput
    connect?: ShopWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type ShopUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ShopCreateWithoutFavoritesInput, ShopUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutFavoritesInput
    upsert?: ShopUpsertWithoutFavoritesInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutFavoritesInput, ShopUpdateWithoutFavoritesInput>, ShopUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserCreateNestedOneWithoutAgendaInput = {
    create?: XOR<UserCreateWithoutAgendaInput, UserUncheckedCreateWithoutAgendaInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgendaInput
    connect?: UserWhereUniqueInput
  }

  export type StreamCreateNestedOneWithoutAgendaInput = {
    create?: XOR<StreamCreateWithoutAgendaInput, StreamUncheckedCreateWithoutAgendaInput>
    connectOrCreate?: StreamCreateOrConnectWithoutAgendaInput
    connect?: StreamWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAgendaNestedInput = {
    create?: XOR<UserCreateWithoutAgendaInput, UserUncheckedCreateWithoutAgendaInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgendaInput
    upsert?: UserUpsertWithoutAgendaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgendaInput, UserUpdateWithoutAgendaInput>, UserUncheckedUpdateWithoutAgendaInput>
  }

  export type StreamUpdateOneRequiredWithoutAgendaNestedInput = {
    create?: XOR<StreamCreateWithoutAgendaInput, StreamUncheckedCreateWithoutAgendaInput>
    connectOrCreate?: StreamCreateOrConnectWithoutAgendaInput
    upsert?: StreamUpsertWithoutAgendaInput
    connect?: StreamWhereUniqueInput
    update?: XOR<XOR<StreamUpdateToOneWithWhereWithoutAgendaInput, StreamUpdateWithoutAgendaInput>, StreamUncheckedUpdateWithoutAgendaInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ShopCreateNestedOneWithoutQuotaWalletInput = {
    create?: XOR<ShopCreateWithoutQuotaWalletInput, ShopUncheckedCreateWithoutQuotaWalletInput>
    connectOrCreate?: ShopCreateOrConnectWithoutQuotaWalletInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutQuotaWalletNestedInput = {
    create?: XOR<ShopCreateWithoutQuotaWalletInput, ShopUncheckedCreateWithoutQuotaWalletInput>
    connectOrCreate?: ShopCreateOrConnectWithoutQuotaWalletInput
    upsert?: ShopUpsertWithoutQuotaWalletInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutQuotaWalletInput, ShopUpdateWithoutQuotaWalletInput>, ShopUncheckedUpdateWithoutQuotaWalletInput>
  }

  export type ShopCreateNestedOneWithoutQuotaTransactionsInput = {
    create?: XOR<ShopCreateWithoutQuotaTransactionsInput, ShopUncheckedCreateWithoutQuotaTransactionsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutQuotaTransactionsInput
    connect?: ShopWhereUniqueInput
  }

  export type EnumQuotaResourceFieldUpdateOperationsInput = {
    set?: $Enums.QuotaResource
  }

  export type EnumQuotaDirectionFieldUpdateOperationsInput = {
    set?: $Enums.QuotaDirection
  }

  export type EnumQuotaReasonFieldUpdateOperationsInput = {
    set?: $Enums.QuotaReason
  }

  export type NullableEnumQuotaRefTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuotaRefType | null
  }

  export type EnumQuotaActorTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuotaActorType
  }

  export type ShopUpdateOneRequiredWithoutQuotaTransactionsNestedInput = {
    create?: XOR<ShopCreateWithoutQuotaTransactionsInput, ShopUncheckedCreateWithoutQuotaTransactionsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutQuotaTransactionsInput
    upsert?: ShopUpsertWithoutQuotaTransactionsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutQuotaTransactionsInput, ShopUpdateWithoutQuotaTransactionsInput>, ShopUncheckedUpdateWithoutQuotaTransactionsInput>
  }

  export type ShopCreateNestedOneWithoutPurchaseRequestsInput = {
    create?: XOR<ShopCreateWithoutPurchaseRequestsInput, ShopUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPurchaseRequestsInput
    connect?: ShopWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutApprovedPurchaseRequestsInput = {
    create?: XOR<AdminCreateWithoutApprovedPurchaseRequestsInput, AdminUncheckedCreateWithoutApprovedPurchaseRequestsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutApprovedPurchaseRequestsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumPurchaseTypeFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseType
  }

  export type EnumPurchaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseStatus
  }

  export type ShopUpdateOneRequiredWithoutPurchaseRequestsNestedInput = {
    create?: XOR<ShopCreateWithoutPurchaseRequestsInput, ShopUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPurchaseRequestsInput
    upsert?: ShopUpsertWithoutPurchaseRequestsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutPurchaseRequestsInput, ShopUpdateWithoutPurchaseRequestsInput>, ShopUncheckedUpdateWithoutPurchaseRequestsInput>
  }

  export type AdminUpdateOneWithoutApprovedPurchaseRequestsNestedInput = {
    create?: XOR<AdminCreateWithoutApprovedPurchaseRequestsInput, AdminUncheckedCreateWithoutApprovedPurchaseRequestsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutApprovedPurchaseRequestsInput
    upsert?: AdminUpsertWithoutApprovedPurchaseRequestsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutApprovedPurchaseRequestsInput, AdminUpdateWithoutApprovedPurchaseRequestsInput>, AdminUncheckedUpdateWithoutApprovedPurchaseRequestsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAuthUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthUserType | EnumAuthUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthUserType[] | ListEnumAuthUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthUserType[] | ListEnumAuthUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthUserTypeFilter<$PrismaModel> | $Enums.AuthUserType
  }

  export type NestedEnumAuthUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthUserStatus | EnumAuthUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuthUserStatus[] | ListEnumAuthUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthUserStatus[] | ListEnumAuthUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthUserStatusFilter<$PrismaModel> | $Enums.AuthUserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAuthUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthUserType | EnumAuthUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthUserType[] | ListEnumAuthUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthUserType[] | ListEnumAuthUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthUserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthUserTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthUserTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuthUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthUserStatus | EnumAuthUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuthUserStatus[] | ListEnumAuthUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthUserStatus[] | ListEnumAuthUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuthUserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthUserStatusFilter<$PrismaModel>
    _max?: NestedEnumAuthUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type NestedEnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminStatus[] | ListEnumAdminStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumShopStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopStatus | EnumShopStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShopStatus[] | ListEnumShopStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopStatus[] | ListEnumShopStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShopStatusFilter<$PrismaModel> | $Enums.ShopStatus
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumShopStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopStatus | EnumShopStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShopStatus[] | ListEnumShopStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShopStatus[] | ListEnumShopStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShopStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShopStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShopStatusFilter<$PrismaModel>
    _max?: NestedEnumShopStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStreamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StreamStatus | EnumStreamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStreamStatusFilter<$PrismaModel> | $Enums.StreamStatus
  }

  export type NestedEnumSocialPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformFilter<$PrismaModel> | $Enums.SocialPlatform
  }

  export type NestedEnumStreamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StreamStatus | EnumStreamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStreamStatusWithAggregatesFilter<$PrismaModel> | $Enums.StreamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStreamStatusFilter<$PrismaModel>
    _max?: NestedEnumStreamStatusFilter<$PrismaModel>
  }

  export type NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel> | $Enums.SocialPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialPlatformFilter<$PrismaModel>
    _max?: NestedEnumSocialPlatformFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuotaResourceFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaResource | EnumQuotaResourceFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaResource[] | ListEnumQuotaResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaResource[] | ListEnumQuotaResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaResourceFilter<$PrismaModel> | $Enums.QuotaResource
  }

  export type NestedEnumQuotaDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaDirection | EnumQuotaDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaDirection[] | ListEnumQuotaDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaDirection[] | ListEnumQuotaDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaDirectionFilter<$PrismaModel> | $Enums.QuotaDirection
  }

  export type NestedEnumQuotaReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaReason | EnumQuotaReasonFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaReason[] | ListEnumQuotaReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaReason[] | ListEnumQuotaReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaReasonFilter<$PrismaModel> | $Enums.QuotaReason
  }

  export type NestedEnumQuotaRefTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaRefType | EnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.QuotaRefType[] | ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QuotaRefType[] | ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQuotaRefTypeNullableFilter<$PrismaModel> | $Enums.QuotaRefType | null
  }

  export type NestedEnumQuotaActorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaActorType | EnumQuotaActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaActorType[] | ListEnumQuotaActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaActorType[] | ListEnumQuotaActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaActorTypeFilter<$PrismaModel> | $Enums.QuotaActorType
  }

  export type NestedEnumQuotaResourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaResource | EnumQuotaResourceFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaResource[] | ListEnumQuotaResourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaResource[] | ListEnumQuotaResourceFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaResourceWithAggregatesFilter<$PrismaModel> | $Enums.QuotaResource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotaResourceFilter<$PrismaModel>
    _max?: NestedEnumQuotaResourceFilter<$PrismaModel>
  }

  export type NestedEnumQuotaDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaDirection | EnumQuotaDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaDirection[] | ListEnumQuotaDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaDirection[] | ListEnumQuotaDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaDirectionWithAggregatesFilter<$PrismaModel> | $Enums.QuotaDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotaDirectionFilter<$PrismaModel>
    _max?: NestedEnumQuotaDirectionFilter<$PrismaModel>
  }

  export type NestedEnumQuotaReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaReason | EnumQuotaReasonFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaReason[] | ListEnumQuotaReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaReason[] | ListEnumQuotaReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaReasonWithAggregatesFilter<$PrismaModel> | $Enums.QuotaReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotaReasonFilter<$PrismaModel>
    _max?: NestedEnumQuotaReasonFilter<$PrismaModel>
  }

  export type NestedEnumQuotaRefTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaRefType | EnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.QuotaRefType[] | ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QuotaRefType[] | ListEnumQuotaRefTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQuotaRefTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.QuotaRefType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumQuotaRefTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumQuotaRefTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumQuotaActorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotaActorType | EnumQuotaActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuotaActorType[] | ListEnumQuotaActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotaActorType[] | ListEnumQuotaActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotaActorTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuotaActorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotaActorTypeFilter<$PrismaModel>
    _max?: NestedEnumQuotaActorTypeFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseType | EnumPurchaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseTypeFilter<$PrismaModel> | $Enums.PurchaseType
  }

  export type NestedEnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type NestedEnumPurchaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseType | EnumPurchaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseTypeFilter<$PrismaModel>
    _max?: NestedEnumPurchaseTypeFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type ShopCreateWithoutAuthUserInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutAuthUserInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutAuthUserInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutAuthUserInput, ShopUncheckedCreateWithoutAuthUserInput>
  }

  export type AdminCreateWithoutAuthUserInput = {
    role?: $Enums.AdminRole
    adminStatus?: $Enums.AdminStatus
    createdAt?: Date | string
    approvedPurchaseRequests?: PurchaseRequestCreateNestedManyWithoutApprovedByAdminInput
  }

  export type AdminUncheckedCreateWithoutAuthUserInput = {
    role?: $Enums.AdminRole
    adminStatus?: $Enums.AdminStatus
    createdAt?: Date | string
    approvedPurchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutApprovedByAdminInput
  }

  export type AdminCreateOrConnectWithoutAuthUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAuthUserInput, AdminUncheckedCreateWithoutAuthUserInput>
  }

  export type ClientCreateWithoutAuthUserInput = {
    displayName?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
  }

  export type ClientUncheckedCreateWithoutAuthUserInput = {
    displayName?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutAuthUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAuthUserInput, ClientUncheckedCreateWithoutAuthUserInput>
  }

  export type ShopUpsertWithoutAuthUserInput = {
    update: XOR<ShopUpdateWithoutAuthUserInput, ShopUncheckedUpdateWithoutAuthUserInput>
    create: XOR<ShopCreateWithoutAuthUserInput, ShopUncheckedCreateWithoutAuthUserInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutAuthUserInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutAuthUserInput, ShopUncheckedUpdateWithoutAuthUserInput>
  }

  export type ShopUpdateWithoutAuthUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutAuthUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type AdminUpsertWithoutAuthUserInput = {
    update: XOR<AdminUpdateWithoutAuthUserInput, AdminUncheckedUpdateWithoutAuthUserInput>
    create: XOR<AdminCreateWithoutAuthUserInput, AdminUncheckedCreateWithoutAuthUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAuthUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAuthUserInput, AdminUncheckedUpdateWithoutAuthUserInput>
  }

  export type AdminUpdateWithoutAuthUserInput = {
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedPurchaseRequests?: PurchaseRequestUpdateManyWithoutApprovedByAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAuthUserInput = {
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedPurchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutApprovedByAdminNestedInput
  }

  export type ClientUpsertWithoutAuthUserInput = {
    update: XOR<ClientUpdateWithoutAuthUserInput, ClientUncheckedUpdateWithoutAuthUserInput>
    create: XOR<ClientCreateWithoutAuthUserInput, ClientUncheckedCreateWithoutAuthUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAuthUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAuthUserInput, ClientUncheckedUpdateWithoutAuthUserInput>
  }

  export type ClientUpdateWithoutAuthUserInput = {
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateWithoutAuthUserInput = {
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthUserCreateWithoutAdminInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    shop?: ShopCreateNestedOneWithoutAuthUserInput
    client?: ClientCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserUncheckedCreateWithoutAdminInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    shop?: ShopUncheckedCreateNestedOneWithoutAuthUserInput
    client?: ClientUncheckedCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserCreateOrConnectWithoutAdminInput = {
    where: AuthUserWhereUniqueInput
    create: XOR<AuthUserCreateWithoutAdminInput, AuthUserUncheckedCreateWithoutAdminInput>
  }

  export type PurchaseRequestCreateWithoutApprovedByAdminInput = {
    purchaseId?: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    paymentProofUrl?: string | null
    notes?: string | null
    shop: ShopCreateNestedOneWithoutPurchaseRequestsInput
  }

  export type PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput = {
    purchaseId?: string
    shopId: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    paymentProofUrl?: string | null
    notes?: string | null
  }

  export type PurchaseRequestCreateOrConnectWithoutApprovedByAdminInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutApprovedByAdminInput, PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput>
  }

  export type PurchaseRequestCreateManyApprovedByAdminInputEnvelope = {
    data: PurchaseRequestCreateManyApprovedByAdminInput | PurchaseRequestCreateManyApprovedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type AuthUserUpsertWithoutAdminInput = {
    update: XOR<AuthUserUpdateWithoutAdminInput, AuthUserUncheckedUpdateWithoutAdminInput>
    create: XOR<AuthUserCreateWithoutAdminInput, AuthUserUncheckedCreateWithoutAdminInput>
    where?: AuthUserWhereInput
  }

  export type AuthUserUpdateToOneWithWhereWithoutAdminInput = {
    where?: AuthUserWhereInput
    data: XOR<AuthUserUpdateWithoutAdminInput, AuthUserUncheckedUpdateWithoutAdminInput>
  }

  export type AuthUserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUpdateOneWithoutAuthUserNestedInput
    client?: ClientUpdateOneWithoutAuthUserNestedInput
  }

  export type AuthUserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUncheckedUpdateOneWithoutAuthUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutAuthUserNestedInput
  }

  export type PurchaseRequestUpsertWithWhereUniqueWithoutApprovedByAdminInput = {
    where: PurchaseRequestWhereUniqueInput
    update: XOR<PurchaseRequestUpdateWithoutApprovedByAdminInput, PurchaseRequestUncheckedUpdateWithoutApprovedByAdminInput>
    create: XOR<PurchaseRequestCreateWithoutApprovedByAdminInput, PurchaseRequestUncheckedCreateWithoutApprovedByAdminInput>
  }

  export type PurchaseRequestUpdateWithWhereUniqueWithoutApprovedByAdminInput = {
    where: PurchaseRequestWhereUniqueInput
    data: XOR<PurchaseRequestUpdateWithoutApprovedByAdminInput, PurchaseRequestUncheckedUpdateWithoutApprovedByAdminInput>
  }

  export type PurchaseRequestUpdateManyWithWhereWithoutApprovedByAdminInput = {
    where: PurchaseRequestScalarWhereInput
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyWithoutApprovedByAdminInput>
  }

  export type PurchaseRequestScalarWhereInput = {
    AND?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
    OR?: PurchaseRequestScalarWhereInput[]
    NOT?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
    purchaseId?: StringFilter<"PurchaseRequest"> | string
    shopId?: StringFilter<"PurchaseRequest"> | string
    type?: EnumPurchaseTypeFilter<"PurchaseRequest"> | $Enums.PurchaseType
    quantity?: IntFilter<"PurchaseRequest"> | number
    status?: EnumPurchaseStatusFilter<"PurchaseRequest"> | $Enums.PurchaseStatus
    createdAt?: DateTimeFilter<"PurchaseRequest"> | Date | string
    approvedAt?: DateTimeNullableFilter<"PurchaseRequest"> | Date | string | null
    approvedByAdminId?: StringNullableFilter<"PurchaseRequest"> | string | null
    paymentProofUrl?: StringNullableFilter<"PurchaseRequest"> | string | null
    notes?: StringNullableFilter<"PurchaseRequest"> | string | null
  }

  export type AuthUserCreateWithoutClientInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    shop?: ShopCreateNestedOneWithoutAuthUserInput
    admin?: AdminCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserUncheckedCreateWithoutClientInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    shop?: ShopUncheckedCreateNestedOneWithoutAuthUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserCreateOrConnectWithoutClientInput = {
    where: AuthUserWhereUniqueInput
    create: XOR<AuthUserCreateWithoutClientInput, AuthUserUncheckedCreateWithoutClientInput>
  }

  export type AuthUserUpsertWithoutClientInput = {
    update: XOR<AuthUserUpdateWithoutClientInput, AuthUserUncheckedUpdateWithoutClientInput>
    create: XOR<AuthUserCreateWithoutClientInput, AuthUserUncheckedCreateWithoutClientInput>
    where?: AuthUserWhereInput
  }

  export type AuthUserUpdateToOneWithWhereWithoutClientInput = {
    where?: AuthUserWhereInput
    data: XOR<AuthUserUpdateWithoutClientInput, AuthUserUncheckedUpdateWithoutClientInput>
  }

  export type AuthUserUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUpdateOneWithoutAuthUserNestedInput
    admin?: AdminUpdateOneWithoutAuthUserNestedInput
  }

  export type AuthUserUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUncheckedUpdateOneWithoutAuthUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutAuthUserNestedInput
  }

  export type FavoriteCreateWithoutUserInput = {
    id?: string
    shop: ShopCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    shopId: string
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgendaCreateWithoutUserInput = {
    id?: string
    stream: StreamCreateNestedOneWithoutAgendaInput
  }

  export type AgendaUncheckedCreateWithoutUserInput = {
    id?: string
    streamId: string
  }

  export type AgendaCreateOrConnectWithoutUserInput = {
    where: AgendaWhereUniqueInput
    create: XOR<AgendaCreateWithoutUserInput, AgendaUncheckedCreateWithoutUserInput>
  }

  export type AgendaCreateManyUserInputEnvelope = {
    data: AgendaCreateManyUserInput | AgendaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    shopId?: StringFilter<"Favorite"> | string
  }

  export type AgendaUpsertWithWhereUniqueWithoutUserInput = {
    where: AgendaWhereUniqueInput
    update: XOR<AgendaUpdateWithoutUserInput, AgendaUncheckedUpdateWithoutUserInput>
    create: XOR<AgendaCreateWithoutUserInput, AgendaUncheckedCreateWithoutUserInput>
  }

  export type AgendaUpdateWithWhereUniqueWithoutUserInput = {
    where: AgendaWhereUniqueInput
    data: XOR<AgendaUpdateWithoutUserInput, AgendaUncheckedUpdateWithoutUserInput>
  }

  export type AgendaUpdateManyWithWhereWithoutUserInput = {
    where: AgendaScalarWhereInput
    data: XOR<AgendaUpdateManyMutationInput, AgendaUncheckedUpdateManyWithoutUserInput>
  }

  export type AgendaScalarWhereInput = {
    AND?: AgendaScalarWhereInput | AgendaScalarWhereInput[]
    OR?: AgendaScalarWhereInput[]
    NOT?: AgendaScalarWhereInput | AgendaScalarWhereInput[]
    id?: StringFilter<"Agenda"> | string
    userId?: StringFilter<"Agenda"> | string
    streamId?: StringFilter<"Agenda"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuthUserCreateWithoutShopInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutAuthUserInput
    client?: ClientCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserUncheckedCreateWithoutShopInput = {
    id?: string
    email: string
    passwordHash?: string | null
    userType: $Enums.AuthUserType
    status?: $Enums.AuthUserStatus
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    admin?: AdminUncheckedCreateNestedOneWithoutAuthUserInput
    client?: ClientUncheckedCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserCreateOrConnectWithoutShopInput = {
    where: AuthUserWhereUniqueInput
    create: XOR<AuthUserCreateWithoutShopInput, AuthUserUncheckedCreateWithoutShopInput>
  }

  export type StreamCreateWithoutShopInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    reports?: ReportCreateNestedManyWithoutStreamInput
    reviews?: ReviewCreateNestedManyWithoutStreamInput
    agenda?: AgendaCreateNestedManyWithoutStreamInput
  }

  export type StreamUncheckedCreateWithoutShopInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutStreamInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutStreamInput
    agenda?: AgendaUncheckedCreateNestedManyWithoutStreamInput
  }

  export type StreamCreateOrConnectWithoutShopInput = {
    where: StreamWhereUniqueInput
    create: XOR<StreamCreateWithoutShopInput, StreamUncheckedCreateWithoutShopInput>
  }

  export type StreamCreateManyShopInputEnvelope = {
    data: StreamCreateManyShopInput | StreamCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ReelCreateWithoutShopInput = {
    id?: string
    url: string
    platform?: $Enums.SocialPlatform
    hidden?: boolean
    views?: number
    createdAt?: Date | string
  }

  export type ReelUncheckedCreateWithoutShopInput = {
    id?: string
    url: string
    platform?: $Enums.SocialPlatform
    hidden?: boolean
    views?: number
    createdAt?: Date | string
  }

  export type ReelCreateOrConnectWithoutShopInput = {
    where: ReelWhereUniqueInput
    create: XOR<ReelCreateWithoutShopInput, ReelUncheckedCreateWithoutShopInput>
  }

  export type ReelCreateManyShopInputEnvelope = {
    data: ReelCreateManyShopInput | ReelCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type PenaltyCreateWithoutShopInput = {
    id?: string
    reason: string
    active?: boolean
    createdAt?: Date | string
  }

  export type PenaltyUncheckedCreateWithoutShopInput = {
    id?: string
    reason: string
    active?: boolean
    createdAt?: Date | string
  }

  export type PenaltyCreateOrConnectWithoutShopInput = {
    where: PenaltyWhereUniqueInput
    create: XOR<PenaltyCreateWithoutShopInput, PenaltyUncheckedCreateWithoutShopInput>
  }

  export type PenaltyCreateManyShopInputEnvelope = {
    data: PenaltyCreateManyShopInput | PenaltyCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ShopSocialHandleCreateWithoutShopInput = {
    id?: string
    platform: $Enums.SocialPlatform
    handle: string
    createdAt?: Date | string
  }

  export type ShopSocialHandleUncheckedCreateWithoutShopInput = {
    id?: string
    platform: $Enums.SocialPlatform
    handle: string
    createdAt?: Date | string
  }

  export type ShopSocialHandleCreateOrConnectWithoutShopInput = {
    where: ShopSocialHandleWhereUniqueInput
    create: XOR<ShopSocialHandleCreateWithoutShopInput, ShopSocialHandleUncheckedCreateWithoutShopInput>
  }

  export type ShopSocialHandleCreateManyShopInputEnvelope = {
    data: ShopSocialHandleCreateManyShopInput | ShopSocialHandleCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ShopWhatsappLineCreateWithoutShopInput = {
    id?: string
    label: string
    number: string
    createdAt?: Date | string
  }

  export type ShopWhatsappLineUncheckedCreateWithoutShopInput = {
    id?: string
    label: string
    number: string
    createdAt?: Date | string
  }

  export type ShopWhatsappLineCreateOrConnectWithoutShopInput = {
    where: ShopWhatsappLineWhereUniqueInput
    create: XOR<ShopWhatsappLineCreateWithoutShopInput, ShopWhatsappLineUncheckedCreateWithoutShopInput>
  }

  export type ShopWhatsappLineCreateManyShopInputEnvelope = {
    data: ShopWhatsappLineCreateManyShopInput | ShopWhatsappLineCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutShopInput = {
    id?: string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutShopInput = {
    id?: string
    userId: string
  }

  export type FavoriteCreateOrConnectWithoutShopInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutShopInput, FavoriteUncheckedCreateWithoutShopInput>
  }

  export type FavoriteCreateManyShopInputEnvelope = {
    data: FavoriteCreateManyShopInput | FavoriteCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type QuotaWalletCreateWithoutShopInput = {
    weeklyLiveBaseLimit: number
    weeklyLiveUsed: number
    weeklyLiveWeekKey: string
    liveExtraBalance: number
    reelDailyLimit: number
    reelDailyUsed: number
    reelDailyDateKey: string
    reelExtraBalance: number
  }

  export type QuotaWalletUncheckedCreateWithoutShopInput = {
    weeklyLiveBaseLimit: number
    weeklyLiveUsed: number
    weeklyLiveWeekKey: string
    liveExtraBalance: number
    reelDailyLimit: number
    reelDailyUsed: number
    reelDailyDateKey: string
    reelExtraBalance: number
  }

  export type QuotaWalletCreateOrConnectWithoutShopInput = {
    where: QuotaWalletWhereUniqueInput
    create: XOR<QuotaWalletCreateWithoutShopInput, QuotaWalletUncheckedCreateWithoutShopInput>
  }

  export type QuotaTransactionCreateWithoutShopInput = {
    txnId?: string
    resource: $Enums.QuotaResource
    direction: $Enums.QuotaDirection
    amount: number
    reason: $Enums.QuotaReason
    refType?: $Enums.QuotaRefType | null
    refId?: string | null
    actorType: $Enums.QuotaActorType
    actorId?: string | null
    createdAt?: Date | string
  }

  export type QuotaTransactionUncheckedCreateWithoutShopInput = {
    txnId?: string
    resource: $Enums.QuotaResource
    direction: $Enums.QuotaDirection
    amount: number
    reason: $Enums.QuotaReason
    refType?: $Enums.QuotaRefType | null
    refId?: string | null
    actorType: $Enums.QuotaActorType
    actorId?: string | null
    createdAt?: Date | string
  }

  export type QuotaTransactionCreateOrConnectWithoutShopInput = {
    where: QuotaTransactionWhereUniqueInput
    create: XOR<QuotaTransactionCreateWithoutShopInput, QuotaTransactionUncheckedCreateWithoutShopInput>
  }

  export type QuotaTransactionCreateManyShopInputEnvelope = {
    data: QuotaTransactionCreateManyShopInput | QuotaTransactionCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseRequestCreateWithoutShopInput = {
    purchaseId?: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    paymentProofUrl?: string | null
    notes?: string | null
    approvedByAdmin?: AdminCreateNestedOneWithoutApprovedPurchaseRequestsInput
  }

  export type PurchaseRequestUncheckedCreateWithoutShopInput = {
    purchaseId?: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedByAdminId?: string | null
    paymentProofUrl?: string | null
    notes?: string | null
  }

  export type PurchaseRequestCreateOrConnectWithoutShopInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutShopInput, PurchaseRequestUncheckedCreateWithoutShopInput>
  }

  export type PurchaseRequestCreateManyShopInputEnvelope = {
    data: PurchaseRequestCreateManyShopInput | PurchaseRequestCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type AuthUserUpsertWithoutShopInput = {
    update: XOR<AuthUserUpdateWithoutShopInput, AuthUserUncheckedUpdateWithoutShopInput>
    create: XOR<AuthUserCreateWithoutShopInput, AuthUserUncheckedCreateWithoutShopInput>
    where?: AuthUserWhereInput
  }

  export type AuthUserUpdateToOneWithWhereWithoutShopInput = {
    where?: AuthUserWhereInput
    data: XOR<AuthUserUpdateWithoutShopInput, AuthUserUncheckedUpdateWithoutShopInput>
  }

  export type AuthUserUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutAuthUserNestedInput
    client?: ClientUpdateOneWithoutAuthUserNestedInput
  }

  export type AuthUserUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumAuthUserTypeFieldUpdateOperationsInput | $Enums.AuthUserType
    status?: EnumAuthUserStatusFieldUpdateOperationsInput | $Enums.AuthUserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUncheckedUpdateOneWithoutAuthUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutAuthUserNestedInput
  }

  export type StreamUpsertWithWhereUniqueWithoutShopInput = {
    where: StreamWhereUniqueInput
    update: XOR<StreamUpdateWithoutShopInput, StreamUncheckedUpdateWithoutShopInput>
    create: XOR<StreamCreateWithoutShopInput, StreamUncheckedCreateWithoutShopInput>
  }

  export type StreamUpdateWithWhereUniqueWithoutShopInput = {
    where: StreamWhereUniqueInput
    data: XOR<StreamUpdateWithoutShopInput, StreamUncheckedUpdateWithoutShopInput>
  }

  export type StreamUpdateManyWithWhereWithoutShopInput = {
    where: StreamScalarWhereInput
    data: XOR<StreamUpdateManyMutationInput, StreamUncheckedUpdateManyWithoutShopInput>
  }

  export type StreamScalarWhereInput = {
    AND?: StreamScalarWhereInput | StreamScalarWhereInput[]
    OR?: StreamScalarWhereInput[]
    NOT?: StreamScalarWhereInput | StreamScalarWhereInput[]
    id?: StringFilter<"Stream"> | string
    shopId?: StringFilter<"Stream"> | string
    title?: StringFilter<"Stream"> | string
    description?: StringNullableFilter<"Stream"> | string | null
    status?: EnumStreamStatusFilter<"Stream"> | $Enums.StreamStatus
    scheduledAt?: DateTimeFilter<"Stream"> | Date | string
    scheduledEndPlanned?: DateTimeNullableFilter<"Stream"> | Date | string | null
    timezone?: StringFilter<"Stream"> | string
    startTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    durationMinutes?: IntNullableFilter<"Stream"> | number | null
    cancelledAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    cancelReason?: StringNullableFilter<"Stream"> | string | null
    hidden?: BoolFilter<"Stream"> | boolean
    visibilityReason?: StringNullableFilter<"Stream"> | string | null
    platform?: EnumSocialPlatformFilter<"Stream"> | $Enums.SocialPlatform
    url?: StringNullableFilter<"Stream"> | string | null
    extensionCount?: IntFilter<"Stream"> | number
    reportCount?: IntFilter<"Stream"> | number
    editCount?: IntFilter<"Stream"> | number
    lastEditedAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    originalScheduledAt?: DateTimeNullableFilter<"Stream"> | Date | string | null
    reprogrammedFromId?: StringNullableFilter<"Stream"> | string | null
    reprogramReason?: StringNullableFilter<"Stream"> | string | null
    pendingReprogramNote?: StringNullableFilter<"Stream"> | string | null
    reprogramBatchId?: StringNullableFilter<"Stream"> | string | null
    createdAt?: DateTimeFilter<"Stream"> | Date | string
  }

  export type ReelUpsertWithWhereUniqueWithoutShopInput = {
    where: ReelWhereUniqueInput
    update: XOR<ReelUpdateWithoutShopInput, ReelUncheckedUpdateWithoutShopInput>
    create: XOR<ReelCreateWithoutShopInput, ReelUncheckedCreateWithoutShopInput>
  }

  export type ReelUpdateWithWhereUniqueWithoutShopInput = {
    where: ReelWhereUniqueInput
    data: XOR<ReelUpdateWithoutShopInput, ReelUncheckedUpdateWithoutShopInput>
  }

  export type ReelUpdateManyWithWhereWithoutShopInput = {
    where: ReelScalarWhereInput
    data: XOR<ReelUpdateManyMutationInput, ReelUncheckedUpdateManyWithoutShopInput>
  }

  export type ReelScalarWhereInput = {
    AND?: ReelScalarWhereInput | ReelScalarWhereInput[]
    OR?: ReelScalarWhereInput[]
    NOT?: ReelScalarWhereInput | ReelScalarWhereInput[]
    id?: StringFilter<"Reel"> | string
    shopId?: StringFilter<"Reel"> | string
    url?: StringFilter<"Reel"> | string
    platform?: EnumSocialPlatformFilter<"Reel"> | $Enums.SocialPlatform
    hidden?: BoolFilter<"Reel"> | boolean
    views?: IntFilter<"Reel"> | number
    createdAt?: DateTimeFilter<"Reel"> | Date | string
  }

  export type PenaltyUpsertWithWhereUniqueWithoutShopInput = {
    where: PenaltyWhereUniqueInput
    update: XOR<PenaltyUpdateWithoutShopInput, PenaltyUncheckedUpdateWithoutShopInput>
    create: XOR<PenaltyCreateWithoutShopInput, PenaltyUncheckedCreateWithoutShopInput>
  }

  export type PenaltyUpdateWithWhereUniqueWithoutShopInput = {
    where: PenaltyWhereUniqueInput
    data: XOR<PenaltyUpdateWithoutShopInput, PenaltyUncheckedUpdateWithoutShopInput>
  }

  export type PenaltyUpdateManyWithWhereWithoutShopInput = {
    where: PenaltyScalarWhereInput
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyWithoutShopInput>
  }

  export type PenaltyScalarWhereInput = {
    AND?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
    OR?: PenaltyScalarWhereInput[]
    NOT?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
    id?: StringFilter<"Penalty"> | string
    shopId?: StringFilter<"Penalty"> | string
    reason?: StringFilter<"Penalty"> | string
    active?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
  }

  export type ShopSocialHandleUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopSocialHandleWhereUniqueInput
    update: XOR<ShopSocialHandleUpdateWithoutShopInput, ShopSocialHandleUncheckedUpdateWithoutShopInput>
    create: XOR<ShopSocialHandleCreateWithoutShopInput, ShopSocialHandleUncheckedCreateWithoutShopInput>
  }

  export type ShopSocialHandleUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopSocialHandleWhereUniqueInput
    data: XOR<ShopSocialHandleUpdateWithoutShopInput, ShopSocialHandleUncheckedUpdateWithoutShopInput>
  }

  export type ShopSocialHandleUpdateManyWithWhereWithoutShopInput = {
    where: ShopSocialHandleScalarWhereInput
    data: XOR<ShopSocialHandleUpdateManyMutationInput, ShopSocialHandleUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopSocialHandleScalarWhereInput = {
    AND?: ShopSocialHandleScalarWhereInput | ShopSocialHandleScalarWhereInput[]
    OR?: ShopSocialHandleScalarWhereInput[]
    NOT?: ShopSocialHandleScalarWhereInput | ShopSocialHandleScalarWhereInput[]
    id?: StringFilter<"ShopSocialHandle"> | string
    shopId?: StringFilter<"ShopSocialHandle"> | string
    platform?: EnumSocialPlatformFilter<"ShopSocialHandle"> | $Enums.SocialPlatform
    handle?: StringFilter<"ShopSocialHandle"> | string
    createdAt?: DateTimeFilter<"ShopSocialHandle"> | Date | string
  }

  export type ShopWhatsappLineUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopWhatsappLineWhereUniqueInput
    update: XOR<ShopWhatsappLineUpdateWithoutShopInput, ShopWhatsappLineUncheckedUpdateWithoutShopInput>
    create: XOR<ShopWhatsappLineCreateWithoutShopInput, ShopWhatsappLineUncheckedCreateWithoutShopInput>
  }

  export type ShopWhatsappLineUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopWhatsappLineWhereUniqueInput
    data: XOR<ShopWhatsappLineUpdateWithoutShopInput, ShopWhatsappLineUncheckedUpdateWithoutShopInput>
  }

  export type ShopWhatsappLineUpdateManyWithWhereWithoutShopInput = {
    where: ShopWhatsappLineScalarWhereInput
    data: XOR<ShopWhatsappLineUpdateManyMutationInput, ShopWhatsappLineUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopWhatsappLineScalarWhereInput = {
    AND?: ShopWhatsappLineScalarWhereInput | ShopWhatsappLineScalarWhereInput[]
    OR?: ShopWhatsappLineScalarWhereInput[]
    NOT?: ShopWhatsappLineScalarWhereInput | ShopWhatsappLineScalarWhereInput[]
    id?: StringFilter<"ShopWhatsappLine"> | string
    shopId?: StringFilter<"ShopWhatsappLine"> | string
    label?: StringFilter<"ShopWhatsappLine"> | string
    number?: StringFilter<"ShopWhatsappLine"> | string
    createdAt?: DateTimeFilter<"ShopWhatsappLine"> | Date | string
  }

  export type FavoriteUpsertWithWhereUniqueWithoutShopInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutShopInput, FavoriteUncheckedUpdateWithoutShopInput>
    create: XOR<FavoriteCreateWithoutShopInput, FavoriteUncheckedCreateWithoutShopInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutShopInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutShopInput, FavoriteUncheckedUpdateWithoutShopInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutShopInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutShopInput>
  }

  export type QuotaWalletUpsertWithoutShopInput = {
    update: XOR<QuotaWalletUpdateWithoutShopInput, QuotaWalletUncheckedUpdateWithoutShopInput>
    create: XOR<QuotaWalletCreateWithoutShopInput, QuotaWalletUncheckedCreateWithoutShopInput>
    where?: QuotaWalletWhereInput
  }

  export type QuotaWalletUpdateToOneWithWhereWithoutShopInput = {
    where?: QuotaWalletWhereInput
    data: XOR<QuotaWalletUpdateWithoutShopInput, QuotaWalletUncheckedUpdateWithoutShopInput>
  }

  export type QuotaWalletUpdateWithoutShopInput = {
    weeklyLiveBaseLimit?: IntFieldUpdateOperationsInput | number
    weeklyLiveUsed?: IntFieldUpdateOperationsInput | number
    weeklyLiveWeekKey?: StringFieldUpdateOperationsInput | string
    liveExtraBalance?: IntFieldUpdateOperationsInput | number
    reelDailyLimit?: IntFieldUpdateOperationsInput | number
    reelDailyUsed?: IntFieldUpdateOperationsInput | number
    reelDailyDateKey?: StringFieldUpdateOperationsInput | string
    reelExtraBalance?: IntFieldUpdateOperationsInput | number
  }

  export type QuotaWalletUncheckedUpdateWithoutShopInput = {
    weeklyLiveBaseLimit?: IntFieldUpdateOperationsInput | number
    weeklyLiveUsed?: IntFieldUpdateOperationsInput | number
    weeklyLiveWeekKey?: StringFieldUpdateOperationsInput | string
    liveExtraBalance?: IntFieldUpdateOperationsInput | number
    reelDailyLimit?: IntFieldUpdateOperationsInput | number
    reelDailyUsed?: IntFieldUpdateOperationsInput | number
    reelDailyDateKey?: StringFieldUpdateOperationsInput | string
    reelExtraBalance?: IntFieldUpdateOperationsInput | number
  }

  export type QuotaTransactionUpsertWithWhereUniqueWithoutShopInput = {
    where: QuotaTransactionWhereUniqueInput
    update: XOR<QuotaTransactionUpdateWithoutShopInput, QuotaTransactionUncheckedUpdateWithoutShopInput>
    create: XOR<QuotaTransactionCreateWithoutShopInput, QuotaTransactionUncheckedCreateWithoutShopInput>
  }

  export type QuotaTransactionUpdateWithWhereUniqueWithoutShopInput = {
    where: QuotaTransactionWhereUniqueInput
    data: XOR<QuotaTransactionUpdateWithoutShopInput, QuotaTransactionUncheckedUpdateWithoutShopInput>
  }

  export type QuotaTransactionUpdateManyWithWhereWithoutShopInput = {
    where: QuotaTransactionScalarWhereInput
    data: XOR<QuotaTransactionUpdateManyMutationInput, QuotaTransactionUncheckedUpdateManyWithoutShopInput>
  }

  export type QuotaTransactionScalarWhereInput = {
    AND?: QuotaTransactionScalarWhereInput | QuotaTransactionScalarWhereInput[]
    OR?: QuotaTransactionScalarWhereInput[]
    NOT?: QuotaTransactionScalarWhereInput | QuotaTransactionScalarWhereInput[]
    txnId?: StringFilter<"QuotaTransaction"> | string
    shopId?: StringFilter<"QuotaTransaction"> | string
    resource?: EnumQuotaResourceFilter<"QuotaTransaction"> | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFilter<"QuotaTransaction"> | $Enums.QuotaDirection
    amount?: IntFilter<"QuotaTransaction"> | number
    reason?: EnumQuotaReasonFilter<"QuotaTransaction"> | $Enums.QuotaReason
    refType?: EnumQuotaRefTypeNullableFilter<"QuotaTransaction"> | $Enums.QuotaRefType | null
    refId?: StringNullableFilter<"QuotaTransaction"> | string | null
    actorType?: EnumQuotaActorTypeFilter<"QuotaTransaction"> | $Enums.QuotaActorType
    actorId?: StringNullableFilter<"QuotaTransaction"> | string | null
    createdAt?: DateTimeFilter<"QuotaTransaction"> | Date | string
  }

  export type PurchaseRequestUpsertWithWhereUniqueWithoutShopInput = {
    where: PurchaseRequestWhereUniqueInput
    update: XOR<PurchaseRequestUpdateWithoutShopInput, PurchaseRequestUncheckedUpdateWithoutShopInput>
    create: XOR<PurchaseRequestCreateWithoutShopInput, PurchaseRequestUncheckedCreateWithoutShopInput>
  }

  export type PurchaseRequestUpdateWithWhereUniqueWithoutShopInput = {
    where: PurchaseRequestWhereUniqueInput
    data: XOR<PurchaseRequestUpdateWithoutShopInput, PurchaseRequestUncheckedUpdateWithoutShopInput>
  }

  export type PurchaseRequestUpdateManyWithWhereWithoutShopInput = {
    where: PurchaseRequestScalarWhereInput
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopCreateWithoutStreamsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutStreamsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutStreamsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutStreamsInput, ShopUncheckedCreateWithoutStreamsInput>
  }

  export type ReportCreateWithoutStreamInput = {
    id?: string
    userId?: string | null
    reason: string
    status?: $Enums.ReportStatus
    resolved?: boolean
    createdAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutStreamInput = {
    id?: string
    userId?: string | null
    reason: string
    status?: $Enums.ReportStatus
    resolved?: boolean
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutStreamInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutStreamInput, ReportUncheckedCreateWithoutStreamInput>
  }

  export type ReportCreateManyStreamInputEnvelope = {
    data: ReportCreateManyStreamInput | ReportCreateManyStreamInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutStreamInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewUncheckedCreateWithoutStreamInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutStreamInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutStreamInput, ReviewUncheckedCreateWithoutStreamInput>
  }

  export type ReviewCreateManyStreamInputEnvelope = {
    data: ReviewCreateManyStreamInput | ReviewCreateManyStreamInput[]
    skipDuplicates?: boolean
  }

  export type AgendaCreateWithoutStreamInput = {
    id?: string
    user: UserCreateNestedOneWithoutAgendaInput
  }

  export type AgendaUncheckedCreateWithoutStreamInput = {
    id?: string
    userId: string
  }

  export type AgendaCreateOrConnectWithoutStreamInput = {
    where: AgendaWhereUniqueInput
    create: XOR<AgendaCreateWithoutStreamInput, AgendaUncheckedCreateWithoutStreamInput>
  }

  export type AgendaCreateManyStreamInputEnvelope = {
    data: AgendaCreateManyStreamInput | AgendaCreateManyStreamInput[]
    skipDuplicates?: boolean
  }

  export type ShopUpsertWithoutStreamsInput = {
    update: XOR<ShopUpdateWithoutStreamsInput, ShopUncheckedUpdateWithoutStreamsInput>
    create: XOR<ShopCreateWithoutStreamsInput, ShopUncheckedCreateWithoutStreamsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutStreamsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutStreamsInput, ShopUncheckedUpdateWithoutStreamsInput>
  }

  export type ShopUpdateWithoutStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutStreamInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutStreamInput, ReportUncheckedUpdateWithoutStreamInput>
    create: XOR<ReportCreateWithoutStreamInput, ReportUncheckedCreateWithoutStreamInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutStreamInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutStreamInput, ReportUncheckedUpdateWithoutStreamInput>
  }

  export type ReportUpdateManyWithWhereWithoutStreamInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutStreamInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    streamId?: StringFilter<"Report"> | string
    userId?: StringNullableFilter<"Report"> | string | null
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    resolved?: BoolFilter<"Report"> | boolean
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutStreamInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutStreamInput, ReviewUncheckedUpdateWithoutStreamInput>
    create: XOR<ReviewCreateWithoutStreamInput, ReviewUncheckedCreateWithoutStreamInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutStreamInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutStreamInput, ReviewUncheckedUpdateWithoutStreamInput>
  }

  export type ReviewUpdateManyWithWhereWithoutStreamInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutStreamInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    streamId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type AgendaUpsertWithWhereUniqueWithoutStreamInput = {
    where: AgendaWhereUniqueInput
    update: XOR<AgendaUpdateWithoutStreamInput, AgendaUncheckedUpdateWithoutStreamInput>
    create: XOR<AgendaCreateWithoutStreamInput, AgendaUncheckedCreateWithoutStreamInput>
  }

  export type AgendaUpdateWithWhereUniqueWithoutStreamInput = {
    where: AgendaWhereUniqueInput
    data: XOR<AgendaUpdateWithoutStreamInput, AgendaUncheckedUpdateWithoutStreamInput>
  }

  export type AgendaUpdateManyWithWhereWithoutStreamInput = {
    where: AgendaScalarWhereInput
    data: XOR<AgendaUpdateManyMutationInput, AgendaUncheckedUpdateManyWithoutStreamInput>
  }

  export type ShopCreateWithoutReelsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutReelsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutReelsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutReelsInput, ShopUncheckedCreateWithoutReelsInput>
  }

  export type ShopUpsertWithoutReelsInput = {
    update: XOR<ShopUpdateWithoutReelsInput, ShopUncheckedUpdateWithoutReelsInput>
    create: XOR<ShopCreateWithoutReelsInput, ShopUncheckedCreateWithoutReelsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutReelsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutReelsInput, ShopUncheckedUpdateWithoutReelsInput>
  }

  export type ShopUpdateWithoutReelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutReelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutSocialHandlesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutSocialHandlesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutSocialHandlesInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutSocialHandlesInput, ShopUncheckedCreateWithoutSocialHandlesInput>
  }

  export type ShopUpsertWithoutSocialHandlesInput = {
    update: XOR<ShopUpdateWithoutSocialHandlesInput, ShopUncheckedUpdateWithoutSocialHandlesInput>
    create: XOR<ShopCreateWithoutSocialHandlesInput, ShopUncheckedCreateWithoutSocialHandlesInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutSocialHandlesInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutSocialHandlesInput, ShopUncheckedUpdateWithoutSocialHandlesInput>
  }

  export type ShopUpdateWithoutSocialHandlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutSocialHandlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutWhatsappLinesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutWhatsappLinesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutWhatsappLinesInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutWhatsappLinesInput, ShopUncheckedCreateWithoutWhatsappLinesInput>
  }

  export type ShopUpsertWithoutWhatsappLinesInput = {
    update: XOR<ShopUpdateWithoutWhatsappLinesInput, ShopUncheckedUpdateWithoutWhatsappLinesInput>
    create: XOR<ShopCreateWithoutWhatsappLinesInput, ShopUncheckedCreateWithoutWhatsappLinesInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutWhatsappLinesInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutWhatsappLinesInput, ShopUncheckedUpdateWithoutWhatsappLinesInput>
  }

  export type ShopUpdateWithoutWhatsappLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutWhatsappLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type StreamCreateWithoutReviewsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutStreamsInput
    reports?: ReportCreateNestedManyWithoutStreamInput
    agenda?: AgendaCreateNestedManyWithoutStreamInput
  }

  export type StreamUncheckedCreateWithoutReviewsInput = {
    id?: string
    shopId: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutStreamInput
    agenda?: AgendaUncheckedCreateNestedManyWithoutStreamInput
  }

  export type StreamCreateOrConnectWithoutReviewsInput = {
    where: StreamWhereUniqueInput
    create: XOR<StreamCreateWithoutReviewsInput, StreamUncheckedCreateWithoutReviewsInput>
  }

  export type StreamUpsertWithoutReviewsInput = {
    update: XOR<StreamUpdateWithoutReviewsInput, StreamUncheckedUpdateWithoutReviewsInput>
    create: XOR<StreamCreateWithoutReviewsInput, StreamUncheckedCreateWithoutReviewsInput>
    where?: StreamWhereInput
  }

  export type StreamUpdateToOneWithWhereWithoutReviewsInput = {
    where?: StreamWhereInput
    data: XOR<StreamUpdateWithoutReviewsInput, StreamUncheckedUpdateWithoutReviewsInput>
  }

  export type StreamUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutStreamsNestedInput
    reports?: ReportUpdateManyWithoutStreamNestedInput
    agenda?: AgendaUpdateManyWithoutStreamNestedInput
  }

  export type StreamUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutStreamNestedInput
    agenda?: AgendaUncheckedUpdateManyWithoutStreamNestedInput
  }

  export type StreamCreateWithoutReportsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutStreamsInput
    reviews?: ReviewCreateNestedManyWithoutStreamInput
    agenda?: AgendaCreateNestedManyWithoutStreamInput
  }

  export type StreamUncheckedCreateWithoutReportsInput = {
    id?: string
    shopId: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutStreamInput
    agenda?: AgendaUncheckedCreateNestedManyWithoutStreamInput
  }

  export type StreamCreateOrConnectWithoutReportsInput = {
    where: StreamWhereUniqueInput
    create: XOR<StreamCreateWithoutReportsInput, StreamUncheckedCreateWithoutReportsInput>
  }

  export type StreamUpsertWithoutReportsInput = {
    update: XOR<StreamUpdateWithoutReportsInput, StreamUncheckedUpdateWithoutReportsInput>
    create: XOR<StreamCreateWithoutReportsInput, StreamUncheckedCreateWithoutReportsInput>
    where?: StreamWhereInput
  }

  export type StreamUpdateToOneWithWhereWithoutReportsInput = {
    where?: StreamWhereInput
    data: XOR<StreamUpdateWithoutReportsInput, StreamUncheckedUpdateWithoutReportsInput>
  }

  export type StreamUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutStreamsNestedInput
    reviews?: ReviewUpdateManyWithoutStreamNestedInput
    agenda?: AgendaUpdateManyWithoutStreamNestedInput
  }

  export type StreamUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutStreamNestedInput
    agenda?: AgendaUncheckedUpdateManyWithoutStreamNestedInput
  }

  export type ShopCreateWithoutPenaltiesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutPenaltiesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutPenaltiesInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutPenaltiesInput, ShopUncheckedCreateWithoutPenaltiesInput>
  }

  export type ShopUpsertWithoutPenaltiesInput = {
    update: XOR<ShopUpdateWithoutPenaltiesInput, ShopUncheckedUpdateWithoutPenaltiesInput>
    create: XOR<ShopCreateWithoutPenaltiesInput, ShopUncheckedCreateWithoutPenaltiesInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutPenaltiesInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutPenaltiesInput, ShopUncheckedUpdateWithoutPenaltiesInput>
  }

  export type ShopUpdateWithoutPenaltiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutPenaltiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UserCreateWithoutFavoritesInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    agenda?: AgendaCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    agenda?: AgendaUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type ShopCreateWithoutFavoritesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutFavoritesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutFavoritesInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutFavoritesInput, ShopUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agenda?: AgendaUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agenda?: AgendaUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShopUpsertWithoutFavoritesInput = {
    update: XOR<ShopUpdateWithoutFavoritesInput, ShopUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ShopCreateWithoutFavoritesInput, ShopUncheckedCreateWithoutFavoritesInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutFavoritesInput, ShopUncheckedUpdateWithoutFavoritesInput>
  }

  export type ShopUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UserCreateWithoutAgendaInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgendaInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgendaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgendaInput, UserUncheckedCreateWithoutAgendaInput>
  }

  export type StreamCreateWithoutAgendaInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    shop: ShopCreateNestedOneWithoutStreamsInput
    reports?: ReportCreateNestedManyWithoutStreamInput
    reviews?: ReviewCreateNestedManyWithoutStreamInput
  }

  export type StreamUncheckedCreateWithoutAgendaInput = {
    id?: string
    shopId: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutStreamInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutStreamInput
  }

  export type StreamCreateOrConnectWithoutAgendaInput = {
    where: StreamWhereUniqueInput
    create: XOR<StreamCreateWithoutAgendaInput, StreamUncheckedCreateWithoutAgendaInput>
  }

  export type UserUpsertWithoutAgendaInput = {
    update: XOR<UserUpdateWithoutAgendaInput, UserUncheckedUpdateWithoutAgendaInput>
    create: XOR<UserCreateWithoutAgendaInput, UserUncheckedCreateWithoutAgendaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgendaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgendaInput, UserUncheckedUpdateWithoutAgendaInput>
  }

  export type UserUpdateWithoutAgendaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgendaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StreamUpsertWithoutAgendaInput = {
    update: XOR<StreamUpdateWithoutAgendaInput, StreamUncheckedUpdateWithoutAgendaInput>
    create: XOR<StreamCreateWithoutAgendaInput, StreamUncheckedCreateWithoutAgendaInput>
    where?: StreamWhereInput
  }

  export type StreamUpdateToOneWithWhereWithoutAgendaInput = {
    where?: StreamWhereInput
    data: XOR<StreamUpdateWithoutAgendaInput, StreamUncheckedUpdateWithoutAgendaInput>
  }

  export type StreamUpdateWithoutAgendaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutStreamsNestedInput
    reports?: ReportUpdateManyWithoutStreamNestedInput
    reviews?: ReviewUpdateManyWithoutStreamNestedInput
  }

  export type StreamUncheckedUpdateWithoutAgendaInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutStreamNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutStreamNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    agenda?: AgendaCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    agenda?: AgendaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    agenda?: AgendaUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    agenda?: AgendaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShopCreateWithoutQuotaWalletInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutQuotaWalletInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutQuotaWalletInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutQuotaWalletInput, ShopUncheckedCreateWithoutQuotaWalletInput>
  }

  export type ShopUpsertWithoutQuotaWalletInput = {
    update: XOR<ShopUpdateWithoutQuotaWalletInput, ShopUncheckedUpdateWithoutQuotaWalletInput>
    create: XOR<ShopCreateWithoutQuotaWalletInput, ShopUncheckedCreateWithoutQuotaWalletInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutQuotaWalletInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutQuotaWalletInput, ShopUncheckedUpdateWithoutQuotaWalletInput>
  }

  export type ShopUpdateWithoutQuotaWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutQuotaWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutQuotaTransactionsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutQuotaTransactionsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutQuotaTransactionsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutQuotaTransactionsInput, ShopUncheckedCreateWithoutQuotaTransactionsInput>
  }

  export type ShopUpsertWithoutQuotaTransactionsInput = {
    update: XOR<ShopUpdateWithoutQuotaTransactionsInput, ShopUncheckedUpdateWithoutQuotaTransactionsInput>
    create: XOR<ShopCreateWithoutQuotaTransactionsInput, ShopUncheckedCreateWithoutQuotaTransactionsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutQuotaTransactionsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutQuotaTransactionsInput, ShopUncheckedUpdateWithoutQuotaTransactionsInput>
  }

  export type ShopUpdateWithoutQuotaTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutQuotaTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutPurchaseRequestsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authUser?: AuthUserCreateNestedOneWithoutShopInput
    streams?: StreamCreateNestedManyWithoutShopInput
    reels?: ReelCreateNestedManyWithoutShopInput
    penalties?: PenaltyCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineCreateNestedManyWithoutShopInput
    favorites?: FavoriteCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutPurchaseRequestsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    website?: string | null
    authUserId?: string | null
    requiresEmailFix?: boolean
    razonSocial?: string | null
    cuit?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: number | null
    paymentMethods?: ShopCreatepaymentMethodsInput | string[]
    plan?: string
    status?: $Enums.ShopStatus
    statusReason?: string | null
    statusChangedAt?: Date | string | null
    agendaSuspendedUntil?: Date | string | null
    agendaSuspendedByAdminId?: string | null
    agendaSuspendedReason?: string | null
    streamQuota?: number
    reelQuota?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    streams?: StreamUncheckedCreateNestedManyWithoutShopInput
    reels?: ReelUncheckedCreateNestedManyWithoutShopInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutShopInput
    socialHandles?: ShopSocialHandleUncheckedCreateNestedManyWithoutShopInput
    whatsappLines?: ShopWhatsappLineUncheckedCreateNestedManyWithoutShopInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutShopInput
    quotaWallet?: QuotaWalletUncheckedCreateNestedOneWithoutShopInput
    quotaTransactions?: QuotaTransactionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutPurchaseRequestsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutPurchaseRequestsInput, ShopUncheckedCreateWithoutPurchaseRequestsInput>
  }

  export type AdminCreateWithoutApprovedPurchaseRequestsInput = {
    role?: $Enums.AdminRole
    adminStatus?: $Enums.AdminStatus
    createdAt?: Date | string
    authUser: AuthUserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutApprovedPurchaseRequestsInput = {
    authUserId: string
    role?: $Enums.AdminRole
    adminStatus?: $Enums.AdminStatus
    createdAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutApprovedPurchaseRequestsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutApprovedPurchaseRequestsInput, AdminUncheckedCreateWithoutApprovedPurchaseRequestsInput>
  }

  export type ShopUpsertWithoutPurchaseRequestsInput = {
    update: XOR<ShopUpdateWithoutPurchaseRequestsInput, ShopUncheckedUpdateWithoutPurchaseRequestsInput>
    create: XOR<ShopCreateWithoutPurchaseRequestsInput, ShopUncheckedCreateWithoutPurchaseRequestsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutPurchaseRequestsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutPurchaseRequestsInput, ShopUncheckedUpdateWithoutPurchaseRequestsInput>
  }

  export type ShopUpdateWithoutPurchaseRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneWithoutShopNestedInput
    streams?: StreamUpdateManyWithoutShopNestedInput
    reels?: ReelUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutPurchaseRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    authUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresEmailFix?: BoolFieldUpdateOperationsInput | boolean
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    addressDetails?: NullableJsonNullValueInput | InputJsonValue
    minimumPurchase?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethods?: ShopUpdatepaymentMethodsInput | string[]
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumShopStatusFieldUpdateOperationsInput | $Enums.ShopStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    statusChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agendaSuspendedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    agendaSuspendedReason?: NullableStringFieldUpdateOperationsInput | string | null
    streamQuota?: IntFieldUpdateOperationsInput | number
    reelQuota?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streams?: StreamUncheckedUpdateManyWithoutShopNestedInput
    reels?: ReelUncheckedUpdateManyWithoutShopNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutShopNestedInput
    socialHandles?: ShopSocialHandleUncheckedUpdateManyWithoutShopNestedInput
    whatsappLines?: ShopWhatsappLineUncheckedUpdateManyWithoutShopNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutShopNestedInput
    quotaWallet?: QuotaWalletUncheckedUpdateOneWithoutShopNestedInput
    quotaTransactions?: QuotaTransactionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type AdminUpsertWithoutApprovedPurchaseRequestsInput = {
    update: XOR<AdminUpdateWithoutApprovedPurchaseRequestsInput, AdminUncheckedUpdateWithoutApprovedPurchaseRequestsInput>
    create: XOR<AdminCreateWithoutApprovedPurchaseRequestsInput, AdminUncheckedCreateWithoutApprovedPurchaseRequestsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutApprovedPurchaseRequestsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutApprovedPurchaseRequestsInput, AdminUncheckedUpdateWithoutApprovedPurchaseRequestsInput>
  }

  export type AdminUpdateWithoutApprovedPurchaseRequestsInput = {
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authUser?: AuthUserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutApprovedPurchaseRequestsInput = {
    authUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    adminStatus?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestCreateManyApprovedByAdminInput = {
    purchaseId?: string
    shopId: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    paymentProofUrl?: string | null
    notes?: string | null
  }

  export type PurchaseRequestUpdateWithoutApprovedByAdminInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shop?: ShopUpdateOneRequiredWithoutPurchaseRequestsNestedInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutApprovedByAdminInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutApprovedByAdminInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FavoriteCreateManyUserInput = {
    id?: string
    shopId: string
  }

  export type AgendaCreateManyUserInput = {
    id?: string
    streamId: string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type FavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stream?: StreamUpdateOneRequiredWithoutAgendaNestedInput
  }

  export type AgendaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamCreateManyShopInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StreamStatus
    scheduledAt?: Date | string
    scheduledEndPlanned?: Date | string | null
    timezone?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    durationMinutes?: number | null
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    hidden?: boolean
    visibilityReason?: string | null
    platform?: $Enums.SocialPlatform
    url?: string | null
    extensionCount?: number
    reportCount?: number
    editCount?: number
    lastEditedAt?: Date | string | null
    originalScheduledAt?: Date | string | null
    reprogrammedFromId?: string | null
    reprogramReason?: string | null
    pendingReprogramNote?: string | null
    reprogramBatchId?: string | null
    createdAt?: Date | string
  }

  export type ReelCreateManyShopInput = {
    id?: string
    url: string
    platform?: $Enums.SocialPlatform
    hidden?: boolean
    views?: number
    createdAt?: Date | string
  }

  export type PenaltyCreateManyShopInput = {
    id?: string
    reason: string
    active?: boolean
    createdAt?: Date | string
  }

  export type ShopSocialHandleCreateManyShopInput = {
    id?: string
    platform: $Enums.SocialPlatform
    handle: string
    createdAt?: Date | string
  }

  export type ShopWhatsappLineCreateManyShopInput = {
    id?: string
    label: string
    number: string
    createdAt?: Date | string
  }

  export type FavoriteCreateManyShopInput = {
    id?: string
    userId: string
  }

  export type QuotaTransactionCreateManyShopInput = {
    txnId?: string
    resource: $Enums.QuotaResource
    direction: $Enums.QuotaDirection
    amount: number
    reason: $Enums.QuotaReason
    refType?: $Enums.QuotaRefType | null
    refId?: string | null
    actorType: $Enums.QuotaActorType
    actorId?: string | null
    createdAt?: Date | string
  }

  export type PurchaseRequestCreateManyShopInput = {
    purchaseId?: string
    type: $Enums.PurchaseType
    quantity: number
    status?: $Enums.PurchaseStatus
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedByAdminId?: string | null
    paymentProofUrl?: string | null
    notes?: string | null
  }

  export type StreamUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutStreamNestedInput
    reviews?: ReviewUpdateManyWithoutStreamNestedInput
    agenda?: AgendaUpdateManyWithoutStreamNestedInput
  }

  export type StreamUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutStreamNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutStreamNestedInput
    agenda?: AgendaUncheckedUpdateManyWithoutStreamNestedInput
  }

  export type StreamUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEndPlanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    visibilityReason?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extensionCount?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    editCount?: IntFieldUpdateOperationsInput | number
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalScheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reprogrammedFromId?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramReason?: NullableStringFieldUpdateOperationsInput | string | null
    pendingReprogramNote?: NullableStringFieldUpdateOperationsInput | string | null
    reprogramBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReelUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    hidden?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReelUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    hidden?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReelUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    hidden?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopSocialHandleUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopSocialHandleUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopSocialHandleUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopWhatsappLineUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopWhatsappLineUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopWhatsappLineUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type QuotaTransactionUpdateWithoutShopInput = {
    txnId?: StringFieldUpdateOperationsInput | string
    resource?: EnumQuotaResourceFieldUpdateOperationsInput | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFieldUpdateOperationsInput | $Enums.QuotaDirection
    amount?: IntFieldUpdateOperationsInput | number
    reason?: EnumQuotaReasonFieldUpdateOperationsInput | $Enums.QuotaReason
    refType?: NullableEnumQuotaRefTypeFieldUpdateOperationsInput | $Enums.QuotaRefType | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumQuotaActorTypeFieldUpdateOperationsInput | $Enums.QuotaActorType
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotaTransactionUncheckedUpdateWithoutShopInput = {
    txnId?: StringFieldUpdateOperationsInput | string
    resource?: EnumQuotaResourceFieldUpdateOperationsInput | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFieldUpdateOperationsInput | $Enums.QuotaDirection
    amount?: IntFieldUpdateOperationsInput | number
    reason?: EnumQuotaReasonFieldUpdateOperationsInput | $Enums.QuotaReason
    refType?: NullableEnumQuotaRefTypeFieldUpdateOperationsInput | $Enums.QuotaRefType | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumQuotaActorTypeFieldUpdateOperationsInput | $Enums.QuotaActorType
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotaTransactionUncheckedUpdateManyWithoutShopInput = {
    txnId?: StringFieldUpdateOperationsInput | string
    resource?: EnumQuotaResourceFieldUpdateOperationsInput | $Enums.QuotaResource
    direction?: EnumQuotaDirectionFieldUpdateOperationsInput | $Enums.QuotaDirection
    amount?: IntFieldUpdateOperationsInput | number
    reason?: EnumQuotaReasonFieldUpdateOperationsInput | $Enums.QuotaReason
    refType?: NullableEnumQuotaRefTypeFieldUpdateOperationsInput | $Enums.QuotaRefType | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumQuotaActorTypeFieldUpdateOperationsInput | $Enums.QuotaActorType
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUpdateWithoutShopInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByAdmin?: AdminUpdateOneWithoutApprovedPurchaseRequestsNestedInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutShopInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutShopInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateManyStreamInput = {
    id?: string
    userId?: string | null
    reason: string
    status?: $Enums.ReportStatus
    resolved?: boolean
    createdAt?: Date | string
  }

  export type ReviewCreateManyStreamInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type AgendaCreateManyStreamInput = {
    id?: string
    userId: string
  }

  export type ReportUpdateWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaUpdateWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAgendaNestedInput
  }

  export type AgendaUncheckedUpdateWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaUncheckedUpdateManyWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AdminCountOutputTypeDefaultArgs instead
     */
    export type AdminCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopCountOutputTypeDefaultArgs instead
     */
    export type ShopCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StreamCountOutputTypeDefaultArgs instead
     */
    export type StreamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StreamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthUserDefaultArgs instead
     */
    export type AuthUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopDefaultArgs instead
     */
    export type ShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StreamDefaultArgs instead
     */
    export type StreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StreamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReelDefaultArgs instead
     */
    export type ReelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopSocialHandleDefaultArgs instead
     */
    export type ShopSocialHandleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopSocialHandleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopWhatsappLineDefaultArgs instead
     */
    export type ShopWhatsappLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopWhatsappLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PenaltyDefaultArgs instead
     */
    export type PenaltyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PenaltyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FavoriteDefaultArgs instead
     */
    export type FavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FavoriteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgendaDefaultArgs instead
     */
    export type AgendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgendaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuotaWalletDefaultArgs instead
     */
    export type QuotaWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuotaWalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuotaTransactionDefaultArgs instead
     */
    export type QuotaTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuotaTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseRequestDefaultArgs instead
     */
    export type PurchaseRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseRequestDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}